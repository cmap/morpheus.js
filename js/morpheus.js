(function(global){
'use strict';
/**
 * @name morpheus
 * @namespace
 */
var morpheus = (typeof morpheus !== 'undefined') ? morpheus : {};
if (typeof module !== 'undefined' && module.exports) {
  module.exports = morpheus; // Node
} else if (typeof define === 'function' && define.amd) {
  define(function () { // AMD module
    return morpheus;
  });
} else {
  global.morpheus = morpheus; // browser global
}
morpheus.Util = function () {
};

morpheus.Util.URL = 'https://clue.io/morpheus/';
morpheus.Util.RIGHT_ARROW = String.fromCharCode(8594);
/**
 * Add properties in c2 to c1
 *
 * @param {Object}
 *            c1 The object that will inherit from obj2
 * @param {Object}
 *            c2 The object that obj1 inherits from
 */
morpheus.Util.extend = function (c1, c2) {
  for (var key in c2.prototype) {
    if (!(key in c1.prototype)) {
      c1.prototype[key] = c2.prototype[key];
    }
  }
};
morpheus.Util.isFetchSupported = function () {
  return navigator.userAgent.indexOf('Chrome') !== -1;
};

morpheus.Util.viewPortSize = function () {
  return window.getComputedStyle(document.body, ':before').content.replace(
    /"/g, '');
};

morpheus.Util.TRACKING_CODE_LOADED = false;
morpheus.Util.loadTrackingCode = function () {
  if (typeof window !== 'undefined' && typeof navigator !== 'undefined' && navigator.onLine) {
    if (morpheus.Util.TRACKING_CODE_LOADED) {
      return;
    } else if (typeof ga === 'undefined') {
      morpheus.Util.TRACKING_CODE_LOADED = true;
      (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r;
        i[r] = i[r] || function () {
            (i[r].q = i[r].q || []).push(arguments);
          }, i[r].l = 1 * new Date();
        a = s.createElement(o),
          m = s.getElementsByTagName(o)[0];
        a.async = 1;
        a.src = g;
        m.parentNode.insertBefore(a, m);
      })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
    }
    if (typeof ga !== 'undefined') {
      ga('create', 'UA-53973555-1', 'auto', 'morpheus');
      ga('morpheus.send', 'pageview');
    }
    morpheus.Util.TRACKING_CODE_LOADED = true;
  }
};

morpheus.Util.measureScrollbar = function () {
  var $c = $(
    '<div style=\'position:absolute; top:-10000px; left:-10000px; width:100px; height:100px; overflow:scroll;\'></div>')
    .appendTo('body');
  var dim = {
    width: Math.max(0, $c.width() - $c[0].clientWidth),
    height: $c.height() - $c[0].clientHeight
  };
  $c.remove();
  return dim;
};
morpheus.Util.trackEvent = function (options) {
  if (typeof window !== 'undefined') {
    if (!morpheus.Util.TRACKING_CODE_LOADED) {
      morpheus.Util.loadTrackingCode();
    }
    if (morpheus.Util.TRACKING_CODE_LOADED && typeof ga !== 'undefined') {
      ga('morpheus.send', {
        hitType: 'event',
        eventCategory: options.eventCategory,
        eventAction: options.eventAction,
        eventLabel: options.eventLabel
      });
    }
  }

};

morpheus.Util.isString = function (value) {
  return typeof value === 'string' || value instanceof String;
};
/**
 *
 * @param val The value to determine the data type for.
 * @return {String} One of string, number, object, [string], [number], [object]
 */
morpheus.Util.getDataType = function (val) {
  var dataType;
  var isArray = morpheus.Util.isArray(val);
  if (isArray && val.length > 0) {
    val = val[0];
  }
  if (morpheus.Util.isString(val)) {
    dataType = 'string';
  } else if (_.isNumber(val)) {
    dataType = 'number';
  } else {
    dataType = 'object';
  }
  if (isArray) {
    dataType = '[' + dataType + ']';
  }
  return dataType;
};

/**
 * Checks whether supplied argument is an array
 */
morpheus.Util.isArray = function (array) {
  var types = [Array, Int8Array, Uint8Array, Uint8ClampedArray, Int16Array,
    Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array,];
  // handle native arrays
  for (var i = 0, length = types.length; i < length; i++) {
    if (array instanceof types[i]) {
      return true;
    }
  }
  return false;
};
morpheus.Util.getWindowSearchObject = function () {
  var searchObject = {};
  var hashObject = {};
  if (window.location.search.length > 0) {
    searchObject = morpheus.Util.getQueryParams(window.location.search
      .substring(1));
  }
  if (window.location.hash.length > 0) {
    hashObject = morpheus.Util.getQueryParams(window.location.hash
      .substring(1));
  }
  return _.extend(hashObject, searchObject);
};

morpheus.Util.copyString = function (s) {
  return (' ' + s).substr(1);
  //return (' ' + s).slice(1);
  // var copy = [];
  // for (var i = 0, end = s.length; i < end; i++) {
  // 	copy.push(s[i]);
  // }
  // return copy.join('');
};
morpheus.Util.getQueryParams = function (s) {
  var params = {};
  if (!s) {
    return params;
  }
  var search = decodeURIComponent(s);
  var keyValuePairs = search.split('&');
  for (var i = 0; i < keyValuePairs.length; i++) {
    var pair = keyValuePairs[i].split('=');
    if (pair[1] != null && pair[1] !== '') {
      var array = params[pair[0]];
      if (array === undefined) {
        array = [];
        params[pair[0]] = array;
      }
      array.push(pair[1]);
    }
  }
  return params;
};
morpheus.Util.getScriptPath = function (name) {
  if (!name) {
    name = 'morpheus-latest.min.js';
  }
  var scripts = document.getElementsByTagName('script');
  for (var i = scripts.length - 1; i >= 0; i--) {
    var src = scripts[i].src;
    var index = src.lastIndexOf('/');
    if (index !== -1) {
      src = src.substring(index + 1);
    }
    if (src === name) {
      return scripts[i].src;
    }
  }

  // not found
  if (name === 'morpheus-latest.min.js') {
    return morpheus.Util.getScriptPath('morpheus.js');
  }
  // return 1st script
  return scripts.length > 0 ? scripts[0].src : '';
};

morpheus.Util.forceDelete = function (obj) {
  try {
    var _garbageCollector = (function () {
      var ef = URL.createObjectURL(new Blob([''], {
        type: 'text/javascript'
      })), w = new Worker(ef);

      URL.revokeObjectURL(ef);
      return w;
    })();

    _garbageCollector.postMessage(obj, [obj]);
  }
  catch (x) {
    console.log('Unable to delete');
  }
};
morpheus.Util.getFileName = function (fileOrUrl) {
  if (fileOrUrl instanceof File) {
    return fileOrUrl.name;
  }
  var name = '' + fileOrUrl;
  var question = name.indexOf('?');
  if (question !== -1) {
    var params = name.substring(question + 1);
    var keyValuePairs = decodeURIComponent(params).split('&');

    // check for parameters in name
    for (var i = 0; i < keyValuePairs.length; i++) {
      var pair = keyValuePairs[i].split('=');
      if (pair[0] === 'file' || pair[0] === 'name') {
        name = pair[1];
        break;
      }
    }
  } else {
    var slash = name.lastIndexOf('/');
    if (slash === name.length - 1) {
      name = name.substring(0, name.length - 1);
      slash = name.lastIndexOf('/');
    }
    if (slash !== -1) {
      name = name.substring(slash + 1); // get stuff after slash
      // https://s3.amazonaws.com/data.clue.io/icv/dosval/BRD-K45711268_10_UM_24_H/pcl_cell.gct?AWSAccessKeyId=AKIAJZQISWLUKFS3VUKA&Expires=1455761050&Signature=HVle9MvXV3OGRZHOngdm2frqER8%3D

    }
  }
  return name;
};
morpheus.Util.prefixWithZero = function (value) {
  return value < 10 ? '0' + value : value;
};
morpheus.Util.getExtension = function (name) {
  name = '' + name;
  var dotIndex = name.lastIndexOf('.');
  if (dotIndex > 0) {
    var suffix = name.substring(dotIndex + 1).toLowerCase();
    if (suffix === 'txt' || suffix === 'gz' || suffix === 'tsv') { // see if file is in
      // the form
      // name.gct.txt
      var newPath = name.substring(0, dotIndex);
      var secondDotIndex = newPath.lastIndexOf('.');
      if (secondDotIndex > 0) {// see if file has another suffix
        var secondSuffix = newPath.substring(secondDotIndex + 1,
          newPath.length).toLowerCase();
        if (secondSuffix === 'segtab' || secondSuffix === 'seg'
          || secondSuffix === 'maf' || secondSuffix === 'gct'
          || secondSuffix === 'txt' || secondSuffix === 'gmt') {
          return secondSuffix;
        }
      }
    }
    return suffix;
  }
  return '';
};
/**
 * Gets the base file name. For example, if name is 'test.txt' the method
 * returns the string 'test'. If the name is 'test.txt.gz', the method also
 * returns the string 'test'.
 *
 * @param name
 *            The file name.
 * @return The base file name.
 */
morpheus.Util.getBaseFileName = function (name) {
  var dotIndex = name.lastIndexOf('.');
  if (dotIndex > 0) {
    var suffix = name.substring(dotIndex + 1, name.length);
    if (suffix === 'gz' || suffix === 'zip' || suffix === 'bz2') {
      return morpheus.Util.getBaseFileName(name.substring(0, dotIndex));
    }
    return name.substring(0, dotIndex);
  }
  return name;
};
morpheus.Util.seq = function (length) {
  var array = [];
  for (var i = 0; i < length; i++) {
    array.push(i);
  }
  return array;
};

morpheus.Util.sequ32 = function (length) {
  var array = new Uint32Array(length);
  for (var i = 0; i < length; i++) {
    array[i] = i;
  }
  return array;
};

/**
 * Converts window hash or search to an object that maps keys to an array of
 * values. For example ?foo=bar returns {foo:[bar]}
 */
morpheus.Util.paramsToObject = function (hash) {
  var search = hash ? window.location.hash : window.location.search;
  if (search.length <= 1) {
    return {};
  }
  search = decodeURIComponent(search);
  var keyValuePairs = search.substring(1).split('&');
  var result = {};
  for (var i = 0, length = keyValuePairs.length; i < length; i++) {
    var pair = keyValuePairs[i].split('=');
    var values = result[pair[0]];
    if (values === undefined) {
      values = [];
      result[pair[0]] = values;
    }
    values.push(pair[1]);
  }
  return result;
};
morpheus.Util.endsWith = function (string, suffix) {
  return string.length >= suffix.length
    && string.substr(string.length - suffix.length) === suffix;
};
morpheus.Util.measureSvgText = function (text, classname) {
  if (!text || text.length === 0)
    return {
      height: 0,
      width: 0
    };
  var container = d3.select('body').append('svg');
  if (classname) {
    container.attr('class', classname);
  }
  container.append('text').attr({
    x: -1000,
    y: -1000
  }).text(text);
  var bbox = container.node().getBBox();
  container.remove();
  return {
    height: bbox.height,
    width: bbox.width
  };
};
morpheus.Util.IS_MAC = false;
if (typeof navigator !== 'undefined') {
  morpheus.Util.IS_MAC = navigator.platform.match(/(Mac|iPhone|iPod|iPad)/i) ? true
    : false;
}
morpheus.Util.COMMAND_KEY = morpheus.Util.IS_MAC ? '&#8984;' : 'Ctrl+';

morpheus.Util.hammer = function (el, recognizers) {
  var hammer = new Hammer(el, {
    recognizers: []
  });

  if (_.indexOf(recognizers, 'pan') !== -1) {
    hammer.add(new Hammer.Pan({
      threshold: 1,
      direction: Hammer.DIRECTION_ALL
    }));
  } else if (_.indexOf(recognizers, 'panh') !== -1) {
    hammer.add(new Hammer.Pan({
      threshold: 1,
      direction: Hammer.DIRECTION_HORIZONTAL
    }));
  } else if (_.indexOf(recognizers, 'panv') !== -1) {
    hammer.add(new Hammer.Pan({
      threshold: 1,
      direction: Hammer.DIRECTION_VERTICAL
    }));
  }
  if (_.indexOf(recognizers, 'tap') !== -1) {
    // var singleTap = new Hammer.Tap({
    // event : 'singletap',
    // interval : 50
    // });
    // var doubleTap = new Hammer.Tap({
    // event : 'doubletap',
    // taps : 2
    // });
    // doubleTap.recognizeWith(singleTap);
    // singleTap.requireFailure([ doubleTap ]);
    // hammer.add([ doubleTap, singleTap ]);
    hammer.add(new Hammer.Tap());
  }
  if (_.indexOf(recognizers, 'pinch') !== -1) {
    hammer.add(new Hammer.Pinch());
  }
  if (_.indexOf(recognizers, 'longpress') !== -1) {
    hammer.add(new Hammer.Press({
      event: 'longpress',
      time: 1000
    }));
  }
  if (_.indexOf(recognizers, 'press') !== -1) {
    hammer.add(new Hammer.Press());
  }

  return hammer;
};
morpheus.Util.autocompleteArrayMatcher = function (token, cb, array, fields, max) {
  var filteredSet = new morpheus.Set();
  var regex = new RegExp(morpheus.Util.escapeRegex(token), 'i');
  var regexMatch = new RegExp('(' + morpheus.Util.escapeRegex(token) + ')', 'i');
  // iterate through the pool of strings and for any string that
  // contains the substring `q`, add it to the `matches` array
  if (fields) {
    var nfields = fields.length;
    for (var i = 0, n = array.length; i < n; i++) {
      var item = array[i];
      for (var j = 0; j < nfields; j++) {
        var field = fields[j];
        var value = item[field];
        if (regex.test(value)) {
          filteredSet.add(value);
          break;
        }
      }
      if (filteredSet.size() === max) {
        break;
      }
    }
  } else {
    for (var i = 0, n = array.length; i < n; i++) {
      var value = array[i];
      if (regex.test(value)) {
        filteredSet.add(value);
        if (filteredSet.size() === max) {
          break;
        }
      }

    }
  }
  var matches = [];

  filteredSet.forEach(function (value) {
    var quotedValue = value;
    if (quotedValue.indexOf(' ') !== -1) {
      quotedValue = '"' + quotedValue + '"';
    }
    matches.push({
      value: quotedValue,
      label: '<span>' + value.replace(regexMatch, '<b>$1</b>')
      + '</span>'
    });
  });

  cb(matches);
};

/**
 *
 * @param array. Array of format,data
 */
morpheus.Util.setClipboardData = function (clipboardData, delay) {
  var isRTL = document.documentElement.getAttribute('dir') == 'rtl';
  var fakeElem = document.createElement('div');
  fakeElem.contentEditable = true;

  // Prevent zooming on iOS
  fakeElem.style.fontSize = '12pt';
  // Reset box model

  fakeElem.style.border = '0';
  fakeElem.style.padding = '0';
  fakeElem.style.margin = '0';
  // Move element out of screen horizontally
  fakeElem.style.position = 'absolute';
  fakeElem.style[isRTL ? 'right' : 'left'] = '-999999px';
  // Move element to the same position vertically
  fakeElem.style.top = (window.pageYOffset || document.documentElement.scrollTop) + 'px';
  fakeElem.setAttribute('readonly', '');
  //fakeElem.innerHTML = html;
  var f = function (e) {
    clipboardData.forEach(function (elem) {
      e.clipboardData.setData(elem.format, elem.data);
    });

    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();
    fakeElem.removeEventListener('copy', f);
  };
  fakeElem.addEventListener('copy', f);

  document.body.appendChild(fakeElem);
  // if (fakeElem.hasAttribute('contenteditable')) {
  fakeElem.focus();
  // }
  var selection = window.getSelection();
  var range = document.createRange();
  range.selectNodeContents(fakeElem);
  selection.removeAllRanges();
  selection.addRange(range);
  if (delay) {
    setTimeout(function () {
      if (!document.execCommand('copy')) {
        console.log('copy failed');
      }
      document.body.removeChild(fakeElem);
    }, 20);
  } else {
    if (!document.execCommand('copy')) {
      console.log('copy failed');
    }
    document.body.removeChild(fakeElem);
  }
};

/**
 * @param {Number}
 *            [options.delay=500] - Delay to short autosuggestions.
 * @param {jQuery}
 *            options.$el - Text box to apply autosuggest to.
 * @param {Function}
 *            options.filter - Callback to invoke to filter a suggested term.
 *            Invoked with array of tokens and response.
 * @param {Function}
 *            options.select - Callback to invoke when a suggested term is
 *            selected.
 * @param {Boolean}
 *            [options.multi=true] - Whether to allow more than one search term.
 * @param {Boolean}
 *            [options.suggestWhenEmpty=true] - Whether to autosuggest terms
 *            when text field is empty.
 *
 */
morpheus.Util.autosuggest = function (options) {
  options = $.extend({}, {
    multi: true,
    delay: 500,
    minLength: 0,
    suggestWhenEmpty: true,
  }, options);

  var searching = false;

  function _select(event, ui, isKey) {
    if (ui.item.skip) {
      return false;
    }
    if (options.multi) {
      var terms = morpheus.Util
        .getAutocompleteTokens(
          options.$el[0].value,
          {
            trim: false,
            selectionStart: options.$el[0].selectionStart
          });

      var field = (event.toElement && event.toElement.dataset) ? event.toElement.dataset.autocomplete : null;
      var value = field ? ui.item[field] : ui.item.value;
      var show = ui.item.show;

      // replace the current input
      if (terms.length === 0) {
        terms.push(value);
      } else if (ui.item.clear) {
        terms = [value];
      } else {
        terms[terms.selectionStartIndex === -1
        || terms.selectionStartIndex === undefined ? terms.length - 1
          : terms.selectionStartIndex] = value;
      }
      // add the selected item
      options.$el[0].value = terms.join(' ');
      if ((show && !isKey) || (isKey && event.which === 13)) { // did
        // we
        // select
        // just a
        // field name?
        searching = true;
        setTimeout(function () {
          options.$el.autocomplete('search',
            options.$el.val());
        }, 20);
        setTimeout(function () {
          searching = false;
        }, 100);

      }
      if (!isKey && options.select) {
        options.select();
      }
      return false;
    }
    if (!isKey && options.select) {
      options.select();
    }
    if (!isKey && event.which === 13) {
      event.stopImmediatePropagation();
    }
  }

  options.$el
  // don't navigate away from the field on tab when selecting an item
    .on(
      'keydown',
      function (event) {
        if ((event.keyCode === $.ui.keyCode.TAB)
          && $(this).data('ui-autocomplete').menu.active) {
          event.preventDefault();
        }
      })
    .autocomplete(
      {
        minLength: options.minLength,
        delay: options.delay,
        source: function (request, response) {
          if (request.term.history && options.history) {
            return options.history(response);
          }
          // delegate back to autocomplete, but extract the
          // autocomplete term
          var terms = morpheus.Util
            .getAutocompleteTokens(
              request.term,
              {
                trim: false,
                selectionStart: options.$el[0].selectionStart
              });

          if (terms.selectionStartIndex === undefined
            || terms.selectionStartIndex === -1) {
            terms.selectionStartIndex = terms.length - 1;
          }
          if (options.suggestWhenEmpty || terms.length > 0) {
            options.filter(terms, response);
          }
        },
        focus: function (event, ui) {
          var original = event.originalEvent;
          while (original.originalEvent != null) {
            original = original.originalEvent;
          }
          if (original && /^key/.test(original.type)) {
            return _select(original, ui, true);
          }
          return false;
        },
        select: function (event, ui) {
          return _select(event, ui, false);
        }
      });

  // use html for label instead of default text, class for categories vs. items
  var instance = options.$el.autocomplete('instance');
  if (instance != null) {
    instance._renderItem = function (ul, item) {
      if (item.value == null) { // category
        return $('<li class="' + (item.class ? (' ' + item.class) : '') + ' search-category">')
          .append($('<div>').html(item.label))
          .appendTo(ul);
      }
      return $('<li class="' + (item.class ? (' ' + item.class) : '') + ' search-item">')
        .append($('<div>').html(item.label))
        .appendTo(ul);
    };
    instance._normalize = function (items) {
      return items;
    };
    instance._resizeMenu = function () {
      var ul = this.menu.element;
      ul.outerWidth(instance.element.outerWidth());
    };
  }
  var menu = options.$el.autocomplete('widget');
  menu.menu('option', 'items', '> :not(.search-category)');
  if (menu) {
    menu.addClass('search-menu');
  }
  if (options.suggestWhenEmpty) {
    options.$el.on('focus', function () {
      options.$el.autocomplete('search', options.$el.val());
    });
  }

  options.$el.on('keyup', function (e) {
    if (e.which === 13 && !searching) {
      options.$el.autocomplete('close');
    } else if (e.which === 38 && options.history) { // up arrow
      options.$el.autocomplete('search', {history: true});
    } else if (options.suggestWhenEmpty && options.$el.val() === '') {
      options.$el.autocomplete('search', '');
    }
  });

};

morpheus.Util.getAutocompleteTokens = function (text, options) {
  options = $.extend({}, {
    trim: true
  }, options);
  if (options.trim) {
    text = $.trim(text);
  }
  if (text === '') {
    return [];
  }
  var inQuote = false;
  var inParen = false;
  var tokens = [];
  var currentToken = [];

  for (var i = 0, n = text.length; i < n; i++) {
    var c = text[i];
    if (c === '"') {
      inQuote = !inQuote;
      currentToken.push(c);
    } else if (c === '(' || c === ')') {
      inParen = c === '(';
      currentToken.push(c);
    } else {
      if ((c === ' ' || c === '\t') && !inQuote && !inParen) {
        tokens.push({
          s: currentToken.join(''),
          inSelectionStart: currentToken.inSelectionStart
        });
        currentToken = []; // start new token
      } else { // add to current token
        currentToken.push(c);
      }
    }
    if (i === options.selectionStart - 1) {
      currentToken.inSelectionStart = true;
    }

  }

  tokens.push({
    s: currentToken.join(''),
    inSelectionStart: currentToken.inSelectionStart
  });
  // add trailing token
  if (!options.trim && !inQuote && text[text.length - 1] === ' ') {
    tokens.push({
      s: ' ',
      inSelectionStart: false
    });
  }
  // remove empty tokens
  // keep spaces at end of input "field:value" for next autocomplete
  var filteredTokens = [];
  var selectionStartIndex = -1;
  for (var i = 0, ntokens = tokens.length; i < ntokens; i++) {
    var token = tokens[i];
    var s = token.s;
    if (options.trim || i < (ntokens - 1)) {
      s = $.trim(s);
    }
    if (s !== '') {
      if (token.inSelectionStart) {
        selectionStartIndex = filteredTokens.length;
      }
      filteredTokens.push(s);
    }
  }
  filteredTokens.selectionStartIndex = selectionStartIndex;
  return filteredTokens;
};

morpheus.Util.showDialog = function ($el, title, options) {
  var $dialog = $('<div></div>');
  $el.appendTo($dialog);
  $dialog.appendTo($(document.body));
  if (!options) {
    options = {};
  }
  $dialog.dialog({
    width: 670,
    height: 590,
    title: title,
    // resizeStop : function(event, ui) {
    // var w = parseInt($dialog.width());
    // var h = parseInt($dialog.height());
    // //var d = Math.min(w, h);
    // svg.attr("width", w - 50);
    // svg.attr("height", h - 50);
    // chart.update();
    // },
    close: function (event, ui) {
      $dialog.remove();
      if (options.close) {
        options.close();
      }
    }
  });
};
/**
 * @param sheet
 *            An xlsx sheet
 * @param delim
 *            If a delim is specified each row, will contain a string separated
 *            by delim. Otherwise each row will contain an array.
 */
morpheus.Util.sheetToArray = function (sheet, delim) {
  var r = XLSX.utils.decode_range(sheet['!ref']);
  var rows = [];
  var colors = [];
  var header = [];
  for (var C = r.s.c; C <= r.e.c; ++C) {
    var val = sheet[XLSX.utils.encode_cell({
      c: C,
      r: r.s.r
    })];
    var txt = String(XLSX.utils.format_cell(val));
    header.push(txt);
  }
  for (var R = r.s.r; R <= r.e.r; ++R) {
    var row = [];
    for (var C = r.s.c; C <= r.e.c; ++C) {
      var val = sheet[XLSX.utils.encode_cell({
        c: C,
        r: R
      })];
      if (!val) {
        row.push('');
        continue;
      }

      var txt = String(XLSX.utils.format_cell(val));
      if (val.s != null) {
        var color = '#' + val.s.fgColor.rgb;
        colors.push({
          header: header[row.length],
          color: color,
          value: txt
        });
      }
      row.push(txt);
    }
    rows.push(delim ? row.join(delim) : row);
  }

  rows.colors = colors;
  return rows;
};
morpheus.Util.linesToObjects = function (lines) {
  var header = lines[0];
  var array = [];
  var nfields = header.length;
  for (var i = 1, length = lines.length; i < length; i++) {
    var line = lines[i];
    var obj = {};
    for (var f = 0; f < nfields; f++) {
      var value = line[f];
      var field = header[f];
      obj[field] = value;
    }
    array.push(obj);
  }
  return array;
};
/**
 *
 * @param options.data Binary data string
 * @param options.prompt Prompt for sheet name
 * @param callback {Function} Callback
 */
morpheus.Util.xlsxTo2dArray = function (options, callback) {
  var workbook = XLSX.read(options.data, {
    type: 'binary',
    cellFormula: false,
    cellHTML: false,
    cellStyles: true
  });
  var sheetNames = workbook.SheetNames;
  if (options.prompt && sheetNames.length > 1) {
    var formBuilder = new morpheus.FormBuilder();
    formBuilder.append({
      name: 'sheet',
      type: 'bootstrap-select',
      options: sheetNames,
      required: true,
      col: 'col-xs-2'
    });
    morpheus.FormBuilder.showInModal({
      title: 'Choose Sheet',
      html: formBuilder.$form,
      onClose: function () {
        var worksheet = workbook.Sheets[formBuilder.getValue('sheet')];
        var lines = morpheus.Util.sheetToArray(worksheet);
        callback(null, lines);
      }
    });

  } else {
    var worksheet = workbook.Sheets[sheetNames[0]];
    var lines = morpheus.Util.sheetToArray(worksheet);
    callback(null, lines);
  }

};
/**
 *
 * @param options.data Binary data string
 * @param options.prompt Prompt for sheet name
 * @param callback {Function} Callback
 */
morpheus.Util.xlsxTo1dArray = function (options, callback) {
  var workbook = XLSX.read(options.data, {
    type: 'binary',
    cellFormula: false,
    cellHTML: false,
    cellStyles: true
  });
  var sheetNames = workbook.SheetNames;
  if (options.prompt && sheetNames.length > 1) {
    var formBuilder = new morpheus.FormBuilder();
    formBuilder.append({
      name: 'sheet',
      type: 'bootstrap-select',
      options: sheetNames,
      required: true,
      col: 'col-xs-2'
    });

    morpheus.FormBuilder.showOkCancel({
      title: 'Choose Sheet',
      cancel: false,
      content: formBuilder.$form,
      okCallback: function () {
        var worksheet = workbook.Sheets[formBuilder.getValue('sheet')];
        callback(null, morpheus.Util.sheetToArray(worksheet, '\t'));
      }
    });

  } else {
    var worksheet = workbook.Sheets[sheetNames[0]];
    callback(null, morpheus.Util.sheetToArray(worksheet, '\t'));
  }

};

/**
 * Returns a promise that resolves to a string
 */
morpheus.Util.getText = function (urlOrFile) {
  var deferred = $.Deferred();
  if (morpheus.Util.isString(urlOrFile)) {
    $.ajax({
      contentType: 'text/plain',
      url: urlOrFile,
    }).done(function (text, status, xhr) {
      // var type = xhr.getResponseHeader('Content-Type');
      deferred.resolve(text);
    });
  } else if (urlOrFile instanceof File) {
    var reader = new FileReader();
    reader.onload = function (event) {
      deferred.resolve(event.target.result);
    };
    reader.readAsText(urlOrFile);
  } else {
    // what is urlOrFile?
    deferred.resolve(urlOrFile);
  }
  return deferred.promise();
};
morpheus.Util.createOptions = function (values, none) {
  var html = [];
  if (none) {
    html.push('<option value="">(None)</option>');
  }
  _.each(values, function (val) {
    html.push('<option value="');
    html.push(val);
    html.push('">');
    html.push(val);
    html.push('</option>');
  });
  return html.join('');
};

/**
 * Computes the rank using the given index array. The index array can be
 * obtained from the morpheus.Util.indexSort method. Does not handle ties.
 *
 * @param index
 * @return The ranks.
 */
morpheus.Util.rankIndexArray = function (index) {
  var rank = [];
  var n = index.length;
  for (var j = 0; j < n; j++) {
    rank[index[j]] = j + 1;
  }
  return rank;
};

morpheus.Util.indexSort = function (array, ascending) {
  var pairs = [];
  array.forEach(function (value, index) {
    pairs.push({
      value: value,
      index: index
    });
  });
  return morpheus.Util.indexSortPairs(pairs, ascending);
};
morpheus.Util.indexSortPairs = function (array, ascending) {
  if (ascending) {
    array.sort(function (a, b) {
      return (a.value < b.value ? -1 : (a.value === b.value ? (a.index < b.index ? -1 : 1) : 1));
    });
  } else {
    array.sort(function (a, b) {
      return (a.value < b.value ? 1 : (a.value === b.value ? (a.index < b.index ? 1 : -1) : -1));
    });
  }
  var indices = [];
  array.forEach(function (item) {
    indices.push(item.index);
  });
  return indices;
};
morpheus.Util.arrayEquals = function (array1, array2, comparator) {
  if (array1 == array2)
    return true;
  if (array1 == null || array2 == null) {
    return false;
  }
  if (!comparator) {
    comparator = function (a, b) {
      return a === b;
    };
  }
  var length = array1.length;
  if (array2.length !== length) {
    return false;
  }
  for (var i = 0; i < length; i++) {
    if (!comparator(array1[i], array2[i])) {
      return false;
    }
  }
  return true;
};
morpheus.Util._intFormat = typeof d3 !== 'undefined' ? d3.format(',i')
  : function (d) {
  return '' + Math.round(d);
};
morpheus.Util.intFormat = function (n) {
  return morpheus.Util._intFormat(n);
};
morpheus.Util._nf = typeof d3 !== 'undefined' ? d3.format('.4f') : function (d) {
  return '' + d;
};
morpheus.Util.nf = function (n) {
  var str = (n < 1 && n > -1 && n.toPrecision !== undefined) ? n
    .toPrecision(4) : morpheus.Util._nf(n);
  return morpheus.Util.removeTrailingZerosInFraction(str);
};
morpheus.Util.createNumberFormat = function (nfractionDigits) {
  var d3Formatter = d3.format('.' + nfractionDigits + 'f');
  var f = function (value) {
    var str = d3Formatter(value);
    return morpheus.Util.removeTrailingZerosInFraction(str);
  };
  return f;
};

morpheus.Util.wrapNumber = function (value, object) {
  var n = new Number(value);
  n.toObject = function () {
    return object;
  };
  return n;
};
morpheus.Util.toString = function (value) {
  if (value == null) {
    return '';
  } else if (_.isNumber(value)) {
    return morpheus.Util.nf(value);
  } else if (morpheus.Util.isArray(value)) {
    return morpheus.Util.arrayToString(value, ', ');
  }
  return '' + value;
};

morpheus.Util.arrayToString = function (value, sep) {
  var s = [];
  for (var i = 0, length = value.length; i < length; i++) {
    var val_i = value[i];
    if (_.isNumber(val_i)) {
      s.push(morpheus.Util.nf(val_i));
    } else {
      s.push('' + val_i);
    }

  }
  return s.join(sep);

};
morpheus.Util.removeTrailingZerosInFraction = function (str) {
  var index = str.lastIndexOf('.');
  if (str.lastIndexOf('e') !== -1) {
    return str;
  }
  if (index !== -1) {
    var len = str.length;
    var zeros = len;
    for (var i = len - 1; i > index; i--, zeros--) {
      if (str[i] != '0') {
        break;
      }
    }
    if (zeros === (index + 1)) {
      return str.substring(0, index);
    }
    if (zeros < len) {
      return str.substring(0, index) + str.substring(index, zeros);
    }
  }
  return str;
};
morpheus.Util.s = function (n) {
  return n === 1 ? '' : 's';
};
morpheus.Util.create2dArray = function (rows, columns) {
  var array2d = [];
  for (var i = 0; i < rows; i++) {
    var array = [];
    for (var j = 0; j < columns; j++) {
      array[j] = NaN;
    }
    array2d.push(array);
  }
  return array2d;
};
morpheus.Util.escapeRegex = function (value) {
  return value.replace(/[*]/g, '.*')
    .replace(/[-[\]{}()+?,\\^$|#\s]/g, '\\$&');
};

morpheus.Util.createSearchPredicates = function (options) {
  options = $.extend({}, {
    validateFieldNames: true,
    caseSensitive: true
  }, options);
  var tokens = options.tokens;
  if (tokens == null) {
    return [];
  }
  var availableFields = options.fields;
  if (!options.caseSensitive && availableFields != null) {
    for (var i = 0; i < availableFields.length; i++) {
      availableFields[i] = availableFields[i].toLowerCase();
    }
  }
  var validateFieldNames = options.validateFieldNames;
  var fieldSearchEnabled = !validateFieldNames
    || (availableFields != null && availableFields.length > 0);

  var fieldRegExp = /\\:/g;
  var predicates = [];
  var defaultIsExactMatch = options.defaultMatchMode === 'exact';

  tokens
    .forEach(function (token) {
      var isNot = false;
      if (token[0] === '-') { // not predicate
        token = token.substring(1);
        isNot = true;
      }
      var field = null;
      var semi = token.indexOf(':');
      if (semi > 0) { // field search?
        if (!fieldSearchEnabled
          || token.charCodeAt(semi - 1) === 92) { // \:
          token = token.replace(fieldRegExp, ':');
        } else { // only a field search if field matches
          // one of available fields
          var possibleToken = $.trim(token.substring(semi + 1));
          // check for "field":"val" and "field:val"
          var possibleField = $.trim(token.substring(0, semi)); // split
          // on :
          if (possibleField.length > 0
            && possibleField[0] === '"'
            && possibleField[possibleField.length - 1] === '"') {
            possibleField = possibleField.substring(1,
              possibleField.length - 1);
          } else if (possibleField.length > 0
            && possibleField[0] === '"'
            && possibleToken[possibleToken.length - 1] === '"'
            && possibleToken[0] !== '"') {
            possibleField = possibleField.substring(1,
              possibleField.length);
            possibleToken = '"' + possibleToken;

          }

          if (!validateFieldNames
            || availableFields.indexOf(options.caseSensitive ? possibleField : possibleField.toLowerCase()) !== -1) {
            token = possibleToken;
            field = possibleField;
          }
        }
      }

      var predicate;
      var rangeIndex = -1;
      var rangeToken = null;
      var rangeIndicators = ['..', '>=', '>', '<=', '<', '='];
      for (var i = 0; i < rangeIndicators.length; i++) {
        rangeIndex = token.indexOf(rangeIndicators[i]);
        if (rangeIndex !== -1) {
          rangeToken = rangeIndicators[i];
          break;
        }
      }

      if (rangeIndex !== -1) { // range query
        if (rangeToken === '..') {
          var start = parseFloat(token.substring(0, rangeIndex));
          var end = parseFloat(token.substring(rangeIndex + 2));
          if (!isNaN(start) && !isNaN(end)) {
            predicate = new morpheus.Util.NumberRangePredicate(
              field, start, end);
          }
        } else if (rangeToken === '>') {
          var val = parseFloat(token.substring(rangeIndex + 1));
          if (!isNaN(val)) {
            predicate = new morpheus.Util.GreaterThanPredicate(
              field, val);
          }
        } else if (rangeToken === '>=') {
          var val = parseFloat(token.substring(rangeIndex + 2));
          if (!isNaN(val)) {
            predicate = new morpheus.Util.GreaterThanOrEqualPredicate(
              field, val);
          }
        } else if (rangeToken === '<') {
          var val = parseFloat(token.substring(rangeIndex + 1));
          if (!isNaN(val)) {
            predicate = new morpheus.Util.LessThanPredicate(
              field, val);
          }
        } else if (rangeToken === '<=') {
          var val = parseFloat(token.substring(rangeIndex + 2));
          if (!isNaN(val)) {
            predicate = new morpheus.Util.LessThanOrEqualPredicate(
              field, val);
          }
        } else if (rangeToken === '=') {
          var val = parseFloat(token.substring(rangeIndex + 1));
          predicate = new morpheus.Util.EqualsPredicate(
            field, val);
        } else {
          console.log('Unknown range token:' + rangeToken);
        }
      } else if (token[0] === '"' && token[token.length - 1] === '"') { // exact
        token = token.substring(1, token.length - 1);
        predicate = new morpheus.Util.ExactTermPredicate(field,
          token);
      } else if (token[0] === '(' && token[token.length - 1] === ')') { // exact terms
        token = token.substring(1, token.length - 1);
        var values = morpheus.Util.getAutocompleteTokens(token);

        if (values.length > 0) {
          predicate = new morpheus.Util.ExactTermsPredicate(field,
            values.map(function (val) {
              if (val[0] === '"' && val[val.length - 1] === '"') {
                val = val.substring(1, val.length - 1);
              }
              return val.toLowerCase();
            }));
        }
      } else if (token.indexOf('*') !== -1) { // contains
        predicate = new morpheus.Util.RegexPredicate(field, token);
      } else {
        predicate = defaultIsExactMatch ? new morpheus.Util.ExactTermPredicate(
          field, token)
          : new morpheus.Util.RegexPredicate(field, token);

      }
      if (predicate != null) {
        predicates.push(isNot ? new morpheus.Util.NotPredicate(
          predicate) : predicate);
      }

    });
  return predicates;
}
;

morpheus.Util.createRegExpStringToMatchText = function (text) {
  var tokens = morpheus.Util.getAutocompleteTokens(text);
  if (tokens.length === 0) {
    return null;
  }
  var regex = [];
  _.each(tokens, function (token) {
    if (token[0] === '"' && token[token.length - 1] === '"') {
      token = token.substring(1, token.length - 1);
      regex.push('^' + morpheus.Util.escapeRegex(token) + '$'); // exact
      // match
    } else {
      regex.push(morpheus.Util.escapeRegex(token));
    }
  });
  return '(' + regex.join('|') + ')';
};
morpheus.Util.createRegExpToMatchText = function (text) {
  var s = morpheus.Util.createRegExpStringToMatchText(text);
  return s == null ? null : new RegExp(s, 'i');
};
morpheus.Util.reorderArray = function (array, index) {
  var newArray = [];
  for (var i = 0; i < index.length; i++) {
    newArray.push(array[index[i]]);
  }
  return newArray;
};
morpheus.Util.getSearchString = function () {
  var s = window.location.search;
  return s.length > 1 ? s.substring(1) : '';
};
/**
 * Takes an array of strings and splits each string by \t
 *
 * @return An array of arrays
 */
morpheus.Util.splitLines = function (lines) {
  var tab = /\t/;
  var tokens = [];
  for (var i = 0, nlines = lines.length; i < nlines; i++) {
    var line = lines[i];
    if (line === '') {
      continue;
    }
    tokens.push(line.split(tab));
  }
  return tokens;
};

/**
 * @param file
 *            a File or url
 * @return A deferred object that resolves to an array of strings
 */
morpheus.Util.readLines = function (fileOrUrl, interactive) {
  var isFile = fileOrUrl instanceof File;
  var isString = morpheus.Util.isString(fileOrUrl);
  var name = morpheus.Util.getFileName(fileOrUrl);
  var ext = morpheus.Util.getExtension(name);
  var deferred = $.Deferred();
  if (isString) { // URL
    if (ext === 'xlsx') {
      var oReq = new XMLHttpRequest();
      oReq.open('GET', fileOrUrl, true);
      $.ajaxPrefilter({url: fileOrUrl}, {}, oReq);
      oReq.responseType = 'arraybuffer';
      oReq.onload = function (oEvent) {
        var arrayBuffer = oReq.response;
        if (arrayBuffer) {
          var data = new Uint8Array(arrayBuffer);
          var arr = [];
          for (var i = 0; i != data.length; ++i) {
            arr[i] = String.fromCharCode(data[i]);
          }
          var bstr = arr.join('');
          morpheus.Util.xlsxTo1dArray({
            data: bstr,
            prompt: interactive
          }, function (err, lines) {
            deferred.resolve(lines);
          });

        } else {
          throw 'not found';
        }
      };
      oReq.send(null);
    } else {
      $.ajax({
        url: fileOrUrl,
      }).done(function (text, status, xhr) {
        deferred.resolve(morpheus.Util.splitOnNewLine(text));
      });
    }
  } else if (isFile) {
    var reader = new FileReader();
    reader.onload = function (event) {
      if (ext === 'xlsx' || ext === 'xls') {
        var data = new Uint8Array(event.target.result);
        var arr = [];
        for (var i = 0; i != data.length; ++i) {
          arr[i] = String.fromCharCode(data[i]);
        }
        var bstr = arr.join('');
        morpheus.Util
          .xlsxTo1dArray({
            data: bstr,
            prompt: interactive
          }, function (err, lines) {
            deferred.resolve(lines);
          });
      } else {
        deferred.resolve(morpheus.Util.splitOnNewLine(event.target.result));
      }

    };
    if (ext === 'xlsx' || ext === 'xls') {
      reader.readAsArrayBuffer(fileOrUrl);
    } else {
      reader.readAsText(fileOrUrl);
    }
  } else { // it's already lines?
    deferred.resolve(fileOrUrl);
  }
  return deferred;
};
morpheus.Util.createValueToIndices = function (array, field) {
  var map = new morpheus.Map();
  _.each(array, function (item) {
    var key = item[field];
    var values = map.get(key);
    if (values === undefined) {
      values = [];
      map.set(key, values);
    }
    values.push(item);
  });
  return map;
};

morpheus.Util.createLoadingEl = function () {
  return $('<div style="overflow:hidden;text-align:center;"><i class="fa fa-spinner fa-spin fa-3x"></i><span style="padding-left:4px;vertical-align:middle;font-weight:bold;">Loading...</span></div>');
};
/**
 * Splits a string by the new line character, trimming whitespace
 */
morpheus.Util.splitOnNewLine = function (text, commentChar) {
  var commentCharCode = commentChar !== undefined ? commentChar.charCodeAt(0)
    : undefined;

  var lines = text.split(/\n/);
  if (lines.length === 1) {
    var tmp = text.split(/\r/); // old school mac?
    if (tmp.length > 1) {
      lines = tmp;
    }
  }

  var rows = [];
  for (var i = 0, nlines = lines.length; i < nlines; i++) {
    var line = lines[i].trim();
    if (line !== '') {
      if (commentCharCode !== undefined) {
        if (line.charCodeAt(0) !== commentCharCode) {
          rows.push(line);
        }
      } else {
        rows.push(line);
      }
    }
  }
  return rows;
};

morpheus.Util.ContainsPredicate = function (field, text) {
  this.field = field;
  text = text.toLowerCase();
  this.text = text;
};
morpheus.Util.ContainsPredicate.prototype = {
  accept: function (value) {
    if (value == null) {
      return false;
    }
    value = ('' + value).toLowerCase();
    return value.indexOf(this.text) !== -1;
  },
  getField: function () {
    return this.field;
  },
  getText: function () {
    return this.text;
  },
  isNumber: function () {
    return false;
  },
  toString: function () {
    return 'ContainsPredicate ' + this.field + ':' + this.text;
  }
};
morpheus.Util.ExactTermsPredicate = function (field, values) {
  this.field = field;
  this.values = new morpheus.Set();
  for (var i = 0, nvalues = values.length; i < nvalues; i++) {
    this.values.add(values[i]);
  }
};
morpheus.Util.ExactTermsPredicate.prototype = {
  accept: function (value) {
    if (value == null) {
      return false;
    }
    value = ('' + value).toLowerCase();
    return this.values.has(value);
  },
  getField: function () {
    return this.field;
  },
  getValues: function () {
    return this.values;
  },
  isNumber: function () {
    return false;
  },
  toString: function () {
    return 'ExactTermsPredicate ' + this.field + ':' + this.text;
  }
};

morpheus.Util.ExactTermPredicate = function (field, term) {
  this.field = field;
  term = term.toLowerCase();
  this.text = term;
};
morpheus.Util.ExactTermPredicate.prototype = {
  accept: function (value) {
    if (value == null) {
      return false;
    }
    value = ('' + value).toLowerCase();
    return value === this.text;
  },
  getField: function () {
    return this.field;
  },
  getText: function () {
    return this.text;
  },
  isNumber: function () {
    return false;
  },
  toString: function () {
    return 'ExactTermPredicate ' + this.field + ':' + this.text;
  }
};
morpheus.Util.RegexPredicate = function (field, text) {
  this.field = field;
  this.text = text;
  this.regex = new RegExp(morpheus.Util.escapeRegex(text), 'i');
};
morpheus.Util.RegexPredicate.prototype = {
  accept: function (value) {
    return this.regex.test('' + value);
  },
  getField: function () {
    return this.field;
  },
  getText: function () {
    return this.text;
  },
  isNumber: function () {
    return false;
  },
  toString: function () {
    return 'RegexPredicate ' + this.field + ':' + this.regex;
  }
};
morpheus.Util.NumberRangePredicate = function (field, min, max) {
  this.field = field;
  this.min = min;
  this.max = max;
};
morpheus.Util.NumberRangePredicate.prototype = {
  accept: function (value) {
    return value >= this.min && value <= this.max;
  },
  getField: function () {
    return this.field;
  },
  isNumber: function () {
    return true;
  },
  toString: function () {
    return 'NumberRangePredicate ' + this.field + ':' + this.min + '...'
      + this.max;
  }
};

morpheus.Util.GreaterThanPredicate = function (field, val) {
  this.field = field;
  this.val = val;
};
morpheus.Util.GreaterThanPredicate.prototype = {
  accept: function (value) {
    return value > this.val;
  },
  getField: function () {
    return this.field;
  },
  isNumber: function () {
    return true;
  }
};

morpheus.Util.GreaterThanOrEqualPredicate = function (field, val) {
  this.field = field;
  this.val = val;
};
morpheus.Util.GreaterThanOrEqualPredicate.prototype = {
  accept: function (value) {
    return value >= this.val;
  },
  getField: function () {
    return this.field;
  },
  isNumber: function () {
    return true;
  }
};
morpheus.Util.LessThanPredicate = function (field, val) {
  this.field = field;
  this.val = val;
};
morpheus.Util.LessThanPredicate.prototype = {
  accept: function (value) {
    return value < this.val;
  },
  getField: function () {
    return this.field;
  },
  isNumber: function () {
    return true;
  }
};
morpheus.Util.LessThanOrEqualPredicate = function (field, val) {
  this.field = field;
  this.val = val;
};
morpheus.Util.LessThanOrEqualPredicate.prototype = {
  accept: function (value) {
    return value <= this.val;
  },
  getField: function () {
    return this.field;
  },
  isNumber: function () {
    return true;
  }
};
morpheus.Util.EqualsPredicate = function (field, val) {
  this.field = field;
  this.val = val;
};
morpheus.Util.EqualsPredicate.prototype = {
  accept: function (value) {
    return value === this.val;
  },
  getField: function () {
    return this.field;
  },
  isNumber: function () {
    return true;
  }
};
morpheus.Util.NotPredicate = function (p) {
  this.p = p;
};
morpheus.Util.NotPredicate.prototype = {
  accept: function (value) {
    return !this.p.accept(value);
  },
  getField: function () {
    return this.p.getField();
  },
  isNumber: function () {
    return this.p.isNumber();
  },
  toString: function () {
    return 'NotPredicate ' + this.p;
  }
};


morpheus.Util.getFieldNames = function (rexp) {
  var strValues = rexp.attrValue[0].stringValue;
  var res = [];
  strValues.forEach(function (v) {
    res.push(v.strval);
  });
  return res;
};
morpheus.Util.getRexpData = function (rexp, rclass) {
  var names = morpheus.Util.getFieldNames(rexp);
  var data = {};
  for (var i = 0; i < names.length; i++) {
    var rexpV = rexp.rexpValue[i];
    data[names[i]] = {};
    if (rexpV.attrName.length > 0 && rexpV.attrName[0] == 'dim') {
      data[names[i]].dim = rexpV.attrValue[0].intValue;
    }
    if (rexpV.rclass == rclass.INTEGER) {
      if (rexpV.attrName.length > 0 && rexpV.attrName[0] == 'levels') {
        data[names[i]].values = [];
        rexpV.attrValue[0].stringValue.forEach(function (v) {
          data[names[i]].values.push(v.strval);
        })
      }
      else {
        data[names[i]].values = rexpV.intValue;
      }
    }
    else if (rexpV.rclass == rclass.REAL) {
      data[names[i]].values = rexpV.realValue;
    }
    else if (rexpV.rclass == rclass.STRING) {
      data[names[i]].values = [];
      rexpV.stringValue.forEach(function (v) {
        data[names[i]].values.push(v.strval);
      });
    }
  }
  return data;
};

morpheus.Util.getFilePath = function (session, str) {
  var splitted = str.split("/");
  var fileName = splitted[splitted.length - 1].substring(0, splitted[splitted.length - 1].length - 2);
  return session.getLoc() + "files/" + fileName;
};

morpheus.Util.getTrueIndices = function (dataset) {
  console.log('TrueIndices', dataset, dataset.dataset, dataset.dataset === undefined);
  var rowIndices = dataset.rowIndices ? dataset.rowIndices : [];
  var rows = morpheus.Util.getConsNumbers(rowIndices.length);
  var columnIndices = dataset.columnIndices ? dataset.columnIndices : [];
  var columns = morpheus.Util.getConsNumbers(columnIndices.length);
  var iter = 0;
  var savedDataset = dataset;
  console.log("rows processing");
  while (dataset.dataset) {
    if (!dataset.rowIndices) {
      dataset = dataset.dataset;
      continue;
    }
    rowIndices = dataset.rowIndices;
    console.log(iter, "rows:", rows.length, rows);
    var newRows = Array.apply(null, Array(rows.length)).map(Number.prototype.valueOf, 0);
    for (var i = 0; i < rows.length; i++) {
      newRows[i] = dataset.rowIndices[rows[i]];
    }
    rows = newRows;
    dataset = dataset.dataset;
    iter++;
  }
  iter = 0;
  console.log("columns processing");
  dataset = savedDataset;
  while (dataset.dataset) {
    if (!dataset.columnIndices) {
      dataset = dataset.dataset;
      continue;
    }
    columnIndices = dataset.columnIndices;

    console.log(iter, "columns:", columns.length, columns);
    var newCols = Array.apply(null, Array(columns.length)).map(Number.prototype.valueOf, 0)
    for (i = 0; i < columns.length; i++) {
      newCols[i] = dataset.columnIndices[columns[i]];
    }
    columns = newCols;

    dataset = dataset.dataset;
    iter++;
  }

  console.log("res", rows, columns);
  var conseqRows = morpheus.Util.getConsNumbers(dataset.rows);
  var conseqCols = morpheus.Util.getConsNumbers(dataset.columns);
  console.log(conseqCols);
  var ans = {};
  console.log(morpheus.Util.equalArrays(rows, conseqRows));
  if (morpheus.Util.equalArrays(rows, conseqRows) || rows.length == 0 && morpheus.Util.equalArrays(conseqRows, rowIndices)) {
    ans.rows = [];
  }
  else {
    ans.rows = rows.length > 0 ? rows : rowIndices;
  }
  console.log(morpheus.Util.equalArrays(columns, conseqCols));
  if (morpheus.Util.equalArrays(columns, conseqCols) || columns.length == 0 && morpheus.Util.equalArrays(conseqCols, columnIndices)) {
    ans.columns = [];
  }
  else {
    ans.columns = columns.length > 0 ? columns : columnIndices;
  }
  console.log(ans);
  return ans;
};

morpheus.Util.getConsNumbers = function (n) {
  var ar = [];
  for (var i = 0; i < n; i++) {
    ar.push(i);
  }
  return ar;
};

morpheus.Util.equalArrays = function (a, b) {
  if (a.length != b.length || a == null || b == null) {
    return false;
  }
  for (var i = 0; i < a.length; i++) {
    if (a[i] != b[i]) {
      return false;
    }
  }
  return true;
};
morpheus.BlobFromPath = function () {
};
morpheus.BlobFromPath.getFileBlob = function (url, cb) {
  var xhr = new XMLHttpRequest();
  xhr.open("GET", url);
  xhr.responseType = "blob";
  xhr.addEventListener('load', function () {
    cb(xhr.response);
  });
  xhr.send();
};

morpheus.BlobFromPath.blobToFile = function (blob) {
  blob.lastModifiedDate = new Date();
  return blob;
};

morpheus.BlobFromPath.getFileObject = function (filePathOrUrl, cb) {
  morpheus.BlobFromPath.getFileBlob(filePathOrUrl, function (blob) {
    cb(morpheus.BlobFromPath.blobToFile(blob));
  });
};
// code taken from KineticJS
morpheus.Events = function () {
};
morpheus.Events.prototype = {
  /**
   * Pass in a string of events delimmited by a space to bind multiple events
   * at once such as 'mousedown mouseup mousemove'. Include a namespace to
   * bind an event by name such as 'click.foobar'.
   *
   * @param {String}
   *            evtStr e.g. 'click', 'mousedown touchstart', 'mousedown.foo
   *            touchstart.foo'
   * @param {Function}
   *            handler The handler function is passed an event object
   */
  on: function (evtStr, handler) {
    if (!handler) {
      throw Error('Handler not specified');
    }
    if (!this.eventListeners) {
      this.eventListeners = {};
    }
    var events = evtStr.split(' '), len = events.length, n, event, parts, baseEvent, name;
    /*
     * loop through types and attach event listeners to each one. eg. 'click
     * mouseover.namespace mouseout' will create three event bindings
     */
    for (n = 0; n < len; n++) {
      event = events[n];
      parts = event.split('.');
      baseEvent = parts[0];
      name = parts[1] || '';
      // create events array if it doesn't exist
      if (!this.eventListeners[baseEvent]) {
        this.eventListeners[baseEvent] = [];
      }
      this.eventListeners[baseEvent].push({
        name: name,
        handler: handler
      });
    }
    return this;
  },
  getListeners: function () {
    if (!this.eventListeners) {
      this.eventListeners = {};
    }
    return this.eventListeners;
  },
  setListeners: function (eventListeners) {
    this.eventListeners = eventListeners;
  },
  /**
   * Fire an event.
   *
   * @param eventType
   * @param evt
   */
  trigger: function (eventType, evt) {
    if (!this.eventListeners) {
      this.eventListeners = {};
    }
    if (!evt) {
      evt = {};
    }
    evt.type = eventType;
    if (!evt.source) {
      evt.source = this;
    }
    var events = this.eventListeners[eventType];
    if (events) {
      var len = events.length;
      for (var i = 0; i < len; i++) {
        events[i].handler.apply(this, [evt]);
      }
    }
    return this;
  },
  /**
   * Remove event bindings. Pass in a string of event types delimmited by a
   * space to remove multiple event bindings at once such as 'mousedown
   * mouseup mousemove'. include a namespace to remove an event binding by
   * name such as 'click.foobar'. If you only give a name like '.foobar', all
   * events in that namespace will be removed.
   *
   * @param {String}
   *            evtStr e.g. 'click', 'mousedown.foo touchstart', '.foobar'
   */
  off: function (evtStr, handler) {
    if (!this.eventListeners) {
      this.eventListeners = {};
    }
    var events = (evtStr || '').split(' '), len = events.length, n, t, event, parts, baseEvent, name;
    if (!evtStr) {
      // remove all events
      for (t in this.eventListeners) {
        this._off(t, null, handler);
      }
    }
    for (n = 0; n < len; n++) {
      event = events[n];
      parts = event.split('.');
      baseEvent = parts[0];
      name = parts[1];
      if (baseEvent) {
        if (this.eventListeners[baseEvent]) {
          this._off(baseEvent, name, handler);
        }
      } else {
        for (t in this.eventListeners) {
          this._off(t, name, handler);
        }
      }
    }
    return this;
  },
  _off: function (type, name, handler) {
    var evtListeners = this.eventListeners[type], i, evtName;
    for (i = 0; i < evtListeners.length; i++) {
      evtName = evtListeners[i].name;
      // check if an event name is not specified, or if one is specified,
      // it matches the current event name
      if ((!name || evtName === name)
        && (handler == null || handler == evtListeners[i].handler)) {
        evtListeners.splice(i, 1);
        if (evtListeners.length === 0) {
          delete this.eventListeners[type];
          break;
        }
        i--;
      }
    }
  }
};

morpheus.Identifier = function (array) {
  this.array = array;
};
morpheus.Identifier.prototype = {
  toString: function () {
    return this.array.join(',');
  },
  equals: function (otherId) {
    var other = otherId.getArray();
    var length = this.array.length;
    if (other.length !== length) {
      return false;
    }
    for (var i = 0; i < length; i++) {
      if (this.array[i] !== other[i]) {
        return false;
      }
    }
    return true;
  },
  getArray: function () {
    return this.array;
  }
};

morpheus.Map = function () {
  this.map = {}; // object string -> key, value
  // the key field is stored to get the original key object back
  this.n = 0;
};
morpheus.Map.prototype = {
  toJSON: function () {
    var json = {};
    this.forEach(function (value, key) {
      json[key] = value;
    });
    return json;
  },
  toString: function () {
    var s = [];
    this.forEach(function (value, key) {
      if (s.length > 0) {
        s.push(', ');
      }
      s.push(key);
      s.push('=');
      s.push(value);
    });
    return s.join('');
  },
  keys: function () {
    var keys = [];
    for (var key in this.map) {
      var pair = this.map[key];
      keys.push(pair.key);
    }
    return keys;
  },
  size: function () {
    return this.n;
  },
  equals: function (m) {
    if (m.size() !== this.size()) {
      return false;
    }
    var ret = true;
    try {
      this.forEach(function (value, key) {
        if (value !== m.get(key)) {
          ret = false;
          throw 'break'; // break out of loop
        }
      });
    }
    catch (e) {
      // catch break out of loop
    }
    return ret;
  },
  setAll: function (map) {
    var _this = this;
    map.forEach(function (value, key) {
      _this.set(key, value);
    });
  },
  set: function (key, value) {
    var skey = '\0' + key;
    var previous = this.map[skey];
    if (previous === undefined) { // only increment size when this is a
      // new key
      this.n++;
    }
    this.map[skey] = {
      key: key,
      value: value
    };
  },
  forEach: function (callback) {
    for (var key in this.map) {
      var pair = this.map[key];
      callback(pair.value, pair.key);
    }
  },
  entries: function () {
    var array = [];
    this.forEach(function (value, key) {
      array.push({
        value: value,
        key: key
      });
    });
    return array;
  },
  values: function () {
    var values = [];
    for (var key in this.map) {
      var pair = this.map[key];
      values.push(pair.value);
    }
    return values;
  },
  get: function (key) {
    var skey = '\0' + key;
    var pair = this.map[skey];
    return pair !== undefined ? pair.value : undefined;
  },
  clear: function () {
    this.map = {};
    this.n = 0;
  },
  remove: function (key) {
    var skey = '\0' + key;
    var pair = this.map[skey];
    if (pair !== undefined) {
      delete this.map[skey];
      this.n--;
      return pair.value;
    }
  },
  has: function (key) {
    var skey = '\0' + key;
    return this.map[skey] !== undefined;
  }
};

morpheus.Map.fromJSON = function (json) {
  var map = new morpheus.Map();
  for (var key in json) {
    map.set(key, json[key]);
  }
  return map;
};

morpheus.Set = function () {
  this._map = new morpheus.Map();
};
morpheus.Set.prototype = {
  toJSON: function () {
    var json = [];
    this.forEach(function (value) {
      json.push(value);
    });
    return json;
  },
  toString: function () {
    var s = [];
    this.forEach(function (key) {
      if (s.length > 0) {
        s.push(', ');
      }
      s.push(key);
    });
    return s.join('');
  },
  size: function () {
    return this._map.size();
  },
  equals: function (m) {
    return this._map.equals(m);
  },
  forEach: function (callback) {
    this._map.forEach(function (value, key) {
      callback(key);
    });
  },
  add: function (value) {
    this._map.set(value, true);
  },
  values: function () {
    var values = [];
    this._map.forEach(function (value, key) {
      values.push(key);
    });
    return values;
  },
  clear: function () {
    this._map.clear();
  },
  remove: function (key) {
    this._map.remove(key);
  },
  has: function (key) {
    return this._map.has(key);
  }
};

morpheus.Set.fromJSON = function (json) {
  var set = new morpheus.Set();
  for (var i = 0, length = json.length; i < length; i++) {
    set.add(json[i]);
  }
  return set;
};

morpheus.ArrayBufferReader = function (buffer) {
  this.buffer = buffer;
  this.bufferLength = buffer.length;
  this.index = 0;
  if (typeof TextDecoder !== 'undefined') {
    var textDecoder = new TextDecoder();
    this.decoder = function (buf, start, end) {
      return textDecoder.decode(buf.subarray(start, end));
    };
  } else {
    this.decoder = function (buf, start, end) {
      // TODO convert in chunks
      var s = [];
      for (var i = start; i < end; i++) {
        s.push(String.fromCharCode(buffer[i]));
      }
      return s.join('');
    };
  }
};

morpheus.ArrayBufferReader.prototype = {
  readLine: function () {
    var index = this.index;
    var bufferLength = this.bufferLength;
    if (index >= bufferLength) {
      return null;
    }
    var buffer = this.buffer;
    var start = index;
    var end = start;
    // dos: \r\n, old mac:\r
    for (; index < bufferLength; index++) {
      var c = buffer[index];
      if (c === 10 || c === 13) { // \n or \r
        end = index;
        if ((index !== bufferLength - 1) && buffer[index + 1] === 10) { // skip
          // ahead
          index++;
        }
        index++;
        break;
      }
    }
    this.index = index;
    if (start === end && index === bufferLength) { // eof
      return this.decoder(this.buffer, start, bufferLength);
    }

    return this.decoder(this.buffer, start, end);

  }
};

morpheus.ArrayBufferReader.getArrayBuffer = function (fileOrUrl, callback) {
  var isString = typeof fileOrUrl === 'string' || fileOrUrl instanceof String;
  if (isString) { // URL
    var oReq = new XMLHttpRequest();
    oReq.open('GET', fileOrUrl, true);
    oReq.responseType = 'arraybuffer';
    oReq.onload = function (oEvent) {
      callback(null, oReq.response);
    };

    oReq.onerror = function (oEvent) {
      callback(oEvent);
    };
    oReq.onreadystatechange = function (oEvent) {
      if (oReq.readyState === 4 && oReq.status !== 200) {
        oReq.onload = null;
        oReq.onerror = null;
        if (oReq.status === 404) {
          callback(new Error(fileOrUrl + ' not found.'));
        } else {
          callback(new Error('Unable to read ' + fileOrUrl + '.'));
        }
      }
    };

    oReq.send(null);
    return oReq;

  } else {
    var reader = new FileReader();
    reader.onload = function (event) {
      callback(null, event.target.result);
    };
    reader.onerror = function (event) {
      callback(event);
    };
    reader.readAsArrayBuffer(fileOrUrl);
    return reader;
  }
};

morpheus.Array2dReaderInteractive = function () {

};

morpheus.Array2dReaderInteractive.prototype = {
  read: function (fileOrUrl, callback) {
    var _this = this;
    var name = morpheus.Util.getBaseFileName(morpheus.Util.getFileName(fileOrUrl));
    var html = [];
    html.push('<div>');
    html.push('<label>Click the table cell containing the first data row and column.</label>');
    html.push('<div class="checkbox"> <label> <input name="transpose" type="checkbox">' +
      ' Tranpose </label>' +
      ' </div>');

    html.push('<div' +
      ' style="display:inline-block;width:10px;height:10px;background-color:#b3cde3;"></div><span> Data Matrix</span>');
    html.push('<br /><div' +
      ' style="display:inline-block;width:10px;height:10px;background-color:#fbb4ae;"></div><span> Column' +
      ' Annotations</span>');
    html.push('<br /><div' +
      ' style="display:inline-block;' +
      ' width:10px;height:10px;background-color:#ccebc5;"></div><span> Row' +
      ' Annotations</span>');

    html.push('<div class="slick-bordered-table" style="width:550px;height:400px;"></div>');
    html.push('</div>');
    var $el = $(html.join(''));

    morpheus.Util.readLines(fileOrUrl, true).done(function (lines) {
      // show in table
      var tab = /\t/;
      for (var i = 0, nrows = lines.length; i < nrows; i++) {
        lines[i] = lines[i].split(tab);
      }
      var grid;
      var columns = [];
      for (var j = 0, ncols = lines[0].length; j < ncols; j++) {
        columns.push({
          id: j,
          field: j
        });
      }

      var dataRowStart = 1;
      var dataColumnStart = 1;
      var _lines = lines;
      var grid = new Slick.Grid($el.find('.slick-bordered-table')[0], lines, columns, {
        enableCellNavigation: true,
        headerRowHeight: 0,
        showHeaderRow: false,
        multiColumnSort: false,
        multiSelect: false,
        topPanelHeight: 0,
        enableColumnReorder: false,
        enableTextSelectionOnCells: true,
        forceFitColumns: false,
        defaultFormatter: function (row, cell, value, columnDef, dataContext) {
          var color = 'white';
          if (cell >= dataColumnStart && row >= dataRowStart) {
            color = '#b3cde3'; // data
          } else if (row <= (dataRowStart - 1) && cell >= dataColumnStart) {
            color = '#fbb4ae'; // column
          } else if (cell < dataColumnStart && row >= dataRowStart) {
            color = '#ccebc5'; // row
          }
          var html = ['<div style="width:100%;height:100%;background-color:' + color + '">'];
          if (_.isNumber(value)) {
            html.push(morpheus.Util.nf(value));
          } else if (morpheus.Util.isArray(value)) {
            var s = [];
            for (var i = 0, length = value.length; i < length; i++) {
              if (i > 0) {
                s.push(', ');
              }
              var val = value[i];
              s.push(value[i]);
            }
            html.push(s.join(''));
          } else {
            html.push(value);
          }
          html.push('</div>');
          return html.join('');
        }
      });
      var transposedLines;
      var transposedColumns;
      $el.find('[name=transpose]').on('click', function (e) {
        if ($(this).prop('checked')) {
          if (transposedLines == null) {
            transposedLines = [];
            for (var j = 0, ncols = lines[0].length; j < ncols; j++) {
              var row = [];
              transposedLines.push(row);
              for (var i = 0, nrows = lines.length; i < nrows; i++) {
                row.push(lines[i][j]);
              }
            }

            transposedColumns = [];
            for (var j = 0, ncols = transposedLines[0].length; j < ncols; j++) {
              transposedColumns.push({
                id: j,
                field: j
              });
            }

          }
          lines = transposedLines;
          grid.setData(transposedLines);
          grid.setColumns(transposedColumns);
          grid.resizeCanvas();
          grid.invalidate();
        } else {
          grid.setData(_lines);
          grid.setColumns(columns);
          grid.resizeCanvas();
          grid.invalidate();
          lines = _lines;
        }
      });
      grid.onClick.subscribe(function (e, args) {
        dataRowStart = args.row;
        dataColumnStart = args.cell;
        grid.invalidate();
      });

      $el.find('.slick-header').remove();
      var footer = [];
      footer
        .push('<button name="ok" type="button" class="btn btn-default">OK</button>');
      footer
        .push('<button name="cancel" type="button" data-dismiss="modal" class="btn btn-default">Cancel</button>');
      var $footer = $(footer.join(''));
      morpheus.FormBuilder.showOkCancel({
        title: 'Open',
        content: $el,
        close: false,
        cancelCallback: function () {
          callback(null);
        },
        okCallback: function () {
          _this._read(name, lines, dataColumnStart, dataRowStart, callback);
        }
      });
      grid.resizeCanvas();

    }).fail(function (err) {
      callback(err);
    });

  },
  _read: function (datasetName, lines, dataColumnStart, dataRowStart, cb) {
    var columnCount = lines[0].length;
    var columns = columnCount - dataColumnStart;
    var rows = lines.length - dataRowStart;
    var dataset = new morpheus.Dataset({
      name: datasetName,
      rows: rows,
      columns: columns,
      dataType: 'Float32'
    });

    // column metadata names are in 1st
    // column
    if (dataColumnStart > 0) {
      for (var i = 0; i < dataRowStart; i++) {
        var name = lines[i][0];
        if (name == null || name === '' || name === 'na') {
          name = 'Annotation';
        }
        var unique = 1;
        while (dataset.getColumnMetadata().getByName(name) != null) {
          name = name + '-' + unique;
          unique++;
        }
        var v = dataset.getColumnMetadata().add(name);
        var nonEmpty = false;
        for (var j = 0; j < columns; j++) {
          var s = lines[i][j + dataColumnStart];
          if (s != null && s !== '') {
            nonEmpty = true;
            v.setValue(j, s);
          }
        }
        if (!nonEmpty) {
          dataset.getColumnMetadata().remove(morpheus.MetadataUtil.indexOf(dataset.getColumnMetadata(), v.getName()));
        }

      }
    }
    if (dataRowStart > 0) {
      // row metadata names are in first row
      for (var j = 0; j < dataColumnStart; j++) {
        var name = lines[0][j];
        if (name == null || name === '') {
          name = 'Annotation';
        }
        var unique = 1;
        while (dataset.getRowMetadata().get(name) != null) {
          name = name + '-' + unique;
          unique++;
        }
        dataset.getRowMetadata().add(name);

      }
    }

    for (var i = 0; i < rows; i++) {
      for (var j = 0, k = 0; k < dataset.getRowMetadata().getMetadataCount(); j++, k++) {
        var metaDataValue = lines[i + dataRowStart][j];
        dataset.getRowMetadata().get(j).setValue(i, metaDataValue);
      }
    }

    for (var i = 0; i < rows; i++) {
      for (var j = 0; j < columns; j++) {
        var s = lines[i + dataRowStart][j + dataColumnStart];
        dataset.setValue(i, j, parseFloat(s));
      }
    }

    morpheus.MetadataUtil.maybeConvertStrings(dataset.getRowMetadata(), 1);
    morpheus.MetadataUtil.maybeConvertStrings(dataset.getColumnMetadata(),
      1);
    cb(null, dataset);
  }
};

morpheus.BufferedReader = function (reader, callback, doneCallback) {
  var textDecoder = new TextDecoder();
  var skipLF = false;
  var text = '';
  reader.read().then(function processResult(result) {
    // result contains a value which is an array of Uint8Array
    text += (result.done ? '' : textDecoder.decode(result.value));
    var start = 0;
    // TODO no need to search previous chunk of text
    for (var i = 0, length = text.length; i < length; i++) {
      var c = text[i];
      if (skipLF && c === '\n') {
        start++;
        skipLF = false;
      } else if (c === '\n' || c === '\r') {
        skipLF = c === '\r'; // \r\n windows line ending
        var s = morpheus.Util.copyString(text.substring(start, i));
        callback(s);
        start = i + 1;
      } else {
        skipLF = false;
      }
    }
    text = start < text.length ? text.substring(start) : '';
    if (!result.done) {
      return reader.read().then(processResult);
    } else {
      if (text !== '' && text !== '\r') {
        callback(text);
      }
      doneCallback();
    }
  });
};

morpheus.BufferedReader.parse = function (url, options) {
  var delim = options.delimiter;
  var regex = new RegExp(delim);
  var handleTokens = options.handleTokens;
  var complete = options.complete;
  fetch(url).then(function (response) {
    if (response.ok) {
      var reader = response.body.getReader();
      new morpheus.BufferedReader(reader, function (line) {
        handleTokens(line.split(regex));
      }, function () {
        complete();
      });
    } else {
      options.error('Network error');
    }
  }).catch(function (error) {
    options.error(error);
  });
};


/**
 * Class for reading cls files. <p/> <p/> The CLS files are simple files created
 * to load class information into GeneCluster. These files use spaces to
 * separate the fields.
 * </P>
 * <UL>
 * <LI>The first line of a CLS file contains numbers indicating the number of
 * samples and number of classes. The number of samples should correspond to the
 * number of samples in the associated RES or GCT data file.</LI>
 * <p/>
 * <UL>
 * <LI>Line format: (number of samples) (space) (number of classes) (space) 1</LI>
 * <LI>For example: 58 2 1</LI>
 * </UL>
 * <p/>
 * <LI>The second line in a CLS file contains names for the class numbers. The
 * line should begin with a pound sign (#) followed by a space.</LI>
 * <p/>
 * <UL>
 * <LI>Line format: # (space) (class 0 name) (space) (class 1 name)</LI>
 * <p/>
 * <LI>For example: # cured fatal/ref.</LI>
 * </UL>
 * <p/>
 * <LI>The third line contains numeric class labels for each of the samples.
 * The number of class labels should be the same as the number of samples
 * specified in the first line.</LI>
 * <UL>
 * <LI>Line format: (sample 1 class) (space) (sample 2 class) (space) ...
 * (sample N class)</LI>
 * <LI>For example: 0 0 0 ... 1
 * </UL>
 * <p/>
 * </UL>
 */
morpheus.ClsReader = function () {
};
morpheus.ClsReader.prototype = {
  /**
   * Parses the cls file.
   *
   * @param file
   *            The file.
   * @throw new Errors Exception If there is a problem with the data
   */
  read: function (lines) {
    var regex = /[ ,]+/;
    // header= <num_data> <num_classes> 1
    var header = lines[0].split(regex);
    if (header.length < 3) {
      throw new Error('Header line needs three numbers');
    }
    var headerNumbers = [];
    try {
      for (var i = 0; i < 3; i++) {
        headerNumbers[i] = parseInt($.trim(header[i]));
      }
    }
    catch (e) {
      throw new Error('Header line element ' + i + ' is not a number');
    }
    if (headerNumbers[0] <= 0) {
      throw new Error(
        'Header line missing first number, number of data points');
    }
    if (headerNumbers[1] <= 0) {
      throw new Error(
        'Header line missing second number, number of classes');
    }
    var numClasses = headerNumbers[1];
    var numItems = headerNumbers[0];
    var classDefinitionLine = lines[1];
    classDefinitionLine = classDefinitionLine.substring(classDefinitionLine
        .indexOf('#') + 1);
    var classNames = $.trim(classDefinitionLine).split(regex);
    if (classNames.length < numClasses) {
      throw new Error('First line specifies ' + numClasses
        + ' classes, but found ' + classNames.length + '.');
    }
    var dataLine = lines[2];
    var assignments = dataLine.split(regex);
    // convert the assignments to names
    for (var i = 0; i < assignments.length; i++) {
      var assignment = $.trim(assignments[i]);
      var index = parseInt(assignment);
      var tmp = classNames[index];
      if (tmp !== undefined) {
        assignments[i] = tmp;
      }
    }
    return assignments;
  }
};

morpheus.ClsWriter = function () {

};
morpheus.ClsWriter.prototype = {
  write: function (vector) {
    var pw = [];
    var size = vector.size();
    pw.push(size);
    pw.push(' ');
    var set = morpheus.VectorUtil.getSet(vector);
    pw.push(set.size());
    pw.push(' ');
    pw.push('1\n');
    pw.push('#');
    var valueToIndex = new morpheus.Map();
    var index = 0;
    set.forEach(function (name) {
      pw.push(' ');
      pw.push(name);
      valueToIndex.set(name, index++);
    });
    pw.push('\n');
    for (var i = 0; i < size; i++) {
      if (i > 0) {
        pw.push(' ');
      }
      pw.push(valueToIndex.get(vector.getValue(i)));
    }
    pw.push('\n');
    return pw.join('');
  }
};

morpheus.GctReader = function () {

};

morpheus.GctReader.prototype = {
  getFormatName: function () {
    return 'gct';
  },
  read: function (fileOrUrl, callback) {
    var _this = this;
    if (fileOrUrl instanceof File) {
      this._readChunking(fileOrUrl, callback, false);
    } else {
      if (morpheus.Util.isFetchSupported()) {
        this._readChunking(fileOrUrl, callback, true);
      } else {
        this._readNoChunking(fileOrUrl, callback);
      }
      // XXX only do byte range requests from S3
      // if (fileOrUrl.indexOf('s3.amazonaws.com') !== -1) {
      // 	$.ajax({
      // 		url: fileOrUrl,
      // 		method: 'HEAD'
      // 	}).done(function (data, textStatus, jqXHR) {
      // 		if ('gzip' === jqXHR.getResponseHeader('Content-Encoding')) {
      // 			_this._readNoChunking(fileOrUrl, callback);
      // 		} else {
      // 			_this._readChunking(fileOrUrl, callback, false);
      // 		}
      // 	}).fail(function () {
      // 		_this._readNoChunking(fileOrUrl, callback);
      // 	});
      // } else {
      // 	_this._readNoChunking(fileOrUrl, callback);
      // }
    }
  },
  _readChunking: function (fileOrUrl, callback, useFetch) {
    var _this = this;
    // Papa.LocalChunkSize = 10485760 * 10; // 100 MB
    //Papa.RemoteChunkSize = 10485760 / 2; // 10485760 = 10MB
    var lineNumber = 0;
    var version;
    var numRowAnnotations = 1; // in addition to row id
    var numColumnAnnotations = 0; // in addition to column id
    var nrows = -1;
    var ncols = -1;
    var version = 2;
    var rowMetadataNames = [];
    var columnMetadataNames = [];
    var rowMetadata = [[]];
    var columnMetadata = [[]];
    var dataColumnStart;
    var matrix = [];
    var dataMatrixLineNumberStart;
    var columnIdFieldName = 'id';
    var rowIdFieldName = 'id';
    var columnNamesArray;

    var handleTokens = function (tokens) {

      if (lineNumber === 0) {
        var text = tokens[0].trim();
        if ('#1.2' === text) {
          version = 2;
        } else if ('#1.3' === text) {
          version = 3;
        } else {
          console.log('Unknown version: assuming version 2');
        }
      } else if (lineNumber === 1) {
        var dimensions = tokens;
        if (version === 3) {
          if (dimensions.length >= 4) {
            nrows = parseInt(dimensions[0]);
            ncols = parseInt(dimensions[1]);
            numRowAnnotations = parseInt(dimensions[2]);
            numColumnAnnotations = parseInt(dimensions[3]);
          } else { // no dimensions specified
            numRowAnnotations = parseInt(dimensions[0]);
            numColumnAnnotations = parseInt(dimensions[1]);
          }
        } else {
          nrows = parseInt(dimensions[0]);
          ncols = parseInt(dimensions[1]);
          if (nrows <= 0 || ncols <= 0) {
            callback(
              'Number of rows and columns must be greater than 0.');
          }
        }
        dataColumnStart = numRowAnnotations + 1;
      } else if (lineNumber === 2) {
        columnNamesArray = tokens;
        for (var i = 0; i < columnNamesArray.length; i++) {
          columnNamesArray[i] = morpheus.Util.copyString(columnNamesArray[i]);
        }
        if (ncols === -1) {
          ncols = columnNamesArray.length - numRowAnnotations - 1;
        }
        if (version == 2) {
          var expectedColumns = ncols + 2;
          if (columnNamesArray.length !== expectedColumns) {
            callback('Expected ' + (expectedColumns - 2)
              + ' column names, but read '
              + (columnNamesArray.length - 2) + ' column names.');
          }
        }
        var name = columnNamesArray[0];
        var slashIndex = name.lastIndexOf('/');

        if (slashIndex != -1 && slashIndex < (name.length - 1)) {
          rowIdFieldName = name.substring(0, slashIndex);
          columnIdFieldName = name.substring(slashIndex + 1);
        }
        rowMetadataNames.push(rowIdFieldName);
        columnMetadataNames.push(columnIdFieldName);
        for (var j = 0; j < ncols; j++) {
          var index = j + numRowAnnotations + 1;
          var columnName = index < columnNamesArray.length ? columnNamesArray[index]
            : null;
          columnMetadata[0].push(morpheus.Util.copyString(columnName));
        }

        for (var j = 0; j < numRowAnnotations; j++) {
          var rowMetadataName = '' === columnNamesArray[1] ? 'description'
            : columnNamesArray[j + 1];
          rowMetadataNames.push(
            rowMetadataName);
          rowMetadata.push([]);
        }
        dataMatrixLineNumberStart = 3 + numColumnAnnotations;
      } else { // lines >=3
        if (lineNumber < dataMatrixLineNumberStart) {
          var metadataName = morpheus.Util.copyString(tokens[0]);
          var v = [];
          columnMetadata.push(v);
          columnMetadataNames.push(metadataName);
          for (var j = 0; j < ncols; j++) {
            v.push(morpheus.Util.copyString(tokens[j + dataColumnStart]));
          }
        } else { // data lines
          if (tokens[0] !== '') {
            var array = new Float32Array(ncols);
            matrix.push(array);
            // we iterate to numRowAnnotations + 1 to include id row
            // metadata field
            for (var rowAnnotationIndex = 0; rowAnnotationIndex <= numRowAnnotations; rowAnnotationIndex++) {
              var rowMetadataValue = tokens[rowAnnotationIndex];
              rowMetadata[rowAnnotationIndex].push(
                morpheus.Util.copyString(rowMetadataValue));

            }

            for (var columnIndex = 0; columnIndex < ncols; columnIndex++) {
              var token = tokens[columnIndex + dataColumnStart];
              array[columnIndex] = parseFloat(token);
            }
          }
        }
      }
      lineNumber++;

    };
    (useFetch ? morpheus.BufferedReader : Papa).parse(fileOrUrl, {
      delimiter: '\t',	// auto-detect
      newline: '',	// auto-detect
      header: false,
      dynamicTyping: false,
      preview: 0,
      encoding: '',
      worker: false,
      comments: false,
      handleTokens: handleTokens,
      step: function (result) {
        handleTokens(result.data[0]);
      },
      complete: function () {
        var dataset = new morpheus.Dataset({
          name: morpheus.Util.getBaseFileName(morpheus.Util
            .getFileName(fileOrUrl)),
          rows: matrix.length,
          columns: ncols,
          array: matrix,
          dataType: 'Float32'
        });
        for (var i = 0; i < rowMetadataNames.length; i++) {
          dataset.getRowMetadata().add(rowMetadataNames[i]).array = rowMetadata[i];
        }
        for (var i = 0; i < columnMetadataNames.length; i++) {
          dataset.getColumnMetadata().add(columnMetadataNames[i]).array = columnMetadata[i];
        }
        morpheus.MetadataUtil.maybeConvertStrings(dataset.getRowMetadata(), 1);
        morpheus.MetadataUtil.maybeConvertStrings(dataset.getColumnMetadata(),
          1);
        callback(null, dataset);
      },
      error: function (err) {
        callback(err);
      },
      download: !(fileOrUrl instanceof File),
      skipEmptyLines: false,
      chunk: undefined,
      fastMode: true,
      beforeFirstChunk: undefined,
      withCredentials: undefined
    });
  },
  _read: function (datasetName, reader) {
    var tab = /\t/;
    var versionLine = morpheus.Util.copyString(reader.readLine().trim());
    if (versionLine === '') {
      throw new Error('Missing version line');
    }
    var version = 2;
    if ('#1.2' === versionLine) {
      version = 2;
    } else if ('#1.3' === versionLine) {
      version = 3;
    } else {
      console.log('Unknown version: assuming version 2');
    }
    var dimensionsLine = morpheus.Util.copyString(reader.readLine());
    if (dimensionsLine == null) {
      throw new Error('No dimensions specified');
    }
    // <numRows> <tab> <numCols>
    var dimensions = dimensionsLine.split(/[ \t]/);
    var numRowAnnotations = 1; // in addition to row id
    var numColumnAnnotations = 0; // in addition to column id
    var nrows = -1;
    var ncols = -1;
    if (version === 3) {
      if (dimensions.length >= 4) {
        nrows = parseInt(dimensions[0]);
        ncols = parseInt(dimensions[1]);
        numRowAnnotations = parseInt(dimensions[2]);
        numColumnAnnotations = parseInt(dimensions[3]);
      } else { // no dimensions specified
        numRowAnnotations = parseInt(dimensions[0]);
        numColumnAnnotations = parseInt(dimensions[1]);
      }
    } else {
      nrows = parseInt(dimensions[0]);
      ncols = parseInt(dimensions[1]);
      if (nrows <= 0 || ncols <= 0) {
        throw new Error(
          'Number of rows and columns must be greater than 0.');
      }
    }
    var columnNamesLine = morpheus.Util.copyString(reader.readLine());
    if (columnNamesLine == null) {
      throw new Error('No column annotations');
    }

    var columnNamesArray = columnNamesLine.split(tab);
    if (ncols === -1) {
      ncols = columnNamesArray.length - numRowAnnotations - 1;
    }
    if (version == 2) {
      var expectedColumns = ncols + 2;
      if (columnNamesArray.length !== expectedColumns) {
        throw new Error('Expected ' + (expectedColumns - 2)
          + ' column names, but read '
          + (columnNamesArray.length - 2) + ' column names.');
      }
    }
    var name = columnNamesArray[0];
    var slashIndex = name.lastIndexOf('/');
    var columnIdFieldName = 'id';
    var rowIdFieldName = 'id';
    if (slashIndex != -1 && slashIndex < (name.length - 1)) {
      rowIdFieldName = name.substring(0, slashIndex);
      columnIdFieldName = name.substring(slashIndex + 1);
    }
    if (nrows === -1) {
      var matrix = [];
      var rowMetadataNames = [rowIdFieldName];
      var columnMetadataNames = [columnIdFieldName];
      var rowMetadata = [[]];
      var columnMetadata = [[]];
      for (var j = 0; j < ncols; j++) {
        var index = j + numRowAnnotations + 1;
        var columnName = index < columnNamesArray.length ? columnNamesArray[index]
          : null;
        columnMetadata[0].push(morpheus.Util.copyString(columnName));
      }

      for (var j = 0; j < numRowAnnotations; j++) {
        var rowMetadataName = '' === columnNamesArray[1] ? 'description'
          : columnNamesArray[j + 1];
        rowMetadataNames.push(
          rowMetadataName);
        rowMetadata.push([]);
      }

      var dataColumnStart = numRowAnnotations + 1;
      var ntokens = ncols + numRowAnnotations + 1;
      var linen = 3;
      if (numColumnAnnotations > 0) {
        for (var columnAnnotationIndex = 0; columnAnnotationIndex < numColumnAnnotations; columnAnnotationIndex++) {
          var tokens = reader.readLine().split(tab);
          var metadataName = tokens[0];
          var v = [];
          columnMetadata.push(v);
          columnMetadataNames.push(metadataName);
          for (var j = 0; j < ncols; j++) {
            v.push(morpheus.Util.copyString(tokens[j + dataColumnStart]));
          }
        }
      }

      var nonEmptyDescriptionFound = false;
      var numRowAnnotationsPlusOne = numRowAnnotations + 1;
      var s;
      while ((s = reader.readLine()) !== null) {
        if (s !== '') {
          var array = new Float32Array(ncols);
          matrix.push(array);
          var tokens = s.split(tab);
          // we iterate to numRowAnnotations + 1 to include id row
          // metadata field
          for (var rowAnnotationIndex = 0; rowAnnotationIndex < numRowAnnotationsPlusOne; rowAnnotationIndex++) {
            var rowMetadataValue = tokens[rowAnnotationIndex];
            rowMetadata[rowAnnotationIndex].push(
              morpheus.Util.copyString(rowMetadataValue));

          }

          for (var columnIndex = 0; columnIndex < ncols; columnIndex++) {
            var token = tokens[columnIndex + dataColumnStart];
            array[columnIndex] = parseFloat(token);
          }
        }

      }
      var dataset = new morpheus.Dataset({
        name: datasetName,
        rows: matrix.length,
        columns: ncols,
        array: matrix,
        dataType: 'Float32'
      });
      for (var i = 0; i < rowMetadataNames.length; i++) {
        dataset.getRowMetadata().add(rowMetadataNames[i]).array = rowMetadata[i];
      }
      for (var i = 0; i < columnMetadataNames.length; i++) {
        dataset.getColumnMetadata().add(columnMetadataNames[i]).array = columnMetadata[i];
      }
      morpheus.MetadataUtil.maybeConvertStrings(dataset.getRowMetadata(), 1);
      morpheus.MetadataUtil.maybeConvertStrings(dataset.getColumnMetadata(),
        1);
      return dataset;

    } else {
      var dataset = new morpheus.Dataset({
        dataType: 'Float32',
        name: datasetName,
        rows: nrows,
        columns: ncols
      });

      var columnIds = dataset.getColumnMetadata().add(columnIdFieldName);
      if (version == 3) {
        for (var j = 0; j < ncols; j++) {
          var index = j + numRowAnnotations + 1;
          var columnName = index < columnNamesArray.length ? columnNamesArray[index]
            : null;
          columnIds.setValue(j, morpheus.Util.copyString(columnName));
        }

      } else {
        for (var j = 0; j < ncols; j++) {
          var columnName = columnNamesArray[j + numRowAnnotations + 1];
          columnIds.setValue(j, morpheus.Util.copyString(columnName));
        }
      }

      var rowAnnotationVectors = [dataset.getRowMetadata().add(
        rowIdFieldName)];
      if (version === 3) {
        for (var j = 0; j < numRowAnnotations; j++) {
          var rowMetadataName = '' === columnNamesArray[1] ? 'description'
            : columnNamesArray[j + 1];
          rowAnnotationVectors.push(dataset.getRowMetadata().add(
            rowMetadataName));
        }

      } else {
        rowAnnotationVectors.push(dataset.getRowMetadata().add(
          columnNamesArray[1]));
      }

      var dataColumnStart = numRowAnnotations + 1;
      var ntokens = ncols + numRowAnnotations + 1;
      var linen = 3;
      if (numColumnAnnotations > 0) {
        for (var columnAnnotationIndex = 0; columnAnnotationIndex < numColumnAnnotations; columnAnnotationIndex++) {
          var tokens = reader.readLine().split(tab);
          var metadataName = tokens[0];
          var v = dataset.getColumnMetadata().add(metadataName);
          for (var j = 0; j < ncols; j++) {
            v.setValue(j, morpheus.Util.copyString(tokens[j + dataColumnStart]));
          }
        }
      }

      var nonEmptyDescriptionFound = false;
      var numRowAnnotationsPlusOne = numRowAnnotations + 1;
      for (var rowIndex = 0, nrows = dataset.getRowCount(); rowIndex < nrows; rowIndex++) {
        var s = reader.readLine();
        if (s === null) {
          throw new Error('Missing data rows.');
        }
        var tokens = s.split(tab);
        if (version === 2) {
          rowAnnotationVectors[0].setValue(rowIndex, morpheus.Util.copyString(tokens[0]));
          var desc = tokens[1];
          if (!nonEmptyDescriptionFound) {
            nonEmptyDescriptionFound = desc !== '';
          }
          rowAnnotationVectors[1].setValue(rowIndex, morpheus.Util.copyString(desc));
        } else {
          // we iterate to numRowAnnotations + 1 to include id row
          // metadata field
          for (var rowAnnotationIndex = 0; rowAnnotationIndex < numRowAnnotationsPlusOne; rowAnnotationIndex++) {
            var rowMetadataValue = tokens[rowAnnotationIndex];
            rowAnnotationVectors[rowAnnotationIndex].setValue(rowIndex,
              morpheus.Util.copyString(rowMetadataValue));

          }
        }
        for (var columnIndex = 0; columnIndex < ncols; columnIndex++) {
          var token = tokens[columnIndex + dataColumnStart];
          // if (token[0] === '{') {
          // var value = JSON.parse(token);
          // dataset.setValue(rowIndex, columnIndex, morpheus.Util
          // .wrapNumber(value.__v, value));
          // } else {
          // dataset.setValue(rowIndex, columnIndex, parseFloat(token));
          // }
          dataset.setValue(rowIndex, columnIndex, parseFloat(token));
        }

      }

      if (version === 2 && !nonEmptyDescriptionFound) {
        dataset.getRowMetadata().remove(1);
      }
      if (rowIndex !== nrows) {
        throw new Error('Missing data rows');
      }

      morpheus.MetadataUtil.maybeConvertStrings(dataset.getRowMetadata(), 1);
      morpheus.MetadataUtil.maybeConvertStrings(dataset.getColumnMetadata(),
        1);
      return dataset;
    }
  },
  _readNoChunking: function (fileOrUrl, callback) {
    var _this = this;
    var name = morpheus.Util.getBaseFileName(morpheus.Util
      .getFileName(fileOrUrl));
    morpheus.ArrayBufferReader.getArrayBuffer(fileOrUrl, function (err, arrayBuffer) {
      if (err) {
        callback(err);
      } else {
        callback(null, _this._read(name,
          new morpheus.ArrayBufferReader(new Uint8Array(
            arrayBuffer))));
      }
    });
    // $.ajax({
    // 	url: fileOrUrl,
    // 	dataType: 'text'
    // }).done(function (text) {
    // 	callback(null, _this.read(name, new morpheus.StringReader(text)));
    // }).fail(function (err) {
    // 	callback(err);
    // });

  }
};

morpheus.GctWriter = function () {
};

morpheus.GctWriter.idFirst = function (model) {
  var fields = ['id', 'Id', 'pr_id'];
  var idIndex = -1;
  for (var i = 0; i < fields.length; i++) {
    idIndex = morpheus.MetadataUtil.indexOf(model, fields[i]);
    if (idIndex !== -1) {
      break;
    }
  }
  if (idIndex !== -1) {
    var order = [];
    order[0] = idIndex;
    for (var i = 0, j = 1, count = model.getMetadataCount(); i < count; i++) {
      if (i !== idIndex) {
        order[j++] = i;
      }
    }
    return new morpheus.MetadataModelColumnView(model, order);
  }
  return model;
};

morpheus.GctWriter.prototype = {
  toString: function (value) {
    return morpheus.Util.toString(value);
  },
  getExtension: function () {
    return 'gct';
  },
  write: function (dataset, pw) {
    if (pw == null) {
      pw = [];
    }
    var rowMetadata = morpheus.GctWriter.idFirst(dataset.getRowMetadata());
    var columnMetadata = morpheus.GctWriter.idFirst(dataset
      .getColumnMetadata());
    this.writeHeader(rowMetadata, columnMetadata, pw);
    this.writeData(dataset, rowMetadata, pw);
    return pw.join('');
  },
  writeData: function (dataset, rowMetadata, pw) {
    var ncols = dataset.getColumnCount();
    var rowMetadataCount = rowMetadata.getMetadataCount();
    for (var i = 0, rows = dataset.getRowCount(); i < rows; i++) {
      for (var rowMetadataIndex = 0; rowMetadataIndex < rowMetadataCount; rowMetadataIndex++) {
        if (rowMetadataIndex > 0) {
          pw.push('\t');
        }
        var value = rowMetadata.get(rowMetadataIndex).getValue(i);
        if (value !== null) {
          pw.push(this.toString(value));
        }
      }
      for (var j = 0; j < ncols; j++) {
        pw.push('\t');
        var value = dataset.getValue(i, j);
        // pw.push((value != null && value.toObject) ? JSON
        // .stringify(value.toObject()) : morpheus.Util.nf(value));
        pw.push(morpheus.Util.nf(value));
      }
      pw.push('\n');
    }
  },
  writeHeader: function (rowMetadata, columnMetadata, pw) {
    var rows = rowMetadata.getItemCount();
    var ncols = columnMetadata.getItemCount();
    pw.push('#1.3\n');
    var rowMetadataCount = rowMetadata.getMetadataCount();
    pw.push(rows + '\t' + ncols + '\t' + (rowMetadataCount - 1) + '\t'
      + (columnMetadata.getMetadataCount() - 1));
    pw.push('\n');
    for (var i = 0; i < rowMetadataCount; i++) {
      if (i > 0) {
        pw.push('\t');
      }
      var name = rowMetadata.get(i).getName();
      if (i === 0 && name !== columnMetadata.get(0).getName()) {
        name = name + '/' + columnMetadata.get(0).getName();
      }
      pw.push(name);
    }
    for (var j = 0; j < ncols; j++) {
      pw.push('\t');
      pw.push(this.toString(columnMetadata.get(0).getValue(j)));
    }
    pw.push('\n');
    for (var columnMetadataIndex = 1, metadataSize = columnMetadata
      .getMetadataCount(); columnMetadataIndex < metadataSize; columnMetadataIndex++) {
      pw.push(columnMetadata.get(columnMetadataIndex).getName());
      for (var i = 1; i < rowMetadataCount; i++) {
        pw.push('\t');
        pw.push('na');
      }
      for (var j = 0; j < ncols; j++) {
        pw.push('\t');
        var value = columnMetadata.get(columnMetadataIndex).getValue(j);
        if (value != null) {
          pw.push(this.toString(value));
        }
      }
      pw.push('\n');
    }
  }
};

morpheus.GctWriter12 = function () {
  this.options = {
    rowDescription: 'Description',
    rowId: 'id',
    columnId: 'id'
  };
};
morpheus.GctWriter12.prototype = {
  toString: function (value) {
    return morpheus.Util.toString(value);
  },
  getExtension: function () {
    return 'gct';
  },
  write: function (dataset, pw) {
    if (pw == null) {
      pw = [];
    }
    var rows = dataset.getRowCount();
    var columns = dataset.getColumnCount();
    var version = '#1.2';
    pw.push(version);
    pw.push('\n');
    pw.push(rows + '\t' + columns);
    pw.push('\n');
    var rowMetadata = morpheus.GctWriter.idFirst(dataset.getRowMetadata());
    var columnMetadata = morpheus.GctWriter.idFirst(dataset
      .getColumnMetadata());
    pw.push('Name');
    pw.push('\t');
    pw.push('Description');
    var columnIds = columnMetadata.getByName(this.options.columnId);
    if (!columnIds) {
      columnIds = columnMetadata.get(0);
    }
    for (var j = 0; j < columns; j++) {
      pw.push('\t');
      pw.push(this.toString(columnIds.getValue(j)));
    }
    var rowIds = rowMetadata.get(this.options.rowId);
    if (!rowIds) {
      rowIds = rowMetadata.get(0);
    }
    var rowDescriptions = rowMetadata
      .getByName(this.options.rowDescription);
    if (rowDescriptions == null && rowMetadata.getMetadataCount() > 1) {
      rowDescriptions = rowMetadata.get(1);
    }

    for (var i = 0; i < rows; i++) {
      pw.push('\n');
      pw.push(this.toString(rowIds.getValue(i)));
      pw.push('\t');
      var rowDescription = rowDescriptions != null ? rowDescriptions
        .getValue(i) : null;
      if (rowDescription != null) {
        pw.push(this.toString(rowDescription));
      }
      for (var j = 0; j < columns; j++) {
        pw.push('\t');
        pw.push(morpheus.Util.nf(dataset.getValue(i, j)));
      }
    }
    pw.push('\n');
    return pw.join('');
  }
};

morpheus.GisticReader = function () {

};
morpheus.GisticReader.prototype = {
  read: function (fileOrUrl, callback) {
    var _this = this;
    var name = morpheus.Util.getBaseFileName(morpheus.Util
      .getFileName(fileOrUrl));
    morpheus.ArrayBufferReader.getArrayBuffer(fileOrUrl, function (err,
                                                                   arrayBuffer) {
      if (err) {
        callback(err);
      } else {
        try {
          callback(null, _this._read(name,
            new morpheus.ArrayBufferReader(new Uint8Array(
              arrayBuffer))));
        }
        catch (x) {
          if (x.stack) {
            console.log(x.stack);
          }
          callback(x);
        }
      }
    });

  },
  _read: function (datasetName, reader) {
    var tab = /\t/;
    var header = reader.readLine().trim().split(tab);

    // Unique Name, Descriptor, Wide Peak Limits, Peak Limits, Region
    // Limits, q values, Residual q values after removing segments shared
    // with higher peaks, Broad or Focal, Amplitude Threshold

    var ncols = header.length - 9;
    var matrix = [];
    var s;
    var rowIds = [];
    var qValues = [];
    while ((s = reader.readLine()) !== null) {
      s = s.trim();

      if (s !== '') {
        var tokens = s.split(tab);
        if (tokens[8] === 'Actual Copy Change Given') {
          var array = new Float32Array(ncols);
          matrix.push(array);
          rowIds.push(String($.trim(tokens[1])));
          qValues.push(parseFloat(tokens[5]));
          for (var j = 9; j <= ncols; j++) {
            var token = tokens[j];
            array[j - 9] = parseFloat(token);
          }
        }
      }
    }
    var dataset = new morpheus.Dataset({
      name: datasetName,
      rows: matrix.length,
      columns: ncols,
      array: matrix,
      dataType: 'Float32'
    });

    var columnIds = dataset.getColumnMetadata().add('id');
    for (var j = 0; j < ncols; j++) {
      columnIds.setValue(j, String(header[j + 9]));
    }

    dataset.getRowMetadata().add('id').array = rowIds;
    dataset.getRowMetadata().add('q_value').array = qValues;
    return dataset;
  }
};

morpheus.GmtDatasetReader = function () {
};
morpheus.GmtDatasetReader.prototype = {
  getFormatName: function () {
    return 'gmt';
  },
  read: function (fileOrUrl, callback) {
    var name = morpheus.Util.getBaseFileName(morpheus.Util
      .getFileName(fileOrUrl));
    morpheus.ArrayBufferReader.getArrayBuffer(fileOrUrl, function (err, arrayBuffer) {
      if (err) {
        callback(err);
      } else {
        try {
          callback(null, morpheus.DatasetUtil.geneSetsToDataset(name,
            new morpheus.GmtReader()
              .read(new morpheus.ArrayBufferReader(
                new Uint8Array(arrayBuffer)))));
        }
        catch (x) {
          callback(x);
        }
      }
    });

  }
};

morpheus.GmtReader = function () {
};
morpheus.GmtReader.prototype = {
  read: function (reader) {
    var sets = [];
    var tab = /\t/;
    var s;
    while ((s = reader.readLine()) != null) {
      if (s === '' || s[0] === '#') {
        continue;
      }
      var tokens = s.split(tab);
      var name = tokens[0].trim();
      var description = tokens.length > 1 ? tokens[1].trim() : '';
      if ('BLANK' === description) {
        description = '';
      }
      var ids = [];
      for (var i = 2; i < tokens.length; i++) {
        var geneName = tokens[i].trim();
        if (geneName !== '') {
          ids.push(geneName);
        }
      }
      var set = {
        name: name,
        description: description,
        ids: ids
      };
      set.toString = function () {
        return this.name;
      };
      sets.push(set);
    }
    return sets;
  }
};

morpheus.GseReader = function (options) {
  this.type = options.type;
};
morpheus.GseReader.prototype = {
  read: function (name, callback) {
    var req = ocpu.call('loadGEO', {name: name, type: this.type}, function (session) {
      //console.log('morpheus.GseReader.prototype.read ::', session);
      session.getObject(function (success) {
        //console.log('morpheus.GseReader.prototype.read ::', success);
        var r = new FileReader();
        var filePath = morpheus.Util.getFilePath(session, success);
        //console.log('morpheus.GseReader.prototype.read ::', filePath);
        r.onload = function (e) {
          var contents = e.target.result;
          var ProtoBuf = dcodeIO.ProtoBuf;
          ProtoBuf.protoFromFile("./message.proto", function (error, success) {
            if (error) {
              alert(error);
              console.log("GSEReader ::", "ProtoBuilder failed", error);
              return;
            }
            var builder = success,
              rexp = builder.build("rexp"),
              REXP = rexp.REXP,
              rclass = REXP.RClass;


            var res = REXP.decode(contents);

            var jsondata = morpheus.Util.getRexpData(res, rclass);

            var flatData = jsondata.data.values;
            var nrowData = jsondata.data.dim[0];
            var ncolData = jsondata.data.dim[1];
            var flatPdata = jsondata.pdata.values;
            //var participants = jsondata.participants.values;
            var annotation = jsondata.fdata.values;
            console.log(annotation);
            var id = jsondata.rownames.values;
            var metaNames = jsondata.colMetaNames.values;
            var rowMetaNames = jsondata.rowMetaNames.values;

            var matrix = [];
            for (var i = 0; i < nrowData; i++) {
              var curArray = new Float32Array(ncolData);
              for (var j = 0; j < ncolData; j++) {
                curArray[j] = flatData[i + j * nrowData];
              }
              matrix.push(curArray);
            }
            var dataset = new morpheus.Dataset({
              name: name,
              rows: nrowData,
              columns: ncolData,
              array: matrix,
              dataType: 'Float32',
              esSession: session
            });


            /*console.log("morpheus.GseReader.prototype.read ::", "input list", res);
             console.log("morpheus.GseReader.prototype.read ::", "metaNames", metaNames);
             console.log("morpheus.GseReader.prototype.read ::", dataset);*/
            /*var columnsIds = dataset.getColumnMetadata().add('id');
            for (var i = 0; i < ncolData; i++) {
              columnsIds.setValue(i, morpheus.Util.copyString(participants[i]));
            }*/
            //console.log(flatPdata);
            for (var i = 0; i < metaNames.length; i++) {
              var curVec = dataset.getColumnMetadata().add(metaNames[i]);
              for (var j = 0; j < ncolData; j++) {
                curVec.setValue(j, flatPdata[j + i * ncolData]);
              }
            }

            var rowIds = dataset.getRowMetadata().add('id');

            /*if (annotation) {
              var rowSymbol = dataset.getRowMetadata().add('symbol');
            }*/
            for (var i = 0; i < rowMetaNames.length; i++) {
              var curVec = dataset.getRowMetadata().add(rowMetaNames[i]);
              for (var j = 0; j < nrowData; j++) {
                curVec.setValue(j, annotation[j + i * nrowData]);
                rowIds.setValue(j, id[j])
              }
            }
            morpheus.MetadataUtil.maybeConvertStrings(dataset.getRowMetadata(), 1);
            morpheus.MetadataUtil.maybeConvertStrings(dataset.getColumnMetadata(),
              1);
            callback(null, dataset);

          });
        };

        morpheus.BlobFromPath.getFileObject(filePath, function (file) {
          //console.log('morpheus.GseReader.prototype.read ::', file);
          r.readAsArrayBuffer(file);
        });

      })
    });
    req.fail(function () {
      callback(req.responseText);
      //console.log('morpheus.GseReader.prototype.read ::', req.responseText);
    });

  },
  _parse: function (text) {

  }
};
morpheus.JsonDatasetReader = function () {

};

morpheus.JsonDatasetReader.prototype = {
  read: function (fileOrUrl, callback) {
    var _this = this;
    var name = morpheus.Util.getBaseFileName(morpheus.Util.getFileName(fileOrUrl));
    var isString = typeof fileOrUrl === 'string' || fileOrUrl instanceof String;
    if (isString) {
      $.ajax(fileOrUrl).done(function (json) {
        callback(null, morpheus.Dataset.fromJSON(json));
      }).fail(function (err) {
        callback(err);
      });
    } else {
      var reader = new FileReader();
      reader.onload = function (event) {
        callback(null, morpheus.Dataset.fromJSON(JSON.parse(event.target.result)));
      };
      reader.onerror = function (event) {
        callback(event);
      };
      reader.readAsText(fileOrUrl);
    }

  },
};

morpheus.MafFileReader = function () {
  this.geneFilter = null;
};
/**
 *
 * @param options.dataset
 * @param options.fields
 */
morpheus.MafFileReader.summarizeMutations = function (options) {
  var dataset = options.dataset;
  var fields = options.fields;
  var count = fields.length;
  var vector = dataset.getRowMetadata().add('mutation_summary');
  vector.getProperties().set(
    morpheus.VectorKeys.FIELDS, fields);
  vector.getProperties().set(morpheus.VectorKeys.DATA_TYPE, '[number]');

  // computing dynamically screws things up b/c summary is computed for other data types (e.g. CN)
  for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
    var bins = new Int32Array(count); // 1-count
    for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
      var value = dataset.getValue(i, j);
      if (value > 0) {
        bins[value - 1]++;
      }
    }
    vector.setValue(i, bins);
  }
};

morpheus.MafFileReader.getField = function (fieldNames, headerToIndex) {
  var name;
  var index;

  for (var i = 0; i < fieldNames.length; i++) {
    name = fieldNames[i];

    var lc = name.toLowerCase();
    index = headerToIndex[lc];

    if (index !== undefined) {
      break;
    }
  }

  if (index !== undefined) {
    return {
      name: name,
      index: index
    };
  }
};

morpheus.MafFileReader.VARIANT_MAP = new morpheus.Map();
// silent
morpheus.MafFileReader.VARIANT_MAP.set('Silent', 1);
// in-frame indel
morpheus.MafFileReader.VARIANT_MAP.set('In_Frame_Del', 2);
morpheus.MafFileReader.VARIANT_MAP.set('In_Frame_Ins', 2);
// other
morpheus.MafFileReader.VARIANT_MAP.set('Translation_Start_Site', 3);
morpheus.MafFileReader.VARIANT_MAP.set('Nonstop_Mutation', 3);
morpheus.MafFileReader.VARIANT_MAP.set('3\'UTR', 3);
morpheus.MafFileReader.VARIANT_MAP.set('3\'Flank', 3);
morpheus.MafFileReader.VARIANT_MAP.set('5\'UTR', 3);
morpheus.MafFileReader.VARIANT_MAP.set('5\'Flank', 3);
morpheus.MafFileReader.VARIANT_MAP.set('IGR', 3);
morpheus.MafFileReader.VARIANT_MAP.set('Intron', 3);
morpheus.MafFileReader.VARIANT_MAP.set('RNA', 3);
morpheus.MafFileReader.VARIANT_MAP.set('Targeted_Region', 3);
morpheus.MafFileReader.VARIANT_MAP.set('Unknown', 3);
// mis-sense
morpheus.MafFileReader.VARIANT_MAP.set('Missense_Mutation', 4);
// splice site
morpheus.MafFileReader.VARIANT_MAP.set('Splice_Site', 5);
// frame shift indel
morpheus.MafFileReader.VARIANT_MAP.set('Frame_Shift_Del', 6);
morpheus.MafFileReader.VARIANT_MAP.set('Frame_Shift_Ins', 6);
// non-sense
morpheus.MafFileReader.VARIANT_MAP.set('Nonsense_Mutation', 7);

morpheus.MafFileReader.FIELD_NAMES = ['Synonymous', 'In Frame Indel', 'Other Non-Synonymous',
  'Missense', 'Splice Site', 'Frame Shift', 'Nonsense'];

morpheus.MafFileReader.prototype = {
  setGeneFilter: function (geneFilter) {
    this.geneFilter = geneFilter;
  },
  getFormatName: function () {
    return 'maf';
  },
  _getGeneLevelDataset: function (datasetName, reader) {
    var _this = this;
    var tab = /\t/;
    var header = reader.readLine().split(tab);
    var headerToIndex = {};
    for (var i = 0, length = header.length; i < length; i++) {
      headerToIndex[header[i].toLowerCase()] = i;
    }
    // TODO six classes of base substitution—C>A, C>G, C>T, T>A, T>C, T>G
    // (all substitutions are referred to by the pyrimidine of the mutated
    // Watson–Crick base pair)
    // var fields = ['Hugo_Symbol', 'Chromosome', 'Start_position',
    //   'Reference_Allele', 'Tumor_Seq_Allele2',
    //   'Variant_Classification', 'Protein_Change', 'Protein_Change', 'ccf_hat',
    //   'tumor_f', 'i_tumor_f', 'Tumor_Sample_Barcode', 'tumor_name',
    //   'Tumor_Sample_UUID', 'encoding'];
    //
    var sampleField = morpheus.MafFileReader.getField([
        'Tumor_Sample_Barcode', 'tumor_name', 'Tumor_Sample_UUID'],
      headerToIndex);
    var encodingField = morpheus.MafFileReader.getField([
        'encoding'],
      headerToIndex); // gives a numeric value for string
    if (sampleField == null) {
      throw new Error('Sample id column not found.');
    }
    var encodingColumnIndex = encodingField == null ? -1 : encodingField.index;
    var sampleColumnName = sampleField.name;
    var sampleIdColumnIndex = sampleField.index;
    var tumorFractionField = morpheus.MafFileReader.getField(['ccf_hat',
      'tumor_f', 'i_tumor_f'], headerToIndex);
    var ccfColumnName;
    var ccfColumnIndex;
    if (tumorFractionField !== undefined) {
      ccfColumnName = tumorFractionField.name;
      ccfColumnIndex = tumorFractionField.index;
    }
    var chromosomeColumn = headerToIndex['Chromosome'.toLowerCase()];
    var startPositionColumn = headerToIndex['Start_position'
      .toLowerCase()];
    var refAlleleColumn = headerToIndex['Reference_Allele'.toLowerCase()];
    var tumorAllelColumn = headerToIndex['Tumor_Seq_Allele2'
      .toLowerCase()];

    var proteinChangeColumn = headerToIndex['Protein_Change'.toLowerCase()];
    if (proteinChangeColumn == null) {
      proteinChangeColumn = headerToIndex['Protein'.toLowerCase()];
    }

    var geneSymbolColumn = headerToIndex['Hugo_Symbol'.toLowerCase()];
    if (geneSymbolColumn == null) {
      geneSymbolColumn = headerToIndex['gene'];
    }
    if (geneSymbolColumn == null) {
      throw new Error('Gene symbol column not found.');
    }
    var variantColumnIndex = headerToIndex['Variant_Classification'
      .toLowerCase()];
    if (variantColumnIndex == null) {
      variantColumnIndex = headerToIndex['variant'
        .toLowerCase()];
    }
    if (variantColumnIndex == null) {
      throw new Error('Variant_Classification not found');
    }
    // keep fields that are in file only

    var geneSymbolToIndex = new morpheus.Map();
    var sampleIdToIndex = new morpheus.Map();
    var variantMatrix = [];
    var ccfMatrix = [];
    var s;
    var customNumberToValueMap = new morpheus.Map();

    var hasMutationInfo = chromosomeColumn !== undefined && startPositionColumn !== undefined && refAlleleColumn !== undefined && tumorAllelColumn !== undefined;
    while ((s = reader.readLine()) !== null) {
      var tokens = s.split(tab);
      var sample = String(tokens[sampleIdColumnIndex]);
      var columnIndex = sampleIdToIndex.get(sample);
      if (columnIndex === undefined) {
        columnIndex = sampleIdToIndex.size();
        sampleIdToIndex.set(sample, columnIndex);
      }
      var gene = String(tokens[geneSymbolColumn]);
      if (gene === 'Unknown') {
        continue;
      }
      if (this.geneFilter == null
        || this.geneFilter.has(tokens[geneSymbolColumn])) {
        var rowIndex = geneSymbolToIndex.get(gene);
        if (rowIndex === undefined) {
          rowIndex = geneSymbolToIndex.size();
          geneSymbolToIndex.set(gene, rowIndex);
        }
        var value = String(tokens[variantColumnIndex]);
        var variantCode;
        if (encodingColumnIndex === -1) {
          variantCode = morpheus.MafFileReader.VARIANT_MAP.get(value);
          if (variantCode === undefined) {
            variantCode = 3;
          }
        } else {
          variantCode = parseInt(tokens[encodingColumnIndex]);
          customNumberToValueMap.set(variantCode, value);
        }

        var variantObject = {};
        var Protein_Change = tokens[proteinChangeColumn];
        if (Protein_Change) {
          variantObject.Protein = String(Protein_Change);
        }
        variantObject.__v = variantCode;
        variantObject.Variant = value;
        if (hasMutationInfo) {
          variantObject.Mutation = String(tokens[chromosomeColumn]) + ':'
            + String(tokens[startPositionColumn]) + ' '
            + String(tokens[refAlleleColumn]) + ' > '
            + String(tokens[tumorAllelColumn]);
        }
        var wrappedVariant = morpheus.Util.wrapNumber(variantCode,
          variantObject);
        var variantRow = variantMatrix[rowIndex];
        if (variantRow === undefined) {
          variantRow = [];
          variantMatrix[rowIndex] = variantRow;
        }
        var ccf = -1;
        var priorCcf = -1;
        if (ccfColumnIndex !== undefined) {
          var ccfRow = ccfMatrix[rowIndex];
          if (ccfRow === undefined) {
            ccfRow = [];
            ccfMatrix[rowIndex] = ccfRow;
          }
          ccf = parseFloat(tokens[ccfColumnIndex]);
          priorCcf = ccfRow[columnIndex] || -1;
        }
        var priorValue = variantRow[columnIndex] || -1;
        if (variantCode > priorValue) { // take most severe mutation
          variantRow[columnIndex] = wrappedVariant;
          if (ccfColumnIndex !== undefined) {
            ccfRow[columnIndex] = ccf;
          }
        } else if (variantCode === priorValue && ccf > priorCcf) {
          variantRow[columnIndex] = wrappedVariant;
          ccfRow[columnIndex] = ccf;
        }
      }
    }
    var dataset = new morpheus.Dataset({
      name: datasetName,
      array: variantMatrix,
      dataType: 'Number',
      rows: geneSymbolToIndex.size(),
      columns: sampleIdToIndex.size()
    });
    var columnIds = dataset.getColumnMetadata().add('id');
    sampleIdToIndex.forEach(function (index, id) {
      columnIds.setValue(index, id);
    });
    var rowIds = dataset.getRowMetadata().add('id');
    geneSymbolToIndex.forEach(function (index, id) {
      rowIds.setValue(index, id);
    });
    for (var i = 0, nrows = dataset.getRowCount(), ncols = dataset
      .getColumnCount(); i < nrows; i++) {
      for (var j = 0; j < ncols; j++) {
        if (variantMatrix[i][j] === undefined) {
          variantMatrix[i][j] = 0;
        }
      }
    }
    if (ccfColumnIndex !== undefined) {
      dataset.addSeries({
        dataType: 'Float32',
        name: 'allelic_fraction',
        array: ccfMatrix
      });
    }
    if (this.geneFilter) {
      var orderVector = dataset.getRowMetadata().add('order');
      for (var i = 0, size = orderVector.size(); i < size; i++) {
        var gene = rowIds.getValue(i);
        var order = this.geneFilter.get(gene);
        orderVector.setValue(i, order);
      }
      var project = new morpheus.Project(dataset);
      project.setRowSortKeys([new morpheus.SortKey('order',
        morpheus.SortKey.SortOrder.ASCENDING)], true); // sort
      // collapsed
      // dataset
      var tmp = project.getSortedFilteredDataset();
      project = new morpheus.Project(tmp);
      var columnIndices = morpheus.Util.seq(tmp.getColumnCount());
      columnIndices
        .sort(function (a, b) {
          for (var i = 0, nrows = tmp.getRowCount(); i < nrows; i++) {
            for (var seriesIndex = 0, nseries = tmp
              .getSeriesCount(); seriesIndex < nseries; seriesIndex++) {
              var f1 = tmp.getValue(i, a, seriesIndex);
              if (isNaN(f1)) {
                f1 = Number.NEGATIVE_INFINITY;
              }
              f1 = f1.valueOf();
              var f2 = tmp.getValue(i, b, seriesIndex);
              if (isNaN(f2)) {
                f2 = Number.NEGATIVE_INFINITY;
              }
              f2 = f2.valueOf();
              var returnVal = (f1 === f2 ? 0 : (f1 < f2 ? 1
                : -1));
              if (returnVal !== 0) {
                return returnVal;
              }
            }
          }
          return 0;
        });
      dataset = new morpheus.SlicedDatasetView(dataset, null,
        columnIndices);
    }

    var fieldNames = morpheus.MafFileReader.FIELD_NAMES;
    if (customNumberToValueMap.size() > 0) {
      var pairs = [];
      customNumberToValueMap.forEach(function (value, key) {
        pairs.push({
          key: key,
          value: value
        });
      });
      pairs.sort(function (a, b) {
        return (a.key === b.key ? 0 : (a.key < b.key ? -1 : 1));
      });
      fieldNames = pairs.map(function (p) {
        return p.value;
      });
    }
    var numUniqueValues = fieldNames.length;
    morpheus.MafFileReader.summarizeMutations({
      dataset: dataset,
      fields: fieldNames
    });
    morpheus.MafFileReader
      .summarizeMutations({
        dataset: new morpheus.TransposedDatasetView(dataset),
        fields: fieldNames
      });

    var mutationSummarySelectionVector = dataset.getColumnMetadata().add('mutation_summary_selection');
    mutationSummarySelectionVector.getProperties().set(
      morpheus.VectorKeys.FIELDS,
      fieldNames);
    mutationSummarySelectionVector.getProperties().set(morpheus.VectorKeys.DATA_TYPE, '[number]');
    mutationSummarySelectionVector.getProperties().set(morpheus.VectorKeys.RECOMPUTE_FUNCTION_SELECTION, true);
    var datasetName = dataset.getName();
    mutationSummarySelectionVector.getProperties().set(morpheus.VectorKeys.FUNCTION, {
      binSize: 1,
      domain: [1, 8],
      cumulative: false
    });
    // mutationSummarySelectionVector.getProperties().set(morpheus.VectorKeys.FUNCTION, function (view, selectedDataset, columnIndex) {
    //   var sourceVector = selectedDataset.getRowMetadata().getByName('Source');
    //   var bins = new Int32Array(numUniqueValues); // 1-7
    //   for (var i = 0, nrows = selectedDataset.getRowCount(); i < nrows; i++) {
    //     var source = sourceVector.getValue(i);
    //     if (source == null || source === datasetName) {
    //       var value = selectedDataset.getValue(i, columnIndex);
    //       if (value > 0) {
    //         bins[value - 1]++;
    //       }
    //     }
    //   }
    //   return bins;
    // });

    return dataset;
  },
  read: function (fileOrUrl, callback) {
    var _this = this;
    var name = morpheus.Util.getBaseFileName(morpheus.Util
      .getFileName(fileOrUrl));
    morpheus.ArrayBufferReader.getArrayBuffer(fileOrUrl, function (err, arrayBuffer) {
      if (err) {
        callback(err);
      } else {
        try {
          callback(null, _this._getGeneLevelDataset(name,
            new morpheus.ArrayBufferReader(new Uint8Array(
              arrayBuffer))));
        }
        catch (err) {
          callback(err);
        }
      }
    });

  }
};

morpheus.SegTabReader = function () {
  this.regions = null;
};
morpheus.SegTabReader.binByRegion = function (dataset, regions) {

  var chromosomeVector = dataset.getRowMetadata().getByName('Chromosome');
  var startVector = dataset.getRowMetadata().getByName('Start_bp');
  var endVector = dataset.getRowMetadata().getByName('End_bp');

  var collapsedDataset = new morpheus.Dataset({
    name: dataset.getName(),
    rows: regions.length,
    columns: dataset.getColumnCount(),
    dataType: 'Float32'
  });
  morpheus.DatasetUtil.fill(collapsedDataset, NaN);
  var regionIdVector = collapsedDataset.getRowMetadata().add('id');
  var newChromosomeVector = collapsedDataset.getRowMetadata().add(
    'chromosome');
  var newStartVector = collapsedDataset.getRowMetadata().add('start');
  var newEndVector = collapsedDataset.getRowMetadata().add('end');
  var nsegmentsVector = collapsedDataset.getRowMetadata().add('nsegments');
  var nseries = dataset.getSeriesCount();

  for (var series = 1; series < nseries; series++) {
    collapsedDataset.addSeries({
      name: dataset.getName(series),
      dataType: 'Float32'
    });

  }

  var summarizeFunction = morpheus.Mean;
  collapsedDataset.setColumnMetadata(dataset.getColumnMetadata());
  for (var regionIndex = 0; regionIndex < regions.length; regionIndex++) {
    var region = regions[regionIndex];
    var rowIndices = [];
    for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
      var chromosome = chromosomeVector.getValue(i);
      var start = startVector.getValue(i);
      var end = endVector.getValue(i);
      if (region.chromosome == chromosome && start >= region.start
        && end <= region.end) {
        rowIndices.push(i);
      }
    }
    if (rowIndices.length > 0) {
      var slice = morpheus.DatasetUtil.slicedView(dataset, rowIndices,
        null);
      var columnView = new morpheus.DatasetColumnView(slice);
      for (var j = 0; j < dataset.getColumnCount(); j++) {
        columnView.setIndex(j);
        for (var series = 0; series < nseries; series++) {
          columnView.setSeriesIndex(series);
          collapsedDataset.setValue(regionIndex, j,
            summarizeFunction(columnView), series);
        }

      }
    }
    nsegmentsVector.setValue(regionIndex, rowIndices.length);
    regionIdVector.setValue(regionIndex, region.id);
    newChromosomeVector.setValue(regionIndex, region.chromosome);
    newStartVector.setValue(regionIndex, region.start);
    newEndVector.setValue(regionIndex, region.end);
  }
  return collapsedDataset;
};

morpheus.SegTabReader.prototype = {
  getFormatName: function () {
    return 'seg';
  },
  setRegions: function (regions) {
    this.regions = regions;
  },
  _read: function (datasetName, reader) {
    var tab = /\t/;
    var header = reader.readLine().split(tab);
    var fieldNameToIndex = {};
    for (var i = 0, length = header.length; i < length; i++) {
      var name = header[i].toLowerCase();
      fieldNameToIndex[name] = i;
    }

    var sampleField = morpheus.MafFileReader.getField(['pair_id',
      'Tumor_Sample_Barcode', 'tumor_name', 'Tumor_Sample_UUID',
      'Sample'], fieldNameToIndex);
    var sampleColumnName = sampleField.name;
    var sampleIdColumnIndex = sampleField.index;
    var tumorFractionField = morpheus.MafFileReader.getField(['ccf_hat',
      'tumor_f', 'i_tumor_f'], fieldNameToIndex);
    var ccfColumnName;
    var ccfColumnIndex;
    if (tumorFractionField !== undefined) {
      ccfColumnName = tumorFractionField.name;
      ccfColumnIndex = tumorFractionField.index;
    }
    var chromosomeColumn = fieldNameToIndex.Chromosome;
    var startPositionColumn = morpheus.MafFileReader.getField(['Start_bp',
      'Start'], fieldNameToIndex).index;
    var endPositionColumn = morpheus.MafFileReader.getField(['End_bp',
      'End'], fieldNameToIndex, {
      remove: false,
      lc: true
    }).index;
    var valueField = morpheus.MafFileReader.getField(['tau',
      'Segment_Mean']).index;
    var s;
    var matrix = [];
    var ccfMatrix = [];
    var sampleIdToIndex = new morpheus.Map();
    var chromosomeStartEndToIndex = new morpheus.Map();
    while ((s = reader.readLine()) !== null) {
      if (s === '') {
        continue;
      }
      var tokens = s.split(tab);
      var sample = String(tokens[sampleIdColumnIndex]);
      var columnIndex = sampleIdToIndex.get(sample);
      if (columnIndex === undefined) {
        columnIndex = sampleIdToIndex.size();
        sampleIdToIndex.set(sample, columnIndex);
      }
      var rowId = new morpheus.Identifier([
        String(tokens[chromosomeColumn]),
        String(tokens[startPositionColumn]),
        String(tokens[endPositionColumn])]);

      var rowIndex = chromosomeStartEndToIndex.get(rowId);
      if (rowIndex === undefined) {
        rowIndex = chromosomeStartEndToIndex.size();
        chromosomeStartEndToIndex.set(rowId, rowIndex);
      }
      var value = parseFloat(String(tokens[valueField]));
      value = isNaN(value) ? value : (morpheus.Log2(value) - 1);
      var matrixRow = matrix[rowIndex];
      if (matrixRow === undefined) {
        matrixRow = [];
        matrix[rowIndex] = matrixRow;
        if (ccfColumnIndex !== undefined) {
          ccfMatrix[rowIndex] = [];
        }
      }
      matrixRow[columnIndex] = value;
      if (ccfColumnIndex !== undefined) {
        ccfMatrix[rowIndex][columnIndex] = parseFloat(tokens[ccfColumnIndex]);
      }
    }
    var dataset = new morpheus.Dataset({
      name: datasetName,
      array: matrix,
      dataType: 'number',
      rows: chromosomeStartEndToIndex.size(),
      columns: sampleIdToIndex.size()
    });

    var columnIds = dataset.getColumnMetadata().add('id');
    sampleIdToIndex.forEach(function (index, id) {
      columnIds.setValue(index, id);
    });

    var chromosomeVector = dataset.getRowMetadata().add('Chromosome');
    var startVector = dataset.getRowMetadata().add('Start_bp');
    var endVector = dataset.getRowMetadata().add('End_bp');
    chromosomeStartEndToIndex.forEach(function (index, id) {
      chromosomeVector.setValue(index, id.getArray()[0]);
      startVector.setValue(index, id.getArray()[1]);
      endVector.setValue(index, id.getArray()[2]);
    });

    if (ccfColumnIndex !== undefined) {
      dataset.addSeries({
        dataType: 'number',
        name: 'ccf',
        array: ccfMatrix
      });
    }

    if (this.regions != null && this.regions.length > 0) {
      dataset = morpheus.SegTabReader.binByRegion(dataset, this.regions);
    }
    return dataset;
  },
  read: function (fileOrUrl, callback) {
    var _this = this;
    var name = morpheus.Util.getBaseFileName(morpheus.Util
      .getFileName(fileOrUrl));
    morpheus.ArrayBufferReader.getArrayBuffer(fileOrUrl, function (err,
                                                                   arrayBuffer) {
      if (err) {
        callback(err);
      } else {
        // try {
        callback(null, _this._read(name, new morpheus.ArrayBufferReader(
          new Uint8Array(arrayBuffer))));
        // } catch (err) {
        // callback(err);
        // }
      }
    });

  }
};

morpheus.TcgaUtil = function () {

};

morpheus.TcgaUtil.DISEASE_STUDIES = {
  'ACC': 'Adrenocortical carcinoma',
  'BLCA': 'Bladder Urothelial Carcinoma',
  'BRCA': 'Breast invasive carcinoma',
  'CESC': 'Cervical squamous cell carcinoma and endocervical adenocarcinoma',
  'CHOL': 'Cholangiocarcinoma',
//	'CNTL': 'Controls',
  'COAD': 'Colon adenocarcinoma',
  'COADREAD': 'Colonrectal adenocarcinoma',
  'DLBC': 'Lymphoid Neoplasm Diffuse Large B-cell Lymphoma',
  'ESCA': 'Esophageal carcinoma ',
//	'FPPP': 'FFPE Pilot Phase II',
  'GBM': 'Glioblastoma multiforme',
  'GBMLGG': 'Glioma',
  'HNSC': 'Head and Neck squamous cell carcinoma',
  'KICH': 'Kidney Chromophobe',
  'KIPAN': 'Pan-Kidney Cohort',
  'KIRC': 'Kidney renal clear cell carcinoma',
  'KIRP': 'Kidney renal papillary cell carcinoma',
  'LAML': 'Acute Myeloid Leukemia',
  'LCML': 'Chronic Myelogenous Leukemia',
  'LGG': 'Brain Lower Grade Glioma',
  'LIHC': 'Liver hepatocellular carcinoma',
  'LUAD': 'Lung adenocarcinoma',
  'LUSC': 'Lung squamous cell carcinoma',
  'MESO': 'Mesothelioma',
//	'MISC': 'Miscellaneous',
  'OV': 'Ovarian serous cystadenocarcinoma',
  'PAAD': 'Pancreatic adenocarcinoma',
  'PCPG': 'Pheochromocytoma and Paraganglioma',
  'PRAD': 'Prostate adenocarcinoma',
  'READ': 'Rectum adenocarcinoma',
  'SARC': 'Sarcoma',
  'SKCM': 'Skin Cutaneous Melanoma',
  'STAD': 'Stomach adenocarcinoma',
  'STES': 'Stomach and Esophageal Carcinoma',
  'TGCT': 'Testicular Germ Cell Tumors',
  'THCA': 'Thyroid carcinoma',
  'THYM': 'Thymoma',
  'UCEC': 'Uterine Corpus Endometrial Carcinoma',
  'UCS': 'Uterine Carcinosarcoma',
  'UVM': 'Uveal Melanoma'
};

morpheus.TcgaUtil.SAMPLE_TYPES = {
  '01': 'Primary solid Tumor',
  '02': 'Recurrent Solid Tumor',
  '03': 'Primary Blood Derived Cancer - Peripheral Blood',
  '04': 'Recurrent Blood Derived Cancer - Bone Marrow',
  '05': 'Additional - New Primary',
  '06': 'Metastatic',
  '07': 'Additional Metastatic',
  '08': 'Human Tumor Original Cells',
  '09': 'Primary Blood Derived Cancer - Bone Marrow',
  '10': 'Blood Derived Normal',
  '11': 'Solid Tissue Normal',
  '12': 'Buccal Cell Normal',
  '13': 'EBV Immortalized Normal',
  '14': 'Bone Marrow Normal',
  '20': 'Control Analyte',
  '40': 'Recurrent Blood Derived Cancer - Peripheral Blood',
  '50': 'Cell Lines',
  '60': 'Primary Xenograft Tissue',
  '61': 'Cell Line Derived Xenograft Tissue'
};

morpheus.TcgaUtil.barcode = function (s) {
  var tokens = s.split('-');
  var id = tokens[2];
  var sampleType;
  // e.g. TCGA-AC-A23H-01A-11D-A159-09
  if (tokens.length > 3) {
    sampleType = tokens[3];
    if (sampleType.length > 2) {
      sampleType = sampleType.substring(0, 2);
    }
    sampleType = morpheus.TcgaUtil.SAMPLE_TYPES[sampleType];
  } else {
    sampleType = morpheus.TcgaUtil.SAMPLE_TYPES['01'];
  }
  return {
    id: id.toLowerCase(),
    sampleType: sampleType
  };
};

morpheus.TcgaUtil.setIdAndSampleType = function (dataset) {
  var idVector = dataset.getColumnMetadata().get(0);
  var participantId = dataset.getColumnMetadata().add('participant_id');
  var sampleType = dataset.getColumnMetadata().add('sample_type');
  for (var i = 0, size = idVector.size(); i < size; i++) {
    var barcode = morpheus.TcgaUtil.barcode(idVector.getValue(i));
    idVector.setValue(i, barcode.id + '-' + barcode.sampleType);
    sampleType.setValue(i, barcode.sampleType);
    participantId.setValue(i, barcode.id);
  }
};

morpheus.TcgaUtil.getDataset = function (options) {
  var promises = [];
  var datasets = [];
  var returnDeferred = $.Deferred();

  if (options.mrna) {
    // id + type
    var mrna = $.Deferred();
    promises.push(mrna);
    new morpheus.TxtReader().read(options.mrna, function (err, dataset) {
      if (err) {
        console.log('Error reading file:' + err);
      } else {
        datasets.push(dataset);
        morpheus.TcgaUtil.setIdAndSampleType(dataset);
      }
      mrna.resolve();
    });
  }
  var sigGenesLines;
  if (options.mutation) {
    var mutation = $.Deferred();
    promises.push(mutation);
    new morpheus.MafFileReader().read(options.mutation, function (err, dataset) {
      if (err) {
        console.log('Error reading file:' + err);
      } else {
        datasets.push(dataset);
        morpheus.TcgaUtil.setIdAndSampleType(dataset);
      }
      mutation.resolve();
    });
    var sigGenesAnnotation = morpheus.Util.readLines(options.sigGenes);
    sigGenesAnnotation.done(function (lines) {
      sigGenesLines = lines;
    });
    promises.push(sigGenesAnnotation);
  }
  if (options.gistic) {
    var gistic = $.Deferred();
    promises.push(gistic);
    new morpheus.GisticReader().read(options.gistic,
      function (err, dataset) {
        if (err) {
          console.log('Error reading file:' + err);
        } else {
          datasets.push(dataset);
          morpheus.TcgaUtil.setIdAndSampleType(dataset);
        }
        gistic.resolve();
      });

  }
  if (options.gisticGene) {
    var gisticGene = $.Deferred();
    promises.push(gisticGene);

    new morpheus.TxtReader({
      dataColumnStart: 3

    }).read(options.gisticGene, function (err, dataset) {
      if (err) {
        console.log('Error reading file:' + err);
      } else {
        datasets.push(dataset);
        morpheus.TcgaUtil.setIdAndSampleType(dataset);
      }
      gisticGene.resolve();
    });

  }
  if (options.seg) {
    var seg = $.Deferred();
    promises.push(seg);
    new morpheus.SegTabReader().read(options.seg, function (err, dataset) {
      if (err) {
        console.log('Error reading file:' + err);
      } else {
        datasets.push(dataset);
        morpheus.TcgaUtil.setIdAndSampleType(dataset);
      }
      seg.resolve();
    });
  }
  if (options.rppa) {
    // id + type
    var rppa = $.Deferred();
    promises.push(rppa);

    new morpheus.TxtReader().read(options.rppa, function (err, dataset) {
      if (err) {
        console.log('Error reading file:' + err);
      } else {
        datasets.push(dataset);
        morpheus.TcgaUtil.setIdAndSampleType(dataset);
      }

      rppa.resolve();
    });

  }
  if (options.methylation) {
    // id + type
    var methylation = $.Deferred();
    promises.push(methylation);
    new morpheus.TxtReader({}).read(options.methylation, function (err,
                                                                   dataset) {
      if (err) {
        console.log('Error reading file:' + err);
      } else {
        datasets.push(dataset);
        morpheus.TcgaUtil.setIdAndSampleType(dataset);
      }
      methylation.resolve();
    });
  }

  var mrnaClustPromise = morpheus.Util.readLines(options.mrnaClust);
  promises.push(mrnaClustPromise);
  var sampleIdToClusterId;
  mrnaClustPromise.done(function (lines) {
    // SampleName cluster silhouetteValue
    // SampleName cluster silhouetteValue
    // TCGA-OR-A5J1-01 1 0.00648776228925048
    sampleIdToClusterId = new morpheus.Map();
    var lineNumber = 0;
    while (lines[lineNumber].indexOf('SampleName') !== -1) {
      lineNumber++;
    }
    var tab = /\t/;
    for (; lineNumber < lines.length; lineNumber++) {
      var tokens = lines[lineNumber].split(tab);
      var barcode = morpheus.TcgaUtil.barcode(tokens[0]);
      sampleIdToClusterId.set(barcode.id + '-' + barcode.sampleType, tokens[1]);
    }
  });
  var annotationCallbacks = [];
  var annotationDef = null;
  if (options.columnAnnotations) {
    annotationDef = morpheus.DatasetUtil.annotate({
      annotations: options.columnAnnotations,
      isColumns: true
    });
    promises.push(annotationDef);
    annotationDef.done(function (array) {
      annotationCallbacks = array;
    });
  }
  $.when.apply($, promises).then(
    function () {
      var datasetToReturn = null;
      if (datasets.length === 1) {
        var sourceName = datasets[0].getName();
        var sourceVector = datasets[0].getRowMetadata().add(
          'Source');
        for (var i = 0; i < sourceVector.size(); i++) {
          sourceVector.setValue(i, sourceName);
        }
        datasetToReturn = datasets[0];

      } else {
        var maxIndex = 0;
        var maxColumns = datasets[0].getColumnCount();
        // use dataset with most columns as the reference or
        // mutation data
        for (var i = 1; i < datasets.length; i++) {
          if (datasets[i].getColumnCount() > maxColumns) {
            maxColumns = datasets[i].getColumnCount();
            maxIndex = i;
          }
          if (datasets[i].getName() === 'mutations_merged.maf') {
            maxColumns = Number.MAX_VALUE;
            maxIndex = i;
          }
        }
        var datasetIndices = [];
        datasetIndices.push(maxIndex);
        for (var i = 0; i < datasets.length; i++) {
          if (i !== maxIndex) {
            datasetIndices.push(i);
          }
        }

        var joined = new morpheus.JoinedDataset(
          datasets[datasetIndices[0]],
          datasets[datasetIndices[1]], 'id', 'id');
        for (var i = 2; i < datasetIndices.length; i++) {
          joined = new morpheus.JoinedDataset(joined,
            datasets[datasetIndices[i]], 'id', 'id');
        }
        datasetToReturn = joined;
      }

      var clusterIdVector = datasetToReturn.getColumnMetadata().add(
        'mRNAseq_cluster');
      var idVector = datasetToReturn.getColumnMetadata().getByName(
        'id');
      for (var j = 0, size = idVector.size(); j < size; j++) {
        clusterIdVector.setValue(j, sampleIdToClusterId
          .get(idVector.getValue(j)));
      }
      // view in space of mutation sample ids only
      if (options.mutation) {
        var sourceToIndices = morpheus.VectorUtil
          .createValueToIndicesMap(datasetToReturn
            .getRowMetadata().getByName('Source'));
        var mutationDataset = new morpheus.SlicedDatasetView(
          datasetToReturn, sourceToIndices
            .get('mutations_merged.maf'));
        new morpheus.OpenFileTool()
          .annotate(sigGenesLines, mutationDataset, false,
            null, 'id', 'gene', ['q']);
        var qVector = mutationDataset.getRowMetadata().getByName(
          'q');
        var qValueVector = mutationDataset.getRowMetadata()
          .getByName('q_value');
        if (qValueVector == null) {
          qValueVector = mutationDataset.getRowMetadata().add(
            'q_value');
        }
        for (var i = 0, size = qValueVector.size(); i < size; i++) {
          qValueVector.setValue(i, qVector.getValue(i));
        }

        mutationDataset.getRowMetadata().remove(
          morpheus.MetadataUtil.indexOf(mutationDataset
            .getRowMetadata(), 'q'));
      }
      if (annotationDef) {
        annotationCallbacks.forEach(function (f) {
          f(datasetToReturn);
        });
      }
      console.log("morpheus.TcgaUtil.setIdAndSampleType ::", datasetToReturn);
      morpheus.DatasetUtil.toESSessionPromise(datasetToReturn);
      returnDeferred.resolve(datasetToReturn);
    });
  return returnDeferred;
};

/**
 *
 * @param options.dataRowStart
 * @param options.dataColumnStart
 * @constructor
 */
morpheus.TxtReader = function (options) {
  if (options == null) {
    options = {};
  }
  this.options = options;
};
morpheus.TxtReader.prototype = {
  read: function (fileOrUrl, callback) {
    var _this = this;
    var name = morpheus.Util.getBaseFileName(morpheus.Util
      .getFileName(fileOrUrl));
    morpheus.ArrayBufferReader.getArrayBuffer(fileOrUrl, function (err,
                                                                   arrayBuffer) {
      if (err) {
        callback(err);
      } else {
        try {
          callback(null, _this._read(name,
            new morpheus.ArrayBufferReader(new Uint8Array(
              arrayBuffer))));
        }
        catch (x) {
          callback(x);
        }
      }
    });

  },
  _read: function (datasetName, reader) {
    var dataColumnStart = this.options.dataColumnStart;
    var dataRowStart = this.options.dataRowStart;
    if (dataRowStart == null) {
      dataRowStart = 1;
    }
    var tab = /\t/;
    var header = reader.readLine().trim().split(tab);
    if (dataRowStart > 1) {
      for (var i = 1; i < dataRowStart; i++) {
        reader.readLine(); // skip
      }
    }
    var testLine = null;
    if (dataColumnStart == null) { // try to figure out where data starts by finding 1st
      // numeric column
      testLine = reader.readLine().trim();
      var tokens = testLine.split(tab);
      for (var i = 1; i < tokens.length; i++) {
        var token = tokens[i];
        if (token === '' || token === 'NA' || token === 'NaN' || $.isNumeric(token)) {
          dataColumnStart = i;
          break;
        }
      }

      if (dataColumnStart == null) {
        dataColumnStart = 1;
      }
    }

    var ncols = header.length - dataColumnStart;
    var matrix = [];
    var s;
    var arrayOfRowArrays = [];
    for (var i = 0; i < dataColumnStart; i++) {
      arrayOfRowArrays.push([]);
    }
    if (testLine != null) {
      var array = new Float32Array(ncols);
      matrix.push(array);
      var tokens = testLine.split(tab);
      for (var j = 0; j < dataColumnStart; j++) {
        // row metadata
        arrayOfRowArrays[j].push(morpheus.Util.copyString(tokens[j]));
      }
      for (var j = dataColumnStart, k = 0; k < ncols; j++, k++) {
        var token = tokens[j];
        array[j - dataColumnStart] = parseFloat(token);
      }
    }
    while ((s = reader.readLine()) !== null) {
      s = s.trim();
      if (s !== '') {
        var array = new Float32Array(ncols);
        matrix.push(array);
        var tokens = s.split(tab);
        for (var j = 0; j < dataColumnStart; j++) {
          // row metadata
          arrayOfRowArrays[j].push(morpheus.Util.copyString(tokens[j]));
        }
        for (var j = dataColumnStart, k = 0; k < ncols; j++, k++) {
          var token = tokens[j];
          array[j - dataColumnStart] = parseFloat(token);
        }
      }
    }
    var dataset = new morpheus.Dataset({
      name: datasetName,
      rows: matrix.length,
      columns: ncols,
      array: matrix,
      dataType: 'Float32'
    });

    var columnIds = dataset.getColumnMetadata().add('id');
    for (var i = 0, j = dataColumnStart; i < ncols; i++, j++) {
      columnIds.setValue(i, morpheus.Util.copyString(header[j]));
    }
    var rowIdVector = dataset.getRowMetadata().add('id');
    rowIdVector.array = arrayOfRowArrays[0];
    // add additional row metadata
    for (var i = 1; i < dataColumnStart; i++) {
      var v = dataset.getRowMetadata().add(header[i]);
      v.array = arrayOfRowArrays[i];
    }

    return dataset;
  }
};

morpheus.XlsxDatasetReader = function () {
};
morpheus.XlsxDatasetReader.prototype = {
  read: function (fileOrUrl, callback) {
    var _this = this;
    var name = morpheus.Util.getBaseFileName(morpheus.Util
      .getFileName(fileOrUrl));
    morpheus.ArrayBufferReader.getArrayBuffer(fileOrUrl, function (err,
                                                                   arrayBuffer) {
      if (err) {
        callback(err);
      } else {
        try {
          var data = new Uint8Array(arrayBuffer);
          var arr = [];
          for (var i = 0; i != data.length; ++i) {
            arr[i] = String.fromCharCode(data[i]);
          }
          var bstr = arr.join('');
          _this._read(name, bstr, callback);
        }
        catch (x) {
          callback(x);
        }
      }
    });

  },

  _read: function (datasetName, bstr, callback) {
    morpheus.Util.xlsxTo2dArray({data: bstr}, function (err, lines) {
      var nrows = lines.length - 1;
      var header = lines[0];
      var ncols = header.length - 1;
      var dataset = new morpheus.Dataset({
        name: datasetName,
        rows: nrows,
        columns: ncols
      });
      var columnIds = dataset.getColumnMetadata().add('id');
      for (var j = 1; j <= ncols; j++) {
        columnIds.setValue(j - 1, header[j]);
      }
      var rowIds = dataset.getRowMetadata().add('id');
      for (var i = 1; i < lines.length; i++) {
        var tokens = lines[i];
        rowIds.setValue(i - 1, tokens[0]);
        for (var j = 1; j <= ncols; j++) {
          var token = tokens[j];
          var value = parseFloat(token);
          dataset.setValue(i - 1, j - 1, value);
        }
      }
      callback(null, dataset);
    });

  }
};

morpheus.VectorAdapter = function (v) {
  if (v == null) {
    throw 'vector is null';
  }
  this.v = v;
};
morpheus.VectorAdapter.prototype = {
  setValue: function (i, value) {
    this.v.setValue(i, value);
  },
  getValue: function (i) {
    return this.v.getValue(i);
  },
  getProperties: function () {
    return this.v.getProperties();
  },
  size: function () {
    return this.v.size();
  },
  getName: function () {
    return this.v.getName();
  },
  setName: function (name) {
    this.v.setName(name);
  }
};

/**
 *
 * Creates a new dataset with the specified dimensions. Subclasses must implement getValue and
 * setValue.
 * @param rows {number} The number of rows
 * @param columns {number} The number of columns
 * @implements {morpheus.DatasetInterface}
 * @constructor
 */
morpheus.AbstractDataset = function (rows, columns) {
  this.seriesNames = [];
  this.seriesArrays = [];
  this.seriesDataTypes = [];
  this.rows = rows;
  this.columns = columns;
  this.rowMetadataModel = new morpheus.MetadataModel(rows);
  this.columnMetadataModel = new morpheus.MetadataModel(columns);
};
morpheus.AbstractDataset.prototype = {
  /**
   * @ignore
   * @param metadata
   */
  setRowMetadata: function (metadata) {
    this.rowMetadataModel = metadata;
  },
  /**
   * @ignore
   * @param metadata
   */
  setColumnMetadata: function (metadata) {
    this.columnMetadataModel = metadata;
  },
  /**
   * Returns the name for the given series. Series can be used to store
   * standard error of data points for example.
   *
   * @param seriesIndex
   *            the series
   * @return the series name
   */
  getName: function (seriesIndex) {
    return this.seriesNames[seriesIndex || 0];
  },
  /**
   * Sets the name for the given series. Series can be used to store standard
   * error of data points for example.
   *
   * @param seriesIndex
   *            the series *
   * @param name
   *            the series name
   */
  setName: function (seriesIndex, name) {
    this.seriesNames[seriesIndex || 0] = name;
  },
  /**
   * Gets the row metadata for this dataset.
   *
   * @return the row metadata
   */
  getRowMetadata: function () {
    return this.rowMetadataModel;
  },
  /**
   * Gets the column metadata for this dataset.
   *
   * @return The column metadata
   */
  getColumnMetadata: function () {
    return this.columnMetadataModel;
  },
  /**
   * Returns the number of rows in the dataset.
   *
   * @return the number of rows
   */
  getRowCount: function () {
    return this.rows;
  },
  /**
   * Returns the number of columns in the dataset.
   *
   * @return the number of columns
   */
  getColumnCount: function () {
    return this.columns;
  },
  /**
   * Returns the value at the given row and column for the given series.
   * Series can be used to store standard error of data points for example.
   *
   * @param rowIndex
   *            the row index
   * @param columnIndex
   *            the column index
   * @param seriesIndex
   *            the series index
   * @return the value
   */
  getValue: function (rowIndex, columnIndex, seriesIndex) {
    // not implemented
  },
  /**
   * Sets the value at the given row and column for the given series.
   *
   * @param rowIndex
   *            the row index
   *
   * @param columnIndex
   *            the column index
   * @param value
   *            the value
   * @param seriesIndex
   *            the series index
   *
   */
  setValue: function (rowIndex, columnIndex, value, seriesIndex) {
    // not implemented
  },
  /**
   * Adds the specified series.
   *
   * @param options
   * @param options.name
   *            the series name
   * @param options.dataType
   *            the series data type (e.g. object, Float32, Int8)
   * @return the series index
   */
  addSeries: function (options) {
    // not implemented
  },
  /**
   * Removes the specified series.
   *
   * @param seriesIndex The series index.
   */
  removeSeries: function (seriesIndex) {
    this.seriesArrays.splice(seriesIndex, 1);
    this.seriesNames.splice(seriesIndex, 1);
    this.seriesDataTypes.splice(seriesIndex, 1);
  },
  /**
   * Returns the number of matrix series. Series can be used to store standard
   * error of data points for example.
   *
   * @return the number of series
   */
  getSeriesCount: function () {
    return this.seriesArrays.length;
  },
  /**
   * Returns the data type at the specified series index.
   *
   * @param seriesIndex
   *            the series index
   * @return the series data type (e.g. Number, Float32, Int8)
   */
  getDataType: function (seriesIndex) {
    return this.seriesDataTypes[seriesIndex || 0];
  },
  toString: function () {
    return this.getName();
  }
};

/**
 *
 * Creates a new vector with the given name and size. Subclasses must implement getValue
 *
 * @param {string} name
 *            the vector name
 * @param size {number}
 *            the number of elements in this vector
 * @implements {morpheus.VectorInterface}
 * @constructor
 */
morpheus.AbstractVector = function (name, size) {
  this.name = name;
  this.n = size;
  this.properties = new morpheus.Map();
};

morpheus.AbstractVector.prototype = {
  getValue: function (index) {
    throw new Error('Not implemented');
  },
  getProperties: function () {
    return this.properties;
  },
  size: function () {
    return this.n;
  },
  getName: function () {
    return this.name;
  }
};

morpheus.SignalToNoise = function (list1, list2) {
  var m1 = morpheus.Mean(list1);
  var m2 = morpheus.Mean(list2);
  var s1 = Math.sqrt(morpheus.Variance(list1, m1));
  var s2 = Math.sqrt(morpheus.Variance(list2, m2));
  return (m1 - m2) / (s1 + s2);
};
morpheus.SignalToNoise.toString = function () {
  return 'Signal to noise';
};

morpheus.createSignalToNoiseAdjust = function (percent) {
  percent = percent || 0.2;
  var f = function (list1, list2) {
    var m1 = morpheus.Mean(list1);
    var m2 = morpheus.Mean(list2);
    var s1 = Math.sqrt(morpheus.Variance(list1, m1));
    var s2 = Math.sqrt(morpheus.Variance(list2, m2));
    s1 = morpheus.SignalToNoise.thresholdStandardDeviation(m1, s1, percent);
    s2 = morpheus.SignalToNoise.thresholdStandardDeviation(m2, s2, percent);
    // ensure variance is at least 20% of mean
    return (m1 - m2) / (s1 + s2);
  };
  f.toString = function () {
    return 'Signal to noise (adjust standard deviation)';
  };
  return f;
};

morpheus.SignalToNoise.thresholdStandardDeviation = function (mean,
                                                              standardDeviation, percent) {
  var returnValue = standardDeviation;
  var absMean = Math.abs(mean);
  var minStdev = percent * absMean;
  if (minStdev > standardDeviation) {
    returnValue = minStdev;
  }

  if (returnValue < percent) {
    returnValue = percent;
  }
  return returnValue;
};

morpheus.createContingencyTable = function (listOne, listTwo, groupingValue) {
  if (groupingValue == null || isNaN(groupingValue)) {
    groupingValue = 1;
  }
  var aHit = 0;
  var aMiss = 0;
  for (var j = 0, size = listOne.size(); j < size; j++) {
    var val = listOne.getValue(j);
    if (!isNaN(val)) {
      if (val >= groupingValue) {
        aHit++;
      } else {
        aMiss++;
      }
    }

  }
  var bHit = 0;
  var bMiss = 0;
  for (var j = 0, size = listTwo.size(); j < size; j++) {
    var val = listTwo.getValue(j);
    if (!isNaN(val)) {
      if (val >= groupingValue) {
        bHit++;
      } else {
        bMiss++;
      }
    }

  }
  // listOne=drawn, listTwo=not drawn
  // green=1, red=0
  var N = aHit + aMiss + bHit + bMiss;
  var K = aHit + bHit;
  var n = aHit + aMiss;
  var k = aHit;
  var a = k;
  var b = K - k;
  var c = n - k;
  var d = N + k - n - K;
  return [a, b, c, d];
};
morpheus.FisherExact = function (listOne, listTwo) {
  var abcd = morpheus.createContingencyTable(listOne, listTwo, 1);
  return morpheus.FisherExact.fisherTest(abcd[0], abcd[1], abcd[2], abcd[3]);
};

morpheus.createFisherExact = function (groupingValue) {
  var f = function (listOne, listTwo) {
    var abcd = morpheus.createContingencyTable(listOne, listTwo,
      groupingValue);
    return morpheus.FisherExact.fisherTest(abcd[0], abcd[1], abcd[2],
      abcd[3]);
  };
  return f;

};

/**
 * Computes the hypergeometric probability.
 */
morpheus.FisherExact.phyper = function (a, b, c, d) {
  return Math
    .exp((morpheus.FisherExact.logFactorial(a + b)
      + morpheus.FisherExact.logFactorial(c + d)
      + morpheus.FisherExact.logFactorial(a + c) + morpheus.FisherExact
        .logFactorial(b + d))
      - (morpheus.FisherExact.logFactorial(a)
      + morpheus.FisherExact.logFactorial(b)
      + morpheus.FisherExact.logFactorial(c)
      + morpheus.FisherExact.logFactorial(d) + morpheus.FisherExact
        .logFactorial(a + b + c + d)));

};

morpheus.FisherExact.logFactorials = [0.00000000000000000,
  0.00000000000000000, 0.69314718055994531, 1.79175946922805500,
  3.17805383034794562, 4.78749174278204599, 6.57925121201010100,
  8.52516136106541430, 10.60460290274525023, 12.80182748008146961,
  15.10441257307551530, 17.50230784587388584, 19.98721449566188615,
  22.55216385312342289, 25.19122118273868150, 27.89927138384089157,
  30.67186010608067280, 33.50507345013688888, 36.39544520803305358,
  39.33988418719949404, 42.33561646075348503, 45.38013889847690803,
  48.47118135183522388, 51.60667556776437357, 54.78472939811231919,
  58.00360522298051994, 61.26170176100200198, 64.55753862700633106,
  67.88974313718153498, 71.25703896716800901];
morpheus.FisherExact.logFactorial = function (k) {
  if (k >= 30) { // stirlings approximation
    var C0 = 9.18938533204672742e-01;
    var C1 = 8.33333333333333333e-02;
    var C3 = -2.77777777777777778e-03;
    var C5 = 7.93650793650793651e-04;
    var C7 = -5.95238095238095238e-04;
    var r = 1.0 / k;
    var rr = r * r;
    return (k + 0.5) * Math.log(k) - k + C0 + r
      * (C1 + rr * (C3 + rr * (C5 + rr * C7)));
    // log k! = (k + 1/2)log(k) - k + (1/2)log(2Pi) + stirlingCorrection(k)
  }
  return morpheus.FisherExact.logFactorials[k];
};

morpheus.FisherExact.fisherTest = function (a, b, c, d) {
  // match R 2-sided fisher.test
  var p = morpheus.FisherExact.phyper(a, b, c, d);
  var sum = p;
  for (var _a = 0, n = a + b + c + d; _a <= n; _a++) {
    var _b = a + b - _a;
    var _c = a + c - _a;
    var _d = b + d - _b;
    if (_a !== a && _b >= 0 && _c >= 0 && _d >= 0) {
      var _p = morpheus.FisherExact.phyper(_a, _b, _c, _d);
      if (_p <= p) {
        sum += _p;
      }
    }
  }
  return Math.min(1, sum);
  // var lt = jStat.hypgeom.cdf(a, a + b + c + d, a + b, a + c);
  // var gt = jStat.hypgeom.cdf(b, a + b + c + d, a + b, b + d);
  // return Math.min(1, 2 * Math.min(lt, gt));
};
morpheus.FisherExact.toString = function () {
  return 'Fisher Exact Test';
};

morpheus.FoldChange = function (list1, list2) {
  var m1 = morpheus.Mean(list1);
  var m2 = morpheus.Mean(list2);
  return (m1 / m2);
};
morpheus.FoldChange.toString = function () {
  return 'Fold Change';
};
morpheus.TTest = function (list1, list2) {
  var m1 = morpheus.Mean(list1);
  var m2 = morpheus.Mean(list2);
  var s1 = Math.sqrt(morpheus.Variance(list1, m1));
  var s2 = Math.sqrt(morpheus.Variance(list2, m2));
  var n1 = morpheus.CountNonNaN(list1);
  var n2 = morpheus.CountNonNaN(list2);
  return ((m1 - m2) / Math.sqrt((s1 * s1 / n1) + (s2 * s2 / n2)));
};
morpheus.TTest.toString = function () {
  return 'T-Test';
};
morpheus.Spearman = function (list1, list2) {
  var flist1 = [];
  var flist2 = [];
  for (var i = 0, n = list1.size(); i < n; i++) {
    var v1 = list1.getValue(i);
    var v2 = list2.getValue(i);
    if (isNaN(v1) || isNaN(v2)) {
      continue;
    }
    flist1.push(v1);
    flist2.push(v2);
  }
  var rank1 = morpheus.Ranking(flist1);
  var rank2 = morpheus.Ranking(flist2);
  return morpheus.Pearson(new morpheus.Vector('', rank1.length)
    .setArray(rank1), new morpheus.Vector('', rank2.length)
    .setArray(rank2));
};
morpheus.Spearman.toString = function () {
  return 'Spearman rank correlation';
};
morpheus.WeightedMean = function (weights, values) {
  var numerator = 0;
  var denom = 0;
  for (var i = 0, size = values.size(); i < size; i++) {
    var value = values.getValue(i);
    if (!isNaN(value)) {
      var weight = Math.abs(weights.getValue(i));
      if (!isNaN(weight)) {
        numerator += (weight * value);
        denom += weight;
      }
    }
  }
  return denom === 0 ? NaN : numerator / denom;
};
morpheus.WeightedMean.toString = function () {
  return 'Weighted average';
};

morpheus.createOneMinusMatrixValues = function (dataset) {
  var f = function (listOne, listTwo) {
    return 1 - dataset.getValue(listOne.getIndex(), listTwo.getIndex());
  };
  f.toString = function () {
    return 'One minus matrix values (for a precomputed similarity matrix)';
  };
  return f;
};

morpheus.Pearson = function (listOne, listTwo) {
  var sumx = 0;
  var sumxx = 0;
  var sumy = 0;
  var sumyy = 0;
  var sumxy = 0;
  var N = 0;
  for (var i = 0, size = listOne.size(); i < size; i++) {
    var x = listOne.getValue(i);
    var y = listTwo.getValue(i);
    if (isNaN(x) || isNaN(y)) {
      continue;
    }
    sumx += x;
    sumxx += x * x;
    sumy += y;
    sumyy += y * y;
    sumxy += x * y;
    N++;
  }
  var numr = sumxy - (sumx * sumy / N);
  var denr = Math.sqrt((sumxx - (sumx * sumx / N))
    * (sumyy - (sumy * sumy / N)));
  return denr == 0 ? 1 : numr / denr;
};
morpheus.Pearson.toString = function () {
  return 'Pearson correlation';
};

morpheus.Jaccard = function (listOne, listTwo) {

  var orCount = 0;
  var andCount = 0;
  for (var i = 0, size = listOne.size(); i < size; i++) {
    var xval = listOne.getValue(i);
    var yval = listTwo.getValue(i);
    if (isNaN(xval) || isNaN(yval)) {
      continue;
    }
    var x = xval > 0;
    var y = yval > 0;
    if (x && y) {
      andCount++;
    } else if (x || y) {
      orCount++;
    }
  }
  if (orCount === 0) {
    return 1;
  }
  return 1 - (andCount / orCount);
};

morpheus.Jaccard.toString = function () {
  return 'Jaccard distance';
};

morpheus.Cosine = function (listOne, listTwo) {
  var sumX2 = 0;
  var sumY2 = 0;
  var sumXY = 0;
  for (var i = 0, size = listOne.size(); i < size; i++) {
    var x = listOne.getValue(i);
    var y = listTwo.getValue(i);
    if (isNaN(x) || isNaN(y)) {
      continue;
    }
    sumX2 += x * x;
    sumY2 += y * y;
    sumXY += x * y;
  }
  return (sumXY / Math.sqrt(sumX2 * sumY2));
};

morpheus.Cosine.toString = function () {
  return 'Cosine similarity';
};

morpheus.Euclidean = function (x, y) {
  var dist = 0;
  for (var i = 0, size = x.size(); i < size; ++i) {
    var x_i = x.getValue(i);
    var y_i = y.getValue(i);
    if (isNaN(x_i) || isNaN(y_i)) {
      continue;
    }
    dist += (x_i - y_i) * (x_i - y_i);
  }
  return Math.sqrt(dist);
};
morpheus.Euclidean.toString = function () {
  return 'Euclidean distance';
};
morpheus.OneMinusFunction = function (f) {
  var dist = function (x, y) {
    return 1 - f(x, y);
  };
  dist.toString = function () {
    var s = f.toString();
    return 'One minus ' + s[0].toLowerCase() + s.substring(1);
  };
  return dist;
};

morpheus.LinearRegression = function (xVector, yVector) {
  var sumX = 0;
  var sumY = 0;
  var sumXX = 0;
  var sumXY = 0;
  var count = 0;
  for (var i = 0, size = xVector.size(); i < size; i++) {
    var x = xVector.getValue(i);
    var y = yVector.getValue(i);
    if (!isNaN(x) && !isNaN(y)) {
      sumX += x;
      sumY += y;
      sumXX += x * x;
      sumXY += x * y;
      count++;
    }
  }

  var m = ((count * sumXY) - (sumX * sumY)) /
    ((count * sumXX) - (sumX * sumX));
  var b = (sumY / count) - ((m * sumX) / count);
  return {
    m: m,
    b: b
  };
};

morpheus.KendallsCorrelation = function (x, y) {

  /**
   * Returns the sum of the number from 1 .. n according to Gauss' summation formula:
   * \[ \sum\limits_{k=1}^n k = \frac{n(n + 1)}{2} \]
   *
   * @param n the summation end
   * @return the sum of the number from 1 to n
   */
  function sum(n) {
    return n * (n + 1) / 2;
  }

  var xArray = [];
  var yArray = [];
  for (var i = 0, size = x.size(); i < size; ++i) {
    var x_i = x.getValue(i);
    var y_i = y.getValue(i);
    if (isNaN(x_i) || isNaN(y_i)) {
      continue;
    }
    xArray.push(x_i);
    yArray.push(y_i);
  }
  var n = xArray.length;
  var numPairs = sum(n - 1);
  var pairs = [];
  for (var i = 0; i < n; i++) {
    pairs[i] = [xArray[i], yArray[i]];
  }
  pairs.sort(function (pair1, pair2) {
    var a = pair1[0];
    var b = pair2[0];
    var compareFirst = (a === b ? 0 : (a < b ? -1 : 1));
    if (compareFirst !== 0) {
      return compareFirst;
    }
    a = pair1[1];
    b = pair2[1];
    return (a === b ? 0 : (a < b ? -1 : 1));
  });

  var tiedXPairs = 0;
  var tiedXYPairs = 0;
  var consecutiveXTies = 1;
  var consecutiveXYTies = 1;
  var prev = pairs[0];
  for (var i = 1; i < n; i++) {
    var curr = pairs[i];
    if (curr[0] === prev[0]) {
      consecutiveXTies++;
      if (curr[1] === prev[1]) {
        consecutiveXYTies++;
      } else {
        tiedXYPairs += sum(consecutiveXYTies - 1);
        consecutiveXYTies = 1;
      }
    } else {
      tiedXPairs += sum(consecutiveXTies - 1);
      consecutiveXTies = 1;
      tiedXYPairs += sum(consecutiveXYTies - 1);
      consecutiveXYTies = 1;
    }
    prev = curr;
  }
  tiedXPairs += sum(consecutiveXTies - 1);
  tiedXYPairs += sum(consecutiveXYTies - 1);
  var swaps = 0;
  var pairsDestination = [];
  for (var segmentSize = 1; segmentSize < n; segmentSize <<= 1) {
    for (var offset = 0; offset < n; offset += 2 * segmentSize) {
      var i = offset;
      var iEnd = Math.min(i + segmentSize, n);
      var j = iEnd;
      var jEnd = Math.min(j + segmentSize, n);
      var copyLocation = offset;
      while (i < iEnd || j < jEnd) {
        if (i < iEnd) {
          if (j < jEnd) {
            var c = (pairs[i][1] === pairs[j][1] ? 0 : (pairs[i][1] < pairs[j][1] ? -1 : 1));
            if (c <= 0) {
              pairsDestination[copyLocation] = pairs[i];
              i++;
            } else {
              pairsDestination[copyLocation] = pairs[j];
              j++;
              swaps += iEnd - i;
            }
          } else {
            pairsDestination[copyLocation] = pairs[i];
            i++;
          }
        } else {
          pairsDestination[copyLocation] = pairs[j];
          j++;
        }
        copyLocation++;
      }
    }
    var pairsTemp = pairs;
    pairs = pairsDestination;
    pairsDestination = pairsTemp;
  }

  var tiedYPairs = 0;
  var consecutiveYTies = 1;
  prev = pairs[0];
  for (var i = 1; i < n; i++) {
    var curr = pairs[i];
    if (curr[1] === prev[1]) {
      consecutiveYTies++;
    } else {
      tiedYPairs += sum(consecutiveYTies - 1);
      consecutiveYTies = 1;
    }
    prev = curr;
  }
  tiedYPairs += sum(consecutiveYTies - 1);

  var concordantMinusDiscordant = numPairs - tiedXPairs - tiedYPairs + tiedXYPairs - 2 * swaps;
  var nonTiedPairsMultiplied = (numPairs - tiedXPairs) * (numPairs - tiedYPairs);
  return concordantMinusDiscordant / Math.sqrt(nonTiedPairsMultiplied);
};
morpheus.KendallsCorrelation.toString = function () {
  return 'Kendall\'s correlation';
};

/**
 * Creates a new computed vector with the given name and size.
 *
 * @param name
 *            the vector name
 * @param size
 *            the number of elements in this vector
 * @param callback {Function} that takes an index and returns the value at the specified index
 * @constructor
 */
morpheus.ComputedVector = function (name, size, callback) {
  morpheus.AbstractVector.call(this, name, size);
  this.callback = callback;
};

morpheus.ComputedVector.prototype = {
  getValue: function (index) {
    return this.callback(index);
  }
};
morpheus.Util.extend(morpheus.ComputedVector, morpheus.AbstractVector);

morpheus.DatasetAdapter = function (dataset, rowMetadata, columnMetadata) {
  if (dataset == null) {
    throw 'dataset is null';
  }
  this.dataset = dataset;
  this.rowMetadata = rowMetadata || dataset.getRowMetadata();
  this.columnMetadata = columnMetadata || dataset.getColumnMetadata();

};
morpheus.DatasetAdapter.prototype = {
  getDataset: function () {
    return this.dataset;
  },
  getName: function (seriesIndex) {
    return this.dataset.getName(seriesIndex);
  },
  setName: function (seriesIndex, name) {
    this.dataset.setName(seriesIndex, name);
  },
  getRowMetadata: function () {
    return this.rowMetadata;
  },
  getColumnMetadata: function () {
    return this.columnMetadata;
  },
  getRowCount: function () {
    return this.dataset.getRowCount();
  },
  getColumnCount: function () {
    return this.dataset.getColumnCount();
  },
  getValue: function (rowIndex, columnIndex, seriesIndex) {
    return this.dataset.getValue(rowIndex, columnIndex, seriesIndex);
  },
  setValue: function (rowIndex, columnIndex, value, seriesIndex) {
    this.dataset.setValue(rowIndex, columnIndex, value, seriesIndex);
  },
  addSeries: function (options) {
    return this.dataset.addSeries(options);
  },
  removeSeries: function (seriesIndex) {
    this.dataset.removeSeries(seriesIndex);
  },
  getSeriesCount: function () {
    return this.dataset.getSeriesCount();
  },
  getDataType: function (seriesIndex) {
    return this.dataset.getDataType(seriesIndex);
  },
  toString: function () {
    return this.dataset.toString();
  }
};

morpheus.DatasetColumnView = function (dataset) {
  this.dataset = dataset;
  this.columnIndex = 0;
  this.seriesIndex = 0;
};
morpheus.DatasetColumnView.prototype = {
  columnIndex: -1,
  size: function () {
    return this.dataset.getRowCount();
  },
  getValue: function (rowIndex) {
    return this.dataset.getValue(rowIndex, this.columnIndex,
      this.seriesIndex);
  },
  setIndex: function (newColumnIndex) {
    this.columnIndex = newColumnIndex;
    return this;
  },
  setSeriesIndex: function (seriesIndex) {
    this.seriesIndex = seriesIndex;
    return this;
  }
};

/**
 * The interface for a dataset consisting of a two-dimensional matrix of
 * values. A dataset may also optionally contain one or more series of
 * two-dimensional matrices. A dataset also has metadata associated with each
 * row and column.
 *
 * @interface morpheus.DatasetInterface
 */

/**
 * Returns the name for the given series. Series can be used to store
 * standard error of data points for example.
 *
 * @function
 * @name morpheus.DatasetInterface#getName
 * @param seriesIndex {number} the series
 * @return {string} the series name
 */

/**
 * Sets the name for the given series. Series can be used to store standard
 * error of data points for example.
 *
 * @function
 * @name morpheus.DatasetInterface#setName
 * @param seriesIndex {number} the series
 * @param name {string} the series name
 */

/**
 * Gets the row metadata for this dataset.
 *
 * @function
 * @name morpheus.DatasetInterface#getRowMetadata
 * @return {morpheus.MetadataModelInterface} the row metadata
 */

/**
 * Gets the column metadata for this dataset.
 *
 * @function
 * @name morpheus.DatasetInterface#getColumnMetadata
 * @return {morpheus.MetadataModelInterface} The column metadata
 */

/**
 * Returns the number of rows in the dataset.
 *
 * @function
 * @name morpheus.DatasetInterface#getRowCount
 * @return {number} the number of rows
 */

/**
 * Returns the number of columns in the dataset.
 *
 * @function
 * @name morpheus.DatasetInterface#getColumnCount
 * @return {number} the number of columns
 */

/**
 * Returns the value at the given row and column for the given series.
 * Series can be used to store standard error of data points for example.
 *
 * @function
 * @name morpheus.DatasetInterface#getValue
 * @param rowIndex {number} the row index
 * @param columnIndex {number} the column index
 * @param seriesIndex {number} the series index
 * @return the value
 */

/**
 * Sets the value at the given row and column for the given series.
 *
 * @function
 * @name morpheus.DatasetInterface#setValue
 * @param rowIndex {number} the row index
 * @param columnIndex {number} the column index
 * @param value the value
 * @param seriesIndex {number} the series index
 */

/**
 * Adds the specified series.
 *
 * @function
 * @name morpheus.DatasetInterface#addSeries
 * @param options.name {string} the series name
 * @param options.dataType {string} the series data type (e.g. object, Float32, Int8)
 * @return {number} the series index
 */

/**
 * Removes the specified series.
 *
 * @function
 * @name morpheus.DatasetInterface#removeSeries
 * @param seriesIndex {number} The series index.
 */

/**
 * Returns the number of matrix series. Series can be used to store standard
 * error of data points for example.
 *
 * @function
 * @name morpheus.DatasetInterface#getSeriesCount
 * @return {number} the number of series
 */

/**
 * Returns the data type at the specified series index.
 *
 * @function
 * @name morpheus.DatasetInterface#getDataType
 * @param seriesIndex {number} the series index
 * @return {string} the series data type (e.g. Number, Float32, Int8)
 */


morpheus.DatasetRowView = function (dataset) {
  this.dataset = dataset;
  this.index = 0;
  this.seriesIndex = 0;
};
morpheus.DatasetRowView.prototype = {
  size: function () {
    return this.dataset.getColumnCount();
  },
  getIndex: function () {
    return this.index;
  },
  getValue: function (columnIndex) {
    return this.dataset.getValue(this.index, columnIndex, this.seriesIndex);
  },
  setIndex: function (newRowIndex) {
    this.index = newRowIndex;
    return this;
  },
  setSeriesIndex: function (seriesIndex) {
    this.seriesIndex = seriesIndex;
    return this;
  },
  setDataset: function (dataset) {
    this.dataset = dataset;
    return this;
  }
};

morpheus.DatasetSeriesView = function (dataset, seriesIndices) {
  morpheus.DatasetAdapter.call(this, dataset);
  this.seriesIndices = seriesIndices;
};
morpheus.DatasetSeriesView.prototype = {
  getValue: function (i, j, seriesIndex) {
    seriesIndex = seriesIndex || 0;
    return this.dataset.getValue(i, j, this.seriesIndices[seriesIndex]);
  },
  setValue: function (i, j, value, seriesIndex) {
    seriesIndex = seriesIndex || 0;
    this.dataset.setValue(i, j, value, this.seriesIndices[seriesIndex]);
  },
  getName: function (seriesIndex) {
    seriesIndex = seriesIndex || 0;
    return this.dataset.getName(this.seriesIndices[seriesIndex]);
  },
  setName: function (seriesIndex, name) {
    seriesIndex = seriesIndex || 0;
    this.dataset.setName(this.seriesIndices[seriesIndex], name);
  },
  addSeries: function (options) {
    var index = this.dataset.addSeries(options);
    this.seriesIndices.push(index);
    return index;
  },
  getSeriesCount: function () {
    return this.seriesIndices.length;
  },
  toString: function () {
    return this.getName();
  }
};
morpheus.Util.extend(morpheus.DatasetSeriesView, morpheus.DatasetAdapter);

/**
 * Static utilities for morpheus.DatasetInterface instances
 *
 * @class morpheus.DatasetUtil
 */
morpheus.DatasetUtil = function () {
};
morpheus.DatasetUtil.min = function (dataset, seriesIndex) {
  seriesIndex = seriesIndex || 0;
  var min = Number.MAX_VALUE;
  for (var i = 0, rows = dataset.getRowCount(); i < rows; i++) {
    for (var j = 0, columns = dataset.getColumnCount(); j < columns; j++) {
      var d = dataset.getValue(i, j, seriesIndex);
      if (isNaN(d)) {
        continue;
      }
      min = Math.min(min, d);
    }
  }
  return min;
};
morpheus.DatasetUtil.slicedView = function (dataset, rows, columns) {
  return new morpheus.SlicedDatasetView(dataset, rows, columns);
};
morpheus.DatasetUtil.transposedView = function (dataset) {
  return dataset instanceof morpheus.TransposedDatasetView ? dataset
    .getDataset() : new morpheus.TransposedDatasetView(dataset);
};
morpheus.DatasetUtil.max = function (dataset, seriesIndex) {
  seriesIndex = seriesIndex || 0;
  var max = -Number.MAX_VALUE;
  for (var i = 0, rows = dataset.getRowCount(); i < rows; i++) {
    for (var j = 0, columns = dataset.getColumnCount(); j < columns; j++) {
      var d = dataset.getValue(i, j, seriesIndex);
      if (isNaN(d)) {
        continue;
      }
      max = Math.max(max, d);
    }
  }
  return max;
};

morpheus.DatasetUtil.getDatasetReader = function (ext, options) {
  if (options == null) {
    options = {};
  }
  var datasetReader;
  if (ext === 'maf') {
    datasetReader = new morpheus.MafFileReader();
    if (options && options.mafGeneFilter) {
      datasetReader.setGeneFilter(options.mafGeneFilter);
    }
  } else if (ext === 'gct') {
    datasetReader = new morpheus.GctReader();
    // datasetReader = new morpheus.StreamingGctReader();
  } else if (ext === 'gmt') {
    datasetReader = new morpheus.GmtDatasetReader();
  } else if (ext === 'xlsx' || ext === 'xls') {
    datasetReader = options.interactive ? new morpheus.Array2dReaderInteractive() : new morpheus.XlsxDatasetReader();
  } else if (ext === 'segtab' || ext === 'seg') {
    datasetReader = new morpheus.SegTabReader();
    if (options && options.regions) {
      datasetReader.setRegions(options.regions);
    }
  } else if (ext === 'txt' || ext === 'tsv' || ext === 'csv') {
    datasetReader = options.interactive ? new morpheus.Array2dReaderInteractive() : new morpheus.TxtReader();
  } else if (ext === 'json') {
    datasetReader = new morpheus.JsonDatasetReader();
  } else {
    datasetReader = new morpheus.GctReader();
  }
  return datasetReader;
}
;

morpheus.DatasetUtil.readDatasetArray = function (datasets) {
  var retDef = $.Deferred();
  var loadedDatasets = [];
  var promises = [];
  _.each(datasets, function (url, i) {
    var p = morpheus.DatasetUtil.read(url);
    p.index = i;
    p.done(function (dataset) {
      loadedDatasets[this.index] = dataset;
    });
    p.fail(function (err) {
      var message = ['Error opening ' + morpheus.Util
        .getFileName(url) + '.'];
      if (err.message) {
        message.push('<br />Cause: ');
        message.push(err.message);
      }
      retDef.reject(message.join(''));

    });
    promises.push(p);
  });
  if (promises.length === 0) {
    retDef.reject('No datasets specified.');
  }

  $.when
    .apply($, promises)
    .then(
      function () {
        retDef.resolve(morpheus.DatasetUtil.join(loadedDatasets, 'id'));
      });
  return retDef;
};
/**
 * Annotate a dataset from external file or text.
 *
 * @param options.annotations -
 *            Array of file, datasetField, and fileField.
 * @param options.isColumns -
 *            Whether to annotate columns
 * @return A jQuery Deferred object that resolves to an array of functions to
 *         execute with a dataset parameter.
 */
morpheus.DatasetUtil.annotate = function (options) {
  var retDef = $.Deferred();
  var promises = [];
  var functions = [];
  var isColumns = options.isColumns;
  _.each(options.annotations, function (ann, annotationIndex) {
    if (morpheus.Util.isArray(ann.file)) { // already parsed text
      functions[annotationIndex] = function (dataset) {
        new morpheus.OpenFileTool().annotate(ann.file, dataset,
          isColumns, null, ann.datasetField, ann.fileField,
          ann.include);
      };
    } else {
      var result = morpheus.Util.readLines(ann.file);
      var fileName = morpheus.Util.getFileName(ann.file);
      var deferred = $.Deferred();
      promises.push(deferred);
      result.fail(function (message) {
        deferred.reject(message);
      });
      result.done(function (lines) {
        if (morpheus.Util.endsWith(fileName, '.gmt')) {
          var sets = new morpheus.GmtReader().parseLines(lines);
          functions[annotationIndex] = function (dataset) {
            new morpheus.OpenFileTool().annotate(null, dataset,
              isColumns, sets, ann.datasetField,
              ann.fileField);
          };
          deferred.resolve();
        } else if (morpheus.Util.endsWith(fileName, '.cls')) {
          functions[annotationIndex] = function (dataset) {
            new morpheus.OpenFileTool().annotateCls(null, dataset,
              fileName, isColumns, lines);
          };
          deferred.resolve();
        } else {
          functions[annotationIndex] = function (dataset) {
            new morpheus.OpenFileTool().annotate(lines, dataset,
              isColumns, null, ann.datasetField,
              ann.fileField, ann.include);
          };
          deferred.resolve();
        }
      });
    }
  });
  $.when.apply($, promises).then(function () {
    retDef.resolve(functions);
  });
  return retDef;
};
/**
 * Reads a dataset at the specified URL or file
 * @param file
 *            a File or URL
 * @return A promise that resolves to morpheus.DatasetInterface
 */
morpheus.DatasetUtil.read = function (fileOrUrl, options) {
  if (fileOrUrl == null) {
    throw 'File is null';
  }
  if (options == null) {
    options = {};
  }
  var isFile = fileOrUrl instanceof File;
  var isString = morpheus.Util.isString(fileOrUrl);
  var ext = options.extension ? options.extension : morpheus.Util.getExtension(morpheus.Util.getFileName(fileOrUrl));
  var datasetReader;
  var str = fileOrUrl.toString();

  var isGSE = isString && (fileOrUrl.substring(0, 3) === 'GSE' || fileOrUrl.substring(0, 3) === 'GDS');

  if (isGSE) {
    datasetReader = new morpheus.GseReader({type: fileOrUrl.substring(0, 3)});
  }
  else if (ext === '' && str != null && str.indexOf('blob:') === 0) {
    datasetReader = new morpheus.TxtReader(); // copy from clipboard
  } else {
    datasetReader = morpheus.DatasetUtil.getDatasetReader(ext, options);
  }
  if (isString || isFile) { // URL or file
    var deferred = $.Deferred();
    // override toString so can determine file name
    if (options.background) {
      var path = morpheus.Util.getScriptPath();
      var blob = new Blob(
        ['self.onmessage = function(e) {'
        + 'importScripts(e.data.path);'
        + 'var ext = morpheus.Util.getExtension(morpheus.Util'
        + '.getFileName(e.data.fileOrUrl));'
        + 'var datasetReader = morpheus.DatasetUtil.getDatasetReader(ext,'
        + '	e.data.options);'
        + 'datasetReader.read(e.data.fileOrUrl, function(err,dataset) {'
        + '	self.postMessage(dataset);' + '	});' + '}']);

      var blobURL = window.URL.createObjectURL(blob);
      var worker = new Worker(blobURL);
      worker.addEventListener('message', function (e) {
        deferred.resolve(morpheus.Dataset.fromJSON(e.data));
        window.URL.revokeObjectURL(blobURL);
      }, false);
      // start the worker
      worker.postMessage({
        path: path,
        fileOrUrl: fileOrUrl,
        options: options
      });

    } else {
      datasetReader.read(fileOrUrl, function (err, dataset) {
        if (err) {
          deferred.reject(err);
        } else {
          deferred.resolve(dataset);
          console.log(dataset);
          morpheus.DatasetUtil.toESSessionPromise({dataset: dataset, isGEO: isGSE});
        }
      });

    }
    var pr = deferred.promise();
    pr.toString = function () {
      return '' + fileOrUrl;
    };
    //console.log("morpheus.DatasetUtil.read ::", pr);
    return pr;
  } else if (typeof fileOrUrl.done === 'function') { // assume it's a
    // deferred
    return fileOrUrl;
  } else { // it's already a dataset?
    var deferred = $.Deferred();
    if (fileOrUrl.getRowCount) {
      deferred.resolve(fileOrUrl);
    } else {
      deferred.resolve(morpheus.Dataset.fromJSON(fileOrUrl));
    }
    return deferred.promise();
  }

};

/**
 * @param dataset
 *            The dataset to convert to an array
 * @param options.columns
 *            An array of column indices to include from the dataset
 * @param options.columnFields
 *            An array of field names to use in the returned objects that
 *            correspond to the column indices in the dataset
 * @param options.metadataFields
 *            An array of row metadata fields to include from the dataset
 *
 */
morpheus.DatasetUtil.toObjectArray = function (dataset, options) {
  var columns = options.columns || [0];
  var columnFields = options.columnFields || ['value'];
  if (columnFields.length !== columns.length) {
    throw 'columns.length !== columnFields.length';
  }
  var metadataFields = options.metadataFields;
  // grab all of the headers and filter the meta data vectors in the dataset
  // down
  // to the ones specified in metaFields. If metaFields is not passed, take
  // all metadata
  var rowMetadata = dataset.getRowMetadata();
  if (!metadataFields) {
    metadataFields = morpheus.MetadataUtil.getMetadataNames(rowMetadata);
  }
  var vectors = morpheus.MetadataUtil.getVectors(rowMetadata, metadataFields);
  // build an object that contains the matrix values for the given columns
  // along
  // with any metadata
  var array = [];
  for (var i = 0; i < dataset.getRowCount(); i++) {
    var obj = {};
    for (var j = 0; j < columns.length; j++) {
      obj[columnFields[j]] = dataset.getValue(i, columns[j]);
    }
    for (var j = 0; j < vectors.length; j++) {
      obj[vectors[j].getName()] = vectors[j].getValue(i);
    }
    array.push(obj);
  }
  return array;
};
morpheus.DatasetUtil.fixL1K = function (dataset) {
  var names = {
    'cell_id': 'Cell Line',
    'pert_idose': 'Dose (\u00B5M)',
    'pert_iname': 'Name',
    'pert_itime': 'Time (hr)',
    'distil_ss': 'Signature Strength',
    'pert_type': 'Type',
    'cell_lineage': 'Lineage',
    'cell_histology': 'Histology',
    'cell_type': 'Cell Type'
  };
  var fixNames = function (metadata) {
    for (var i = 0, count = metadata.getMetadataCount(); i < count; i++) {
      var v = metadata.get(i);
      var name = v.getName();
      var mapped = names[name];
      if (mapped) {
        v.setName(mapped);
      }
    }
  };
  fixNames(dataset.getRowMetadata());
  fixNames(dataset.getColumnMetadata());
  var fix666 = function (metadata) {
    for (var i = 0, count = metadata.getMetadataCount(); i < count; i++) {
      var v = metadata.get(i);
      if (v.getName() == 'Dose (\u00B5M)') { // convert to number
        for (var j = 0, size = v.size(); j < size; j++) {
          var value = v.getValue(j);
          if (value != null) {
            v.setValue(j, parseFloat(value));
          }
        }
      }
      var isNumber = false;
      for (var j = 0, size = v.size(); j < size; j++) {
        var value = v.getValue(j);
        if (value != null) {
          isNumber = _.isNumber(value);
          break;
        }
      }
      var newValue = isNumber || v.getName() == 'Dose (\u00B5M)' ? 0 : '';
      for (var j = 0, size = v.size(); j < size; j++) {
        var value = v.getValue(j);
        if (value != null && value == '-666') {
          v.setValue(j, newValue);
        }
      }
    }
  };
  fix666(dataset.getRowMetadata());
  fix666(dataset.getColumnMetadata());
  var fixCommas = function (metadata) {
    var regex = /(,)([^ ])/g;
    _.each(['Lineage', 'Histology'], function (name) {
      var v = metadata.getByName(name);
      if (v != null) {
        for (var i = 0, size = v.size(); i < size; i++) {
          var val = v.getValue(i);
          if (val) {
            v.setValue(i, val.replace(regex, ', $2'));
          }
        }
      }
    });
  };
  fixCommas(dataset.getRowMetadata());
  fixCommas(dataset.getColumnMetadata());
};
morpheus.DatasetUtil.geneSetsToDataset = function (name, sets) {
  var uniqueIds = new morpheus.Map();
  for (var i = 0, length = sets.length; i < length; i++) {
    var ids = sets[i].ids;
    for (var j = 0, nIds = ids.length; j < nIds; j++) {
      uniqueIds.set(ids[j], 1);
    }
  }
  var uniqueIdsArray = uniqueIds.keys();
  var dataset = new morpheus.Dataset({
    name: name,
    rows: uniqueIdsArray.length,
    columns: sets.length
  });
  var columnIds = dataset.getColumnMetadata().add('id');
  for (var i = 0, length = sets.length; i < length; i++) {
    columnIds.setValue(i, sets[i].name);
  }
  var rowIds = dataset.getRowMetadata().add('id');
  for (var i = 0, size = uniqueIdsArray.length; i < size; i++) {
    rowIds.setValue(i, uniqueIdsArray[i]);
  }
  var rowIdToIndex = morpheus.VectorUtil.createValueToIndexMap(rowIds);
  for (var i = 0, length = sets.length; i < length; i++) {
    var ids = sets[i].ids;
    for (var j = 0, nIds = ids.length; j < nIds; j++) {
      dataset.setValue(rowIdToIndex.get(ids[j]), i, 1);
    }
  }
  return dataset;
};
morpheus.DatasetUtil.DATASET_FILE_FORMATS = '<a target="_blank" href="https://clue.io/help#datasets">GCT 1.3</a>, '
  + '<a target="_blank" href="http://www.broadinstitute.org/cancer/software/genepattern/gp_guides/file-formats/sections/gct">GCT 1.2</a>, '
  + '<a target="_blank" href="https://wiki.nci.nih.gov/display/TCGA/Mutation+Annotation+Format+%28MAF%29+Specification">MAF</a>, '
  + '<a target="_blank" href="http://www.broadinstitute.org/cancer/software/gsea/wiki/index.php/Data_formats#GMT:_Gene_Matrix_Transposed_file_format_.28.2A.gmt.29">GMT</a>, '
  + ' a tab-delimited text file, or an Excel spreadsheet';
morpheus.DatasetUtil.SESSION_FILE_FORMAT = 'a saved Morpheus session';

morpheus.DatasetUtil.DATASET_AND_SESSION_FILE_FORMATS = '<a target="_blank"' +
  ' href="https://clue.io/help#datasets">GCT 1.3</a>, '
  + '<a target="_blank" href="http://www.broadinstitute.org/cancer/software/genepattern/gp_guides/file-formats/sections/gct">GCT 1.2</a>, '
  + '<a target="_blank" href="https://wiki.nci.nih.gov/display/TCGA/Mutation+Annotation+Format+%28MAF%29+Specification">MAF</a>, '
  + '<a target="_blank" href="http://www.broadinstitute.org/cancer/software/gsea/wiki/index.php/Data_formats#GMT:_Gene_Matrix_Transposed_file_format_.28.2A.gmt.29">GMT</a>, '
  + ' a tab-delimited text file, an Excel spreadsheet, or a saved Morpheus session';
morpheus.DatasetUtil.BASIC_DATASET_FILE_FORMATS = '<a target="_blank" href="https://clue.io/help#datasets">GCT 1.3</a>, '
  + '<a target="_blank" href="http://www.broadinstitute.org/cancer/software/genepattern/gp_guides/file-formats/sections/gct">GCT 1.2</a>, '
  + ' or a tab-delimited text file';
morpheus.DatasetUtil.GCT_FILE_FORMAT = '<a target="_blank" href="https://clue.io/help#datasets">GCT 1.3</a>';
morpheus.DatasetUtil.ANNOTATION_FILE_FORMATS = 'an xlsx file, tab-delimited text file, or a <a target="_blank" href="http://www.broadinstitute.org/cancer/software/gsea/wiki/index.php/Data_formats#GMT:_Gene_Matrix_Transposed_file_format_.28.2A.gmt.29">GMT file</a>';
morpheus.DatasetUtil.DENDROGRAM_FILE_FORMATS = 'a <a href="http://en.wikipedia.org/wiki/Newick_format" target="_blank">Newick</a> file';
morpheus.DatasetUtil.OPEN_FILE_FORMATS = '<a target="_blank" href="https://clue.io/help#datasets">GCT 1.3</a>, '
  + '<a target="_blank" href="http://www.broadinstitute.org/cancer/software/genepattern/gp_guides/file-formats/sections/gct">GCT 1.2</a>, '
  + '<a target="_blank" href="https://wiki.nci.nih.gov/display/TCGA/Mutation+Annotation+Format+%28MAF%29+Specification">MAF</a>, '
  + '<a target="_blank" href="http://www.broadinstitute.org/cancer/software/gsea/wiki/index.php/Data_formats#GMT:_Gene_Matrix_Transposed_file_format_.28.2A.gmt.29">GMT</a>, '
  + ' a tab-delimited text file, or a <a href="http://en.wikipedia.org/wiki/Newick_format" target="_blank">Newick</a> file';
morpheus.DatasetUtil.getRootDataset = function (dataset) {
  while (dataset.getDataset) {
    dataset = dataset.getDataset();
  }
  return dataset;
};

morpheus.DatasetUtil.getSeriesIndex = function (dataset, name) {
  for (var i = 0, nseries = dataset.getSeriesCount(); i < nseries; i++) {
    if (name === dataset.getName(i)) {
      return i;
    }
  }
  return -1;
};
morpheus.DatasetUtil.getSeriesNames = function (dataset) {
  var names = [];
  for (var i = 0, nseries = dataset.getSeriesCount(); i < nseries; i++) {
    names.push(dataset.getName(i));
  }
  // names.sort(function (a, b) {
  // 	a = a.toLowerCase();
  // 	b = b.toLowerCase();
  // 	return (a < b ? -1 : (a === b ? 0 : 1));
  // });
  return names;
};

/**
 * Search dataset values.
 *
 * @param options.dataset
 *      The dataset
 * @param options.text
 *            Search text
 * @param options.defaultMatchMode
 *            'exact' or 'contains'
 * @param options.matchAllPredicates Whether to match all predicates
 * @return Set of matching indices.
 *
 */
morpheus.DatasetUtil.searchValues = function (options) {
  if (text === '') {
    return;
  }
  var dataset = options.dataset;
  var text = options.text;
  var tokens = morpheus.Util.getAutocompleteTokens(text);
  if (tokens.length == 0) {
    return;
  }
  var predicates = morpheus.Util.createSearchPredicates({
    tokens: tokens,
    defaultMatchMode: options.defaultMatchMode
  });
  var matchAllPredicates = options.matchAllPredicates === true;
  var npredicates = predicates.length;
  var viewIndices = new morpheus.Set();

  function isMatch(object, toObject, predicate) {
    if (object != null) {
      if (toObject) {
        var filterColumnName = predicate.getField();
        if (filterColumnName != null) {
          var value = object[filterColumnName];
          return predicate.accept(value);
        } else { // try all fields
          for (var name in object) {
            var value = object[name];
            return predicate.accept(value);
          }
        }
      } else {
        var filterColumnName = predicate.getField();
        if (filterColumnName == null || filterColumnName === dataset.getName(k)) {
          return predicate.accept(object);

        }
      }
    }
  }

  for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
    for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
      var matches = false;
      itemSearch:
        if (matchAllPredicates) {
          matches = true;
          for (var p = 0; p < npredicates; p++) {
            var predicate = predicates[p];
            var pmatch = false;
            for (var k = 0, nseries = dataset.getSeriesCount(); k < nseries; k++) {
              var element = dataset.getValue(i, j, k);
              var isObject = element != null && element.toObject != null;
              if (isObject) {
                element = element.toObject();
              }
              if (isMatch(element, isObject, predicate)) {
                pmatch = true;
                break;
              }
            }
            if (!pmatch) {
              matches = false;
              break itemSearch;
            }
          }
        } else {
          for (var k = 0, nseries = dataset.getSeriesCount(); k < nseries; k++) {
            var element = dataset.getValue(i, j, k);
            var isObject = element != null && element.toObject != null;
            if (isObject) {
              element = element.toObject();
            }
            for (var p = 0; p < npredicates; p++) {
              var predicate = predicates[p];
              if (isMatch(element, isObject, predicate)) {
                matches = true;
                break itemSearch;
              }
            }
          }
        }

      if (matches) {
        viewIndices
          .add(new morpheus.Identifier(
            [i, j]));
      }
    }
  }
  return viewIndices;

};

/**
 * Search dataset values.
 */
morpheus.DatasetUtil.autocompleteValues = function (dataset) {
  return function (tokens, cb) {

    var token = tokens != null && tokens.length > 0 ? tokens[tokens.selectionStartIndex]
      : '';
    token = $.trim(token);
    var seriesIndices = [];
    for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
      for (var k = 0, nseries = dataset.getSeriesCount(); k < nseries; k++) {
        if (dataset.getDataType(i, k) === 'Number') {
          seriesIndices.push([i, k]);
        }
      }
    }
    if (seriesIndices.length === 0) {
      return cb();
    }
    var _val; // first non-null value
    elementSearch: for (var k = 0, nseries = seriesIndices.length; k < nseries; k++) {
      var pair = seriesIndices[k];
      for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
        var element = dataset.getValue(pair[0], j, pair[1]);
        if (element != null && element.toObject) {
          _val = element.toObject();
          break elementSearch;
        }
      }
    }
    var matches = [];
    var fields = _val == null ? [] : _.keys(_val);
    if (token === '') {
      fields.sort(function (a, b) {
        return (a === b ? 0 : (a < b ? -1 : 1));
      });
      fields.forEach(function (field) {
        matches.push({
          value: field + ':',
          label: '<span style="font-weight:300;">' + field
          + ':</span>',
          show: true
        });
      });
      return cb(matches);
    }

    var field = null;
    var semi = token.indexOf(':');
    if (semi > 0) { // field search?
      if (token.charCodeAt(semi - 1) !== 92) { // \:
        var possibleField = $.trim(token.substring(0, semi));
        if (possibleField.length > 0 && possibleField[0] === '"'
          && possibleField[token.length - 1] === '"') {
          possibleField = possibleField.substring(1,
            possibleField.length - 1);
        }
        var index = fields.indexOf(possibleField);
        if (index !== -1) {
          token = $.trim(token.substring(semi + 1));
          field = possibleField;
        }
      }

    }

    var set = new morpheus.Set();
    // regex used to determine if a string starts with substring `q`
    var regex = new RegExp('^' + morpheus.Util.escapeRegex(token), 'i');
    // iterate through the pool of strings and for any string that
    // contains the substring `q`, add it to the `matches` array
    var max = 10;

    loop: for (var k = 0, nseries = seriesIndices.length; k < nseries; k++) {
      var pair = seriesIndices[k];
      for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
        var element = dataset.getValue(pair[0], j, pair[1]);
        if (element && element.toObject) {
          var object = element.toObject();
          if (field !== null) {
            var val = object[field];
            if (val != null) {
              var id = new morpheus.Identifier([val, field]);
              if (!set.has(id) && regex.test(val)) {
                set.add(id);
                if (set.size() === max) {
                  break loop;
                }
              }
            }
          } else { // search all fields
            for (var name in object) {
              var val = object[name];
              var id = new morpheus.Identifier([val, name]);
              if (!set.has(id) && regex.test(val)) {
                set.add(id);
                if (set.size() === max) {
                  break loop;
                }
              }
            }
          }

        }
      }
    }
    set.forEach(function (id) {
      var array = id.getArray();
      var field = array[1];
      var val = array[0];
      matches.push({
        value: field + ':' + val,
        label: '<span style="font-weight:300;">' + field + ':</span>'
        + '<span style="font-weight:900;">' + val + '</span>'
      });

    });
    if (field == null) {
      fields.forEach(function (field) {
        if (regex.test(field)) {
          matches.push({
            value: field + ':',
            label: '<span style="font-weight:300;">' + field
            + ':</span>',
            show: true
          });
        }
      });
    }
    cb(matches);
  };

};
// morpheus.DatasetUtil.toJSON = function(dataset) {
// var json = [];
// json.push('{');
// json.push('"name":"' + dataset.getName() + '", ');
// json.push('"v":['); // row major 2d array
// for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
// if (i > 0) {
// json.push(',\n');
// }
// json.push('[');
// for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
// if (j > 0) {
// json.push(',');
// }
// json.push(JSON.stringify(dataset.getValue(i, j)));
// }
// json.push(']');
// }
// json.push(']'); // end v
// var metadatatoJSON = function(model) {
// json.push('[');
// for (var i = 0, count = model.getMetadataCount(); i < count; i++) {
// var v = model.get(i);
// if (i > 0) {
// json.push(',\n');
// }
// json.push('{');
// json.push('"id":"' + v.getName() + '"');
// json.push(', "v":[');
// for (var j = 0, nitems = v.size(); j < nitems; j++) {
// if (j > 0) {
// json.push(',');
// }
// json.push(JSON.stringify(v.getValue(j)));
// }
// json.push(']'); // end v array
// json.push('}');
// }
// json.push(']');
// };
// json.push(', "cols":');
// metadatatoJSON(dataset.getColumnMetadata());
// json.push(', "rows":');
// metadatatoJSON(dataset.getRowMetadata());
// json.push('}'); // end json object
// return json.join('');
// };
morpheus.DatasetUtil.fill = function (dataset, value, seriesIndex) {
  seriesIndex = seriesIndex || 0;
  for (var i = 0, nrows = dataset.getRowCount(), ncols = dataset
    .getColumnCount(); i < nrows; i++) {
    for (var j = 0; j < ncols; j++) {
      dataset.setValue(i, j, value, seriesIndex);
    }
  }
};

/**
 * Add an additional series to a dataset from another dataset.
 * @param options.dataset The dataset to add a series to
 * @param options.newDataset The dataset that is used as the source for the overlay
 * @param options.rowAnnotationName dataset row annotation name to use for matching
 * @param options.columnAnnotationName dataset column annotation name to use for matching
 * @param options.newRowAnnotationName newDataset row annotation name to use for matching
 * @param options.newColumnAnnotationName newDataset column annotation name to use for matching
 *
 */
morpheus.DatasetUtil.overlay = function (options) {
  var dataset = options.dataset;
  var newDataset = options.newDataset;
  var current_dataset_row_annotation_name = options.rowAnnotationName;
  var current_dataset_column_annotation_name = options.columnAnnotationName;
  var new_dataset_row_annotation_name = options.newRowAnnotationName;
  var new_dataset_column_annotation_name = options.newColumnAnnotationName;

  var rowValueToIndexMap = morpheus.VectorUtil
    .createValueToIndexMap(dataset
      .getRowMetadata()
      .getByName(
        current_dataset_row_annotation_name));
  var columnValueToIndexMap = morpheus.VectorUtil
    .createValueToIndexMap(dataset
      .getColumnMetadata()
      .getByName(
        current_dataset_column_annotation_name));
  var seriesIndex = dataset
    .addSeries({
      name: newDataset
        .getName(),
      dataType: newDataset.getDataType(0)
    });

  var rowVector = newDataset
    .getRowMetadata()
    .getByName(
      new_dataset_row_annotation_name);
  var rowIndices = [];
  var newDatasetRowIndicesSubset = [];
  for (var i = 0, size = rowVector
    .size(); i < size; i++) {
    var index = rowValueToIndexMap
      .get(rowVector
        .getValue(i));
    if (index !== undefined) {
      rowIndices.push(index);
      newDatasetRowIndicesSubset
        .push(i);
    }
  }

  var columnVector = newDataset
    .getColumnMetadata()
    .getByName(
      new_dataset_column_annotation_name);
  var columnIndices = [];
  var newDatasetColumnIndicesSubset = [];
  for (var i = 0, size = columnVector
    .size(); i < size; i++) {
    var index = columnValueToIndexMap
      .get(columnVector
        .getValue(i));
    if (index !== undefined) {
      columnIndices.push(index);
      newDatasetColumnIndicesSubset
        .push(i);
    }
  }
  newDataset = new morpheus.SlicedDatasetView(
    newDataset,
    newDatasetRowIndicesSubset,
    newDatasetColumnIndicesSubset);
  for (var i = 0, nrows = newDataset
    .getRowCount(); i < nrows; i++) {
    for (var j = 0, ncols = newDataset
      .getColumnCount(); j < ncols; j++) {
      dataset.setValue(
        rowIndices[i],
        columnIndices[j],
        newDataset
          .getValue(
            i,
            j),
        seriesIndex);

    }
  }
};
/**
 * Joins datasets by appending rows.
 * @param datasets
 * @param field
 * @return {morpheus.AbstractDataset} The joined dataset.
 */
morpheus.DatasetUtil.join = function (datasets, field) {
  if (datasets.length === 0) {
    throw 'No datasets';
  }
  if (datasets.length === 1) {
    var name = datasets[0].getName();
    var sourceVector = datasets[0].getRowMetadata().add('Source');
    for (var i = 0, size = sourceVector.size(); i < size; i++) {
      sourceVector.setValue(i, name);
    }
    return datasets[0];
  }
  // take union of all ids
  var ids = new morpheus.Set();
  for (var i = 0; i < datasets.length; i++) {
    var idVector = datasets[i].getColumnMetadata().getByName(field);
    for (var j = 0, size = idVector.size(); j < size; j++) {
      ids.add(idVector.getValue(j));
    }
  }
  var dummyDataset = new morpheus.Dataset({
    rows: 0,
    columns: ids.size(),
    name: datasets[0].getName()
  });
  var dummyIdVector = dummyDataset.getColumnMetadata().add(field);
  var counter = 0;
  ids.forEach(function (id) {
    dummyIdVector.setValue(counter++, id);
  });

  var dataset = new morpheus.JoinedDataset(
    dummyDataset, datasets[0], field,
    field);
  for (var i = 1; i < datasets.length; i++) {
    dataset = new morpheus.JoinedDataset(dataset,
      datasets[i], field, field);
  }
  return dataset;
};
morpheus.DatasetUtil.shallowCopy = function (dataset) {
  // make a shallow copy of the dataset, metadata is immutable via the UI
  var rowMetadataModel = morpheus.MetadataUtil.shallowCopy(dataset
    .getRowMetadata());
  var columnMetadataModel = morpheus.MetadataUtil.shallowCopy(dataset
    .getColumnMetadata());
  dataset.getRowMetadata = function () {
    return rowMetadataModel;
  };
  dataset.getColumnMetadata = function () {
    return columnMetadataModel;
  };
  return dataset;
};

morpheus.DatasetUtil.copy = function (dataset) {
  var newDataset = new morpheus.Dataset({
    name: dataset.getName(),
    rows: dataset.getRowCount(),
    columns: dataset.getColumnCount(),
    dataType: dataset.getDataType(0)
  });
  for (var seriesIndex = 0,
         nseries = dataset.getSeriesCount(); seriesIndex < nseries; seriesIndex++) {
    if (seriesIndex > 0) {
      newDataset.addSeries({
        name: dataset.getName(seriesIndex),
        rows: dataset.getRowCount(),
        columns: dataset.getColumnCount(),
        dataType: dataset.getDataType(seriesIndex)
      });
    }
    for (var i = 0, nrows = dataset.getRowCount(), ncols = dataset
      .getColumnCount(); i < nrows; i++) {
      for (var j = 0; j < ncols; j++) {
        newDataset.setValue(i, j, dataset.getValue(i, j, seriesIndex),
          seriesIndex);
      }
    }
  }
  var rowMetadataModel = morpheus.MetadataUtil.shallowCopy(dataset
    .getRowMetadata());
  var columnMetadataModel = morpheus.MetadataUtil.shallowCopy(dataset
    .getColumnMetadata());
  newDataset.getRowMetadata = function () {
    return rowMetadataModel;
  };
  newDataset.getColumnMetadata = function () {
    return columnMetadataModel;
  };
  if (dataset.getESSession()) {
    newDataset.setESSession(dataset.getESSession());
  }
  return newDataset;
};
morpheus.DatasetUtil.toString = function (dataset, value, seriesIndex) {
  seriesIndex = seriesIndex || 0;
  var s = [];
  for (var i = 0, nrows = dataset.getRowCount(), ncols = dataset
    .getColumnCount(); i < nrows; i++) {
    for (var j = 0; j < ncols; j++) {
      if (j > 0) {
        s.push(', ');
      }
      s.push(morpheus.Util.nf(dataset.getValue(i, j, seriesIndex)));
    }
    s.push('\n');
  }
  return s.join('');
};
morpheus.DatasetUtil.getNonEmptyRows = function (dataset) {
  var rowsToKeep = [];
  for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
    var keep = false;
    for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
      var value = dataset.getValue(i, j);
      if (!isNaN(value)) {
        keep = true;
        break;
      }
    }
    if (keep) {
      rowsToKeep.push(i);
    }
  }
  return rowsToKeep;
};
morpheus.DatasetUtil.getContentArray = function (dataset) {

  var array = [];
  var nr = dataset.rows;
  var nc = dataset.columns;
  console.log("getContentArray ::", "dataset:", dataset, "rows:", nr, "columns:", nc);

  for (var i = 0; i < nr; i++) {
    for (var j = 0; j < nc; j++) {
      array.push(dataset.getValue(i, j));
    }
  }
  console.log("getContentArray ::", array);
  return array;
};
morpheus.DatasetUtil.getMetadataArray = function (dataset) {
  var pDataArray = [];
  var participantID = [];
  var labelDescription = [];
  //console.log("morpheus.DatasetUtil.getMetadataArray ::", dataset);
  var columnMeta = dataset.getColumnMetadata();
  var features = columnMeta.getMetadataCount();
  var participants = dataset.getColumnCount();
  var vecPartID;

  if (columnMeta.getByName("participant_id") != null) {
    vecPartID = columnMeta.getByName("participant_id");
  }
  else {
    vecPartID = columnMeta.getByName("id");
  }
  for (var i = 0; i < participants; i++) {
    participantID.push({
      strval: vecPartID ? vecPartID.getValue(i) : i.toString(),
      isNA: false
    });
  }
  for (var j = 0; j < features; j++) {
    var vecJ = columnMeta.get(j);
    if (vecJ.getName() == "participant_id" || vecJ.getName() == "id") {
      continue;
    }
    for (var l = 0; l < participants; l++) {
      pDataArray.push({
        strval: vecJ.getValue(l).toString(),
        isNA: false
      });
    }
    labelDescription.push({
      strval: vecJ.getName(),
      isNA: false
    });
  }

  var rowMeta = dataset.getRowMetadata();
  var rowNames = [];
  var rowNamesVec = rowMeta.getByName("id");
  if (rowNamesVec) {
    for (j = 0; j < dataset.getRowCount(); j++) {
      rowNames.push({
        strval: rowNamesVec.getValue(j),
        isNA: false
      });
    }
  }
  var symbolNames = rowMeta.getByName("symbol");
  console.log(symbolNames);
  var symbol = [];

  if (symbolNames) {
    for (j = 0; j < dataset.getRowCount(); j++) {
      symbol.push({
        strval: symbolNames.getValue(j),
        isNA: false
      });
    }
  }
  else {
    symbol = rowNames;
  }
  return {
    pdata: pDataArray,
    participants: participantID,
    labels: labelDescription,
    rownames: rowNames,
    symbol: symbol
  };
};

morpheus.DatasetUtil.toESSessionPromise = function (options) {
  var dataset = options.dataset ? options.dataset : options;

  console.log("ENTERED TO_ESSESSION_PROMISE", dataset, options);
  //var copiedDataset = morpheus.DatasetUtil.copy(dataset);
  //console.log("EsSessionPromise ::", "after copying", dataset);
  while (dataset.dataset) {
    dataset = dataset.dataset;
  }
  dataset.setESSession(new Promise(function (resolve, reject) {
    //console.log("morpheus.DatasetUtil.toESSessionPromise ::", dataset, dataset instanceof morpheus.Dataset, dataset instanceof morpheus.SlicedDatasetView);
    /*		if (dataset.dataset) {
     //console.log("morpheus.DatasetUtil.toESSessionPromise ::", "dataset in instanceof morpheus.SlicedDatasetView", "go deeper");
     morpheus.DatasetUtil.toESSessionPromise(dataset.dataset);
     }*/
    if (options.isGEO) {
      resolve(dataset.getESSession());
      return;
    }

    var array = morpheus.DatasetUtil.getContentArray(dataset);
    var meta = morpheus.DatasetUtil.getMetadataArray(dataset);

    console.log(array, meta);
    var messageJSON = {
      rclass: "LIST",
      rexpValue: [{
        rclass: "REAL",
        realValue: array,
        attrName: "dim",
        attrValue: {
          rclass: "INTEGER",
          intValue: [dataset.getColumnCount(), dataset.getRowCount()]
        }
      }, {
        rclass: "STRING",
        stringValue: meta.pdata,
        attrName: "dim",
        attrValue: {
          rclass: "INTEGER",
          intValue: [dataset.getColumnCount(), meta.pdata.length / dataset.getColumnCount()]
        }
      }, {
        rclass: "STRING",
        stringValue: meta.labels
      }, {
        rclass: "STRING",
        stringValue: meta.participants
      }, {
        rclass: "STRING",
        stringValue: meta.rownames
      }, {
        rclass: "STRING",
        stringValue: meta.symbol
      }],
      attrName: "names",
      attrValue: {
        rclass: "STRING",
        stringValue: [{
          strval: "data",
          isNA: false
        }, {
          strval: "pData",
          isNA: false
        }, {
          strval: "labelDescription",
          isNA: false
        }, {
          strval: "colNames",
          isNA: false
        }, {
          strval: "rowNames",
          isNA: false
        }, {
          strval: "symbol",
          isNA: false
        }]
      }
    };
    var ProtoBuf = dcodeIO.ProtoBuf;
    ProtoBuf.protoFromFile("./message.proto", function (error, success) {
      if (error) {
        alert(error);
        console.log("ExpressionSetCreation :: ", "ProtoBuilder failed", error);
        return;
      }
      //console.log("morpheus.DatasetUtil.toESSessionPromise ::", "protobuilder error", error);
      //console.log("morpheus.DatasetUtil.toESSessionPromise ::", "protobuilder success", success);
      var builder = success,
        rexp = builder.build("rexp"),
        REXP = rexp.REXP;

      var proto = new REXP(messageJSON);
      var req = ocpu.call("createES", proto, function (session) {
        //console.log("morpheus.DatasetUtil.toESSessionPromise ::", "from successful request", session);
        resolve(session);
      }, true);

      req.fail(function () {
        reject(req.responseText);
      });
    });
  }));
  /*var blob = new Blob([new Uint8Array((new REXP(messageJSON)).toArrayBuffer())], {type: "application/octet-stream"});
   saveAs(blob, "test1.bin");*/
};
/**
 * Default implementation of a dataset.
 *
 * @extends {morpheus.AbstractDataset}
 * @param options.rows {number} Number of rows
 * @param options.columns {number} Number of columns
 * @param options.name {string} Dataset name
 * @param options.dataType {string=} Data type that 1st series holds.
 * @param options.esSession {Promise} openCPU session, which contains ExpressionSet version of the dataset
 * @constructor
 */
morpheus.Dataset = function (options) {
  morpheus.AbstractDataset.call(this, options.rows,
    options.columns);

  if (options.dataType == null) {
    options.dataType = 'Float32';
  }

  if (options.esSession) {
    this.esSession = options.esSession;
  }
  this.seriesNames.push(options.name);
  this.seriesArrays.push(options.array ? options.array : morpheus.Dataset
    .createArray(options));
  this.seriesDataTypes.push(options.dataType);
  //console.log(this);
};
/**
 *
 * @param dataset
 * @param options.rowFields
 * @param options.columnFields
 * @param options.seriesIndices
 * @return JSON representation of a dataset
 */
morpheus.Dataset.toJSON = function (dataset, options) {
  options = options || {};
  var seriesArrays = [];
  var seriesDataTypes = [];
  var seriesNames = [];
  var seriesIndices = options.seriesIndices;
  if (seriesIndices == null) {
    seriesIndices = morpheus.Util.sequ32(dataset.getSeriesCount());
  }
  for (var series = 0; series < seriesIndices.length; series++) {
    var seriesIndex = seriesIndices[series];
    seriesNames.push(dataset.getName(seriesIndex));
    seriesDataTypes.push(dataset.getDataType(seriesIndex));
    var data = [];
    seriesArrays.push(data);
    for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
      var row = [];
      data.push(row);
      for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
        row[j] = dataset.getValue(i, j, seriesIndex);
      }
    }
  }
  var vectortoJSON = function (vector) {
    var array = [];
    for (var i = 0, size = vector.size(); i < size; i++) {
      array[i] = vector.getValue(i);
    }
    var properties = new morpheus.Map();
    vector.getProperties().forEach(function (value, key) {
      if (morpheus.VectorKeys.JSON_WHITELIST.has(key)) {
        properties.set(key, value);
      }
    });
    return {
      properties: properties,
      name: vector.getName(),
      array: array
    };
  };
  var metadatatoJSON = function (metadata, fields) {
    var vectors = [];
    var filter;
    if (fields) {
      filter = new morpheus.Set();
      fields.forEach(function (field) {
        filter.add(field);
      });
    }
    for (var i = 0, count = metadata.getMetadataCount(); i < count; i++) {
      var v = metadata.get(i);
      if (filter) {
        if (filter.has(v.getName())) {
          vectors.push(vectortoJSON(v));
        }
      } else {
        vectors.push(vectortoJSON(v));
      }
    }
    return vectors;
  };
  return {
    rows: dataset.getRowCount(),
    columns: dataset.getColumnCount(),
    seriesArrays: seriesArrays,
    seriesDataTypes: seriesDataTypes,
    seriesNames: seriesNames,
    rowMetadataModel: {
      vectors: metadatatoJSON(dataset.getRowMetadata(),
        options.rowFields)
    },
    columnMetadataModel: {
      vectors: metadatatoJSON(dataset.getColumnMetadata(),
        options.columnFields)
    }
  };
};
morpheus.Dataset.fromJSON = function (options) {
  // Object {seriesNames:
  // Array[1], seriesArrays:
  // Array[1], rows:
  // 6238, columns: 7251,
  // rowMetadataModel: Object…}
  // columnMetadataModel: Object
  // itemCount: 7251
  // vectors: Array[3]
  // array: Array[7251]
  // n: 7251
  // name: "pert_id"
  // properties: Object
  // columns: 7251
  // rowMetadataModel: Object
  // rows: 6238
  // seriesArrays: Array[1]
  // seriesNames: Array[1]
  // var array = morpheus.Dataset.createArray(options);
  // for (var i = 0; i < options.rows; i++) {
  // var row = array[i];
  // var jsonRow = options.array[i];
  // for (var j = 0; j < options.columns; j++) {
  // row[j] = jsonRow[j];
  // }
  // }

  if (options.seriesMappings) {
    for (var seriesIndex = 0; seriesIndex < options.seriesMappings.length; seriesIndex++) {
      // map ordinal values
      if (options.seriesMappings[seriesIndex]) {

        var map = options.seriesMappings[seriesIndex]; // e.g. foo:1, bar:3
        var valueMap = new morpheus.Map();
        for (var key in map) {
          var value = map[key];
          valueMap.set(value, morpheus.Util.wrapNumber(value, key));
        }

        var array = options.seriesArrays[seriesIndex];
        for (var i = 0; i < options.rows; i++) {
          for (var j = 0; j < options.columns; j++) {
            var value = array[i][j];
            array[i][j] = valueMap.get(value);
          }
        }
        options.seriesDataTypes[seriesIndex] = 'Number';
      }
    }
  }
  var dataset = new morpheus.Dataset({
    name: options.seriesNames[0],
    dataType: options.seriesDataTypes[0],
    array: options.seriesArrays[0],
    rows: options.rows,
    columns: options.columns
  });

  if (options.rowMetadataModel) {
    options.rowMetadataModel.vectors.forEach(function (v) {
      var vector = new morpheus.Vector(v.name, dataset.getRowCount());
      vector.array = v.array;
      vector.properties = morpheus.Map.fromJSON(v.properties);
      dataset.rowMetadataModel.vectors.push(vector);
    });
  }
  if (options.columnMetadataModel) {
    options.columnMetadataModel.vectors.forEach(function (v) {
      var vector = new morpheus.Vector(v.name, dataset.getColumnCount());
      vector.array = v.array;
      vector.properties = morpheus.Map.fromJSON(v.properties);
      dataset.columnMetadataModel.vectors.push(vector);

    });
  }
  for (var i = 1; i < options.seriesArrays.length; i++) {
    dataset.addSeries({
      name: options.seriesNames[i],
      dataType: options.seriesDataTypes[i],
      array: options.seriesArrays[i]
    });
  }
  return dataset;
};
morpheus.Dataset.createArray = function (options) {
  var array = [];
  if (options.dataType == null || options.dataType === 'Float32') {
    for (var i = 0; i < options.rows; i++) {
      array.push(new Float32Array(options.columns));
    }
  } else if (options.dataType === 'Int8') {
    for (var i = 0; i < options.rows; i++) {
      array.push(new Int8Array(options.columns));
    }
  } else if (options.dataType === 'Int16') {
    for (var i = 0; i < options.rows; i++) {
      array.push(new Int16Array(options.columns));
    }
  } else { // [object, number, Number] array of arrays
    for (var i = 0; i < options.rows; i++) {
      array.push([]);
    }
  }
  return array;
};
morpheus.Dataset.prototype = {
  getValue: function (i, j, seriesIndex) {
    seriesIndex = seriesIndex || 0;
    return this.seriesArrays[seriesIndex][i][j];
  },
  toString: function () {
    return this.getName();
  },
  setValue: function (i, j, value, seriesIndex) {
    seriesIndex = seriesIndex || 0;
    this.seriesArrays[seriesIndex][i][j] = value;
  },
  addSeries: function (options) {
    options = $.extend({}, {
      rows: this.getRowCount(),
      columns: this.getColumnCount(),
      dataType: 'Float32'
    }, options);
    this.seriesDataTypes.push(options.dataType);
    this.seriesNames.push(options.name);
    this.seriesArrays.push(options.array != null ? options.array
      : morpheus.Dataset.createArray(options));
    return this.seriesNames.length - 1;
  },
  setESSession: function (session) {
    //console.log("morpheus.Dataset.prototype.setESSession ::", this, session);
    this.esSession = session;
  },
  getESSession: function () {
    //console.log("morpheus.Dataset.prototype.getESSession ::", this);
    return this.esSession;
  }

};
morpheus.Util.extend(morpheus.Dataset, morpheus.AbstractDataset);

morpheus.ElementSelectionModel = function (project) {
  this.viewIndices = new morpheus.Set();
  this.project = project;
};
morpheus.ElementSelectionModel.prototype = {
  click: function (rowIndex, columnIndex, add) {
    var id = new morpheus.Identifier([rowIndex, columnIndex]);
    var isSelected = this.viewIndices.has(id);
    if (add) {
      isSelected ? this.viewIndices.remove(id) : this.viewIndices.add(id);
    } else {
      this.viewIndices.clear();
      if (!isSelected) {
        this.viewIndices.add(id);
      }
    }
    this.trigger('selectionChanged');
  },
  getProject: function () {
    return this.project;
  },
  setViewIndices: function (indices) {
    this.viewIndices = indices;
    this.trigger('selectionChanged');
  },
  clear: function () {
    this.viewIndices = new morpheus.Set();
  },
  /**
   *
   * @returns {morpheus.Set}
   */
  getViewIndices: function () {
    return this.viewIndices;
  },
  count: function () {
    return this.viewIndices.size();
  },
  toModelIndices: function () {
    var project = this.project;
    var modelIndices = [];
    this.viewIndices.forEach(function (id) {
      modelIndices.push(project
        .convertViewRowIndexToModel(id.getArray()[0]), project
        .convertViewColumnIndexToModel(id.getArray()[1]));
    });
    return modelIndices;
  },
  save: function () {
    this.modelIndices = this.toModelIndices();
  },
  restore: function () {
    var project = this.project;
    this.viewIndices = new morpheus.Set();
    for (var i = 0, length = this.modelIndices.length; i < length; i++) {
      var rowIndex = project
        .convertModelRowIndexToView(this.modelIndices[i][0]);
      var columnIndex = project
        .convertModelColumnIndexToView(this.modelIndices[i][1]);
      if (rowIndex !== -1 && columnIndex !== -1) {
        this.viewIndices.add(new morpheus.Identifier([rowIndex,
          columnIndex]));
      }
    }
  }
};
morpheus.Util.extend(morpheus.ElementSelectionModel, morpheus.Events);

morpheus.CombinedFilter = function (isAndFilter) {
  this.filters = [];
  this.isAndFilter = isAndFilter;
  this.enabledFilters = [];
  this.name = 'combined filter';
};

morpheus.CombinedFilter.prototype = {
  shallowClone: function () {
    var f = new morpheus.CombinedFilter(this.isAndFilter);
    f.filters = this.filters.slice(0);
    return f;
  },
  isColumns: function () {
    return this.filters[0].isColumns();
  },
  toString: function () {
    return this.name;
  },
  setAnd: function (isAndFilter, notify) {
    this.isAndFilter = isAndFilter;
    if (notify) {
      this.trigger('and', {});
    }
  },
  isAnd: function () {
    return this.isAndFilter;
  },
  equals: function (f) {
    if (!(f instanceof morpheus.CombinedFilter)) {
      return false;
    }
    if (this.isAndFilter !== f.isAndFilter) {
      return false;
    }
    if (this.filters.length !== f.filters.length) {
      return false;
    }
    for (var i = 0, length = this.filters.length; i < length; i++) {
      if (!this.filters[i].equals(f.filters[i])) {
        return false;
      }
    }
    return true;
  },
  add: function (filter, notify) {
    this.filters.push(filter);
    if (notify) {
      this.trigger('add', {
        filter: filter
      });
    }
  },
  getFilters: function () {
    return this.filters;
  },
  get: function (index) {
    return this.filters[index];
  },
  indexOf: function (name, type) {
    for (var i = 0, length = this.filters.length; i < length; i++) {
      if (this.filters[i].toString() === name
        && (type == null ? true : this.filters[i] instanceof type)) {
        return i;
      }
    }
    return -1;
  },
  remove: function (index, notify) {
    this.filters.splice(index, 1);
    if (notify) {
      this.trigger('remove', {
        index: index
      });
    }
  },
  set: function (index, filter) {
    this.filters[index] = filter;
  },
  insert: function (index, filter) {
    this.filters.splice(index, 0, filter);
  },
  clear: function () {
    this.filters = [];
  },
  init: function (dataset) {
    for (var i = 0, nfilters = this.filters.length; i < nfilters; i++) {
      if (this.filters[i].isColumns()) { // all filters operate on rows
        this.filters[i].init(new morpheus.TransposedDatasetView(dataset));
      } else {
        this.filters[i].init(dataset);
      }

    }
    this.enabledFilters = this.filters.filter(function (filter) {
      return filter.isEnabled();
    });
  },
  accept: function (index) {
    var filters = this.enabledFilters;
    if (this.isAndFilter) {
      for (var i = 0, nfilters = filters.length; i < nfilters; i++) {
        if (filters[i].accept(index) === false) {
          return false;
        }
      }
      return true;
    } else {
      for (var i = 0, nfilters = filters.length; i < nfilters; i++) {
        if (filters[i].accept(index)) {
          return true;
        }
      }
      return false;
    }
  },
  isEnabled: function () {
    return this.enabledFilters.length > 0;
  }
};
morpheus.Util.extend(morpheus.CombinedFilter, morpheus.Events);
/**
 * @param acceptIndicesSet
 *            a morpheus.Set that contains the model indices in the dataset to
 *            retain.
 */
morpheus.IndexFilter = function (acceptIndicesSet, name, isColumns) {
  this.acceptIndicesSet = acceptIndicesSet;
  this.name = name;
  this.columns = isColumns;
};
morpheus.IndexFilter.prototype = {
  enabled: true,
  isColumns: function () {
    return this.columns;
  },
  isEnabled: function () {
    return this.enabled;
  },
  setAcceptIndicesSet: function (acceptIndicesSet) {
    this.acceptIndicesSet = acceptIndicesSet;
  },
  setEnabled: function (enabled) {
    this.enabled = enabled;
  },
  equals: function (filter) {
    return filter instanceof morpheus.IndexFilter
      && this.acceptIndicesSet.equals(filter.acceptIndicesSet);
  },
  init: function (dataset) {
  },
  toString: function () {
    return this.name;
  },
  /**
   *
   * @param index
   *            The model index in the dataset
   * @returns {Boolean} true if index passes filter
   */
  accept: function (index) {
    return this.acceptIndicesSet.has(index);
  }
};
morpheus.VectorFilter = function (set, maxSetSize, name, isColumns) {
  this.set = set;
  this.name = name;
  this.maxSetSize = maxSetSize;
  this.columns = isColumns;
};

morpheus.VectorFilter.prototype = {
  enabled: true,
  isColumns: function () {
    return this.columns;
  },
  isEnabled: function () {
    return this.enabled && this.set.size() > 0
      && this.set.size() !== this.maxSetSize && this.vector != null;
  },
  setEnabled: function (enabled) {
    this.enabled = enabled;
  },
  equals: function (filter) {
    return filter instanceof morpheus.VectorFilter
      && this.name === filter.name;
  },
  init: function (dataset) {
    this.vector = dataset.getRowMetadata().getByName(this.name);
  },
  toString: function () {
    return this.name;
  },
  /**
   *
   * @param index
   *            The model index in the dataset
   * @returns {Boolean} true if index passes filter
   */
  accept: function (index) {
    return this.set.has(this.vector.getValue(index));
  }
};

morpheus.NotNullFilter = function (name, isColumns) {
  this.name = name;
  this.columns = isColumns;
};
morpheus.NotNullFilter.prototype = {
  enabled: true,
  isColumns: function () {
    return this.columns;
  },
  isEnabled: function () {
    return this.enabled && this.vector != null;
  },
  setEnabled: function (enabled) {
    this.enabled = enabled;
  },
  equals: function (filter) {
    return filter instanceof morpheus.NotNullFilter
      && this.name === filter.name;
  },
  init: function (dataset) {
    this.vector = dataset.getRowMetadata().getByName(this.name);
  },
  toString: function () {
    return this.name;
  },
  /**
   *
   * @param index
   *            The model index in the dataset
   * @returns {Boolean} true if index passes filter
   */
  accept: function (index) {
    return this.vector.getValue(index) != null;
  }
};

morpheus.RangeFilter = function (min, max, name, isColumns) {
  this.min = min;
  this.max = max;
  this.name = name;
  this.columns = isColumns;
};

morpheus.RangeFilter.prototype = {
  enabled: true,
  isColumns: function () {
    return this.columns;
  },
  isEnabled: function () {
    return this.enabled && (!isNaN(this.min) || !isNaN(this.max))
      && this.vector;
  },
  setEnabled: function (enabled) {
    this.enabled = enabled;
  },
  setMin: function (value) {
    this.min = isNaN(value) ? -Number.MAX_VALUE : value;
  },
  setMax: function (value) {
    this.max = isNaN(value) ? Number.MAX_VALUE : value;
  },
  equals: function (filter) {
    return filter instanceof morpheus.RangeFilter
      && this.name === filter.name;
  },
  init: function (dataset) {
    this.vector = dataset.getRowMetadata().getByName(this.name);

  },
  toString: function () {
    return this.name;
  },
  /**
   *
   * @param index
   *            The model index in the dataset
   * @returns {Boolean} true if index passes filter
   */
  accept: function (index) {
    var value = this.vector.getValue(index);
    return value >= this.min && value <= this.max;
  }
};

morpheus.TopNFilter = function (n, direction, name, isColumns) {
  this.n = n;
  this.direction = direction;
  this.name = name;
  this.columns = isColumns;
};

morpheus.TopNFilter.TOP = 0;
morpheus.TopNFilter.BOTTOM = 1;
morpheus.TopNFilter.TOP_BOTTOM = 2;
morpheus.TopNFilter.prototype = {
  enabled: true,
  isColumns: function () {
    return this.columns;
  },
  isEnabled: function () {
    return this.enabled && this.n > 0 && this.vector;
  },
  setEnabled: function (enabled) {
    this.enabled = enabled;
  },
  setN: function (value) {
    this.n = value;
  },
  /**
   *
   * @param direction
   *            one of '
   */
  setDirection: function (direction) {
    this.direction = direction;
  },
  equals: function (filter) {
    return filter instanceof morpheus.TopNFilter
      && this.name === filter.name && this.n === filter.n
      && this.direction === filter.direction;
  },

  init: function (dataset) {
    if (!this.vector) {
      var vector = dataset.getRowMetadata().getByName(this.name);
      this.vector = vector;
      var set = new morpheus.Set();
      for (var i = 0, size = vector.size(); i < size; i++) {
        var value = vector.getValue(i);
        if (!isNaN(value)) {
          set.add(value);
        }
      }
      var values = set.values();
      // ascending order
      values.sort(function (a, b) {
        return (a === b ? 0 : (a < b ? -1 : 1));
      });
      this.sortedValues = values;
    }
    var topAndBottomIndices = [(this.sortedValues.length - this.n),
      (this.n - 1)];

    for (var i = 0; i < topAndBottomIndices.length; i++) {
      topAndBottomIndices[i] = Math.max(0, topAndBottomIndices[i]);
      topAndBottomIndices[i] = Math.min(this.sortedValues.length - 1,
        topAndBottomIndices[i]);
    }

    var topAndBottomValues = [this.sortedValues[topAndBottomIndices[0]],
      this.sortedValues[topAndBottomIndices[1]]];

    if (this.direction === morpheus.TopNFilter.TOP) {
      this.f = function (val) {
        return isNaN(val) ? false : val >= topAndBottomValues[0];
      };
    } else if (this.direction === morpheus.TopNFilter.BOTTOM) {
      this.f = function (val) {
        return isNaN(val) ? false : val <= topAndBottomValues[1];
      };
    } else {
      this.f = function (val) {
        return isNaN(val) ? false
          : (val >= topAndBottomValues[0] || val <= topAndBottomValues[1]);
      };
    }

  },
  /**
   *
   * @param index
   *            The model index in the dataset
   * @returns {Boolean} true if index passes filter
   */
  accept: function (index) {
    return this.f(this.vector.getValue(index));
  },
  toString: function () {
    return this.name;
  }
};

morpheus.AlwaysTrueFilter = function () {

};

morpheus.AlwaysTrueFilter.prototype = {
  isEnabled: function () {
    return false;
  },
  setEnabled: function (enabled) {

  },
  equals: function (filter) {
    return filter instanceof morpheus.AlwaysTrueFilter;

  },
  init: function (dataset) {

  },
  toString: function () {
    return 'AlwaysTrue';
  },
  /**
   *
   * @param index
   *            The model index in the dataset
   * @returns {Boolean} true if index passes filter
   */
  accept: function (index) {
    return true;
  }
};

morpheus.CombinedFilter.fromJSON = function (combinedFilter, json) {
  combinedFilter.setAnd(json.isAnd);
  json.filters.forEach(function (filter) {
    if (filter.type === 'set') {
      var set = new morpheus.Set();
      filter.values.forEach(function (value) {
        set.add(value);
      });
      combinedFilter.add(new morpheus.VectorFilter(
        set,
        filter.maxSetSize,
        filter.name,
        filter.isColumns
      ));
    } else if (filter.type === 'range') {
      combinedFilter.add(new morpheus.RangeFilter(
        filter.min,
        filter.max,
        filter.name,
        filter.isColumns
      ));
    } else if (filter.type === 'top') {
      combinedFilter.add(new morpheus.TopNFilter(
        filter.n,
        filter.direction,
        filter.name,
        filter.isColumns
      ));
    } else if (filter.type === 'index') {
      var set = new morpheus.Set();
      filter.indices.forEach(function (value) {
        set.add(value);
      });
      combinedFilter.add(new morpheus.IndexFilter(
        set,
        filter.name,
        filter.isColumns
      ));
    } else {
      console.log('Unknown filter type');
    }
  });
};

morpheus.CombinedFilter.toJSON = function (filter) {
  var json = {
    isAnd: filter.isAnd(),
    filters: []
  };
  filter.getFilters().forEach(function (filter) {
    if (filter.isEnabled()) {
      if (filter instanceof morpheus.VectorFilter) {
        // morpheus.VectorFilter = function (set, maxSetSize, name, isColumns)
        json.filters.push({
          name: filter.name,
          isColumns: filter.isColumns(),
          values: filter.set.values(),
          maxSetSize: filter.maxSetSize,
          type: 'set'
        });
      } else if (filter instanceof morpheus.RangeFilter) {
        // morpheus.RangeFilter = function (min, max, name, isColumns)
        json.filters.push({
          name: filter.name,
          isColumns: filter.isColumns(),
          min: filter.min,
          max: filter.max,
          type: 'range'
        });
      } else if (filter instanceof morpheus.TopNFilter) {
        // morpheus.TopNFilter = function (n, direction, name, isColumns)
        json.filters.push({
          name: filter.name,
          isColumns: filter.isColumns(),
          min: filter.n,
          max: filter.direction,
          type: 'top'
        });
      } else if (filter instanceof morpheus.IndexFilter) {
        // morpheus.IndexFilter = function (acceptIndicesSet, name, isColumns
        json.filters.push({
          name: filter.name,
          isColumns: filter.isColumns(),
          indices: filter.acceptIndicesSet.values(),
          type: 'index'
        });
      }
    }
  });
  return json;
};

morpheus.IndexMapper = function (project, isRows) {
  this.project = project;
  this.isRows = isRows;
  this.sortKeys = [];
  /**
   * {morpheus.Map} Maps from model index to view index. Note that not all
   * model indices are contained in the map because they might have been
   * filtered from the view.
   */
  this.modelToView = null;
  /** {Array} filtered model indices */
  this.filteredModelIndices = null;
  /** {Array} sorted and filtered model indices */
  this.filteredSortedModelIndices = null;
  this.filter = new morpheus.CombinedFilter(true);
  this._filter();
  this._sort();
};

morpheus.IndexMapper.prototype = {
  convertModelIndexToView: function (modelIndex) {
    var index = this.modelToView.get(modelIndex);
    return index !== undefined ? index : -1;
  },
  convertViewIndexToModel: function (viewIndex) {
    return (viewIndex < this.filteredSortedModelIndices.length
    && viewIndex >= 0 ? this.filteredSortedModelIndices[viewIndex]
      : -1);
  },
  convertToView: function () {
    return this.filteredSortedModelIndices;
  },
  setFilter: function (filter) {
    this.filter = filter;
    this._filter();
    this._sort();
  },
  _filter: function () {
    var filter = this.filter;
    var dataset = this.project.getFullDataset();
    var count = this.isRows ? dataset.getRowCount() : dataset.getColumnCount();
    var filteredModelIndices;
    if (filter != null) {
      filter.init(dataset); // filter needs to transpose if columns
      if (filter.isEnabled()) {
        filteredModelIndices = [];

        for (var i = 0; i < count; i++) {
          if (filter.accept(i)) {
            filteredModelIndices.push(i);
          }
        }
      }
    }

    this.filteredModelIndices = filteredModelIndices != null ? filteredModelIndices
      : morpheus.Util.seq(count);
  },
  _sort: function () {
    var sortKeys = this.sortKeys;
    if (sortKeys.length > 0) {
      var dataset = this.project.getFullDataset();

      var nkeys = sortKeys.length;
      for (var i = 0; i < nkeys; i++) {
        sortKeys[i].init(sortKeys[i].isColumns() ? new morpheus.TransposedDatasetView(dataset) : dataset, this.filteredSortedModelIndices);
      }
      this.filteredSortedModelIndices = this.filteredModelIndices
        .slice(0);
      this.filteredSortedModelIndices.sort(function (a, b) {
        for (var i = 0; i < nkeys; i++) {
          var key = sortKeys[i];
          var comparator = key.getComparator();
          var val1 = key.getValue(a);
          var val2 = key.getValue(b);
          var c = comparator(val1, val2);
          if (c !== 0) {
            return c;
          }
        }
        return 0;
      });
    } else {
      this.filteredSortedModelIndices = this.filteredModelIndices;
    }

    var modelToView = new morpheus.Map();
    for (var i = 0, length = this.filteredSortedModelIndices.length; i < length; i++) {
      modelToView.set(this.filteredSortedModelIndices[i], i);
    }
    this.modelToView = modelToView;
  },
  getFilter: function () {
    return this.filter;
  },
  getViewCount: function () {
    if (this.project.getFullDataset() == null) {
      return 0;
    }
    return this.filteredSortedModelIndices.length;
  },
  setSelectedModelIndices: function (selectedModelIndices) {
    this.selectionModel.setSelectedModelIndices(selectedModelIndices);
  },
  setSortKeys: function (sortKeys) {
    if (sortKeys == null) {
      sortKeys = [];
    }
    this.sortKeys = sortKeys;
    this._sort();
  }
};

/**
 * Adds rows in dataset2 to dataset1
 */
morpheus.JoinedDataset = function (dataset1, dataset2, dataset1Field,
                                   dataset2Field, sourceFieldName) {
  sourceFieldName = sourceFieldName || 'Source';
  this.dataset1Field = dataset1Field;
  this.dataset2Field = dataset2Field;
  if (dataset1 == null) {
    throw 'dataset1 is null';
  }
  if (dataset2 == null) {
    throw 'dataset2 is null';
  }
  if (dataset1Field) { // reorder dataset 2 to match dataset 1
    var v1 = dataset1.getColumnMetadata().getByName(dataset1Field);
    var dataset2ValueToIndex = morpheus.VectorUtil
      .createValueToIndexMap(dataset2.getColumnMetadata().getByName(
        dataset2Field));
    var dataset2ColumnIndices = [];
    for (var i = 0; i < v1.size(); i++) {
      dataset2ColumnIndices[i] = dataset2ValueToIndex.get(v1.getValue(i));
      // undefined indices are handles in SlicedDatasetWithNulls
    }
    dataset2 = new morpheus.SlicedDatasetWithNulls(dataset2,
      dataset2ColumnIndices, dataset1.getColumnCount(), dataset1
        .getColumnMetadata());
  }

  if (!dataset1.getRowMetadata().getByName(sourceFieldName)) {
    var sourceVector = dataset1.getRowMetadata().add(sourceFieldName);
    var name = dataset1.getName();
    for (var i = 0, nrows = sourceVector.size(); i < nrows; i++) {
      sourceVector.setValue(i, name);
    }
  }
  if (!dataset2.getRowMetadata().getByName(sourceFieldName)) {
    var sourceVector = dataset2.getRowMetadata().add(sourceFieldName);
    var name = dataset2.getName();
    for (var i = 0, nrows = sourceVector.size(); i < nrows; i++) {
      sourceVector.setValue(i, name);
    }

  }

  // make sure dataset1 and dataset2 have the same row metadata fields in the
  // same order
  for (var i = 0, count = dataset1.getRowMetadata().getMetadataCount(); i < count; i++) {
    var name = dataset1.getRowMetadata().get(i).getName();
    if (dataset2.getRowMetadata().getByName(name) == null) {
      dataset2.getRowMetadata().add(name);
    }
  }
  for (var i = 0, count = dataset2.getRowMetadata().getMetadataCount(); i < count; i++) {
    var name = dataset2.getRowMetadata().get(i).getName();
    if (dataset1.getRowMetadata().getByName(name) == null) {
      dataset1.getRowMetadata().add(name);
    }
  }

  // put dataset2 row metadata names in same order as dataset1
  var dataset2RowMetadataOrder = [];
  var metadataInDifferentOrder = false;
  for (var i = 0, count = dataset1.getRowMetadata().getMetadataCount(); i < count; i++) {
    var name = dataset1.getRowMetadata().get(i).getName();
    var index = morpheus.MetadataUtil.indexOf(dataset2.getRowMetadata(),
      name);
    dataset2RowMetadataOrder.push(index);
    if (index !== i) {
      metadataInDifferentOrder = true;
    }
  }
  this.dataset1 = dataset1;
  this.dataset2 = dataset2;
  // TODO put series in same order
  var maxSeriesCount = Math.max(this.dataset1.getSeriesCount(), this.dataset2
    .getSeriesCount());
  for (var i = this.dataset1.getSeriesCount(); i < maxSeriesCount; i++) {
    this.dataset1.addSeries({
      name: this.dataset2.getName(i)
    });
  }
  for (var i = this.dataset2.getSeriesCount(); i < maxSeriesCount; i++) {
    this.dataset2.addSeries({
      name: this.dataset1.getName(i)
    });
  }

  this.rowMetadata = new morpheus.JoinedMetadataModel(this.dataset1
    .getRowMetadata(), !metadataInDifferentOrder ? this.dataset2
    .getRowMetadata() : new morpheus.MetadataModelColumnView(
    this.dataset2.getRowMetadata(), dataset2RowMetadataOrder));
};
morpheus.JoinedDataset.prototype = {
  getName: function (seriesIndex) {
    return this.dataset1.getName(seriesIndex);
  },
  setName: function (seriesIndex, name) {
    this.dataset1.setName(seriesIndex, name);
  },
  getDataType: function (seriesIndex) {
    return this.dataset1.getDataType(seriesIndex);
  },
  getDatasets: function () {
    return [this.dataset1, this.dataset2];
  },
  getDataset1: function () {
    return this.dataset1;
  },
  getRowMetadata: function () {
    return this.rowMetadata;
  },
  getColumnMetadata: function () {
    return this.dataset1.getColumnMetadata();
  },
  getRowCount: function () {
    return this.dataset1.getRowCount() + this.dataset2.getRowCount();
  },
  getColumnCount: function () {
    return this.dataset1.getColumnCount();
  },
  getValue: function (i, j, seriesIndex) {
    return i < this.dataset1.getRowCount() ? this.dataset1.getValue(i, j,
      seriesIndex) : this.dataset2.getValue(i
      - this.dataset1.getRowCount(), j, seriesIndex);
  },
  setValue: function (i, j, value, seriesIndex) {
    i < this.dataset1.getRowCount() ? this.dataset1.setValue(i, j, value,
      seriesIndex) : this.dataset2.setValue(i
      - this.dataset1.getRowCount(), j, value, seriesIndex);
  },
  getSeriesCount: function () {
    return this.dataset1.getSeriesCount();
  },
  addSeries: function (options) {
    this.dataset1.addSeries(options);
    return this.dataset2.addSeries(options);
  },
  removeSeries: function (seriesIndex) {
    this.dataset1.removeSeries(seriesIndex);
    this.dataset2.removeSeries(seriesIndex);
  },
  toString: function () {
    return this.getName();
  }
};
morpheus.SlicedDatasetWithNulls = function (dataset, columnIndices, columnCount,
                                            columnMetadata) {
  morpheus.DatasetAdapter.call(this, dataset);
  this.columnIndices = columnIndices;
  this.columnCount = columnCount;
  this.columnMetadata = columnMetadata;
};
morpheus.SlicedDatasetWithNulls.prototype = {
  getColumnMetadata: function () {
    return this.columnMetadata;
  },
  getColumnCount: function () {
    return this.columnCount;
  },
  getValue: function (i, j, seriesIndex) {
    var index = this.columnIndices[j];
    return index === undefined ? undefined : this.dataset.getValue(i,
      index, seriesIndex);
  },
  setValue: function (i, j, value, seriesIndex) {
    var index = this.columnIndices[j];
    if (index !== undefined) {
      this.dataset.setValue(i, index, value, seriesIndex);
    } else {
      console.log(j + ' out of range');
    }
  }
};
morpheus.Util.extend(morpheus.SlicedDatasetWithNulls, morpheus.DatasetAdapter);
morpheus.JoinedVector = function (v1, v2) {
  this.v1 = v1;
  this.v2 = v2;
  morpheus.VectorAdapter.call(this, v1);
  this.properties = new morpheus.Map();
};
morpheus.JoinedVector.prototype = {
  setValue: function (i, value) {
    i < this.v1.size() ? this.v1.setValue(i, value) : this.v2.setValue(i
      - this.v1.size(), value);
  },
  getValue: function (i) {
    return i < this.v1.size() ? this.v1.getValue(i) : this.v2.getValue(i
      - this.v1.size());
  },
  size: function () {
    return this.v1.size() + this.v2.size();
  },
  getProperties: function () {
    return this.properties;
  }
};
morpheus.Util.extend(morpheus.JoinedVector, morpheus.VectorAdapter);
morpheus.JoinedMetadataModel = function (m1, m2) {
  this.m1 = m1;
  this.m2 = m2;
  this.vectors = [];
  for (var i = 0, count = m1.getMetadataCount(); i < count; i++) {
    var v1 = this.m1.get(i);
    var v2 = this.m2.get(i);
    var v = new morpheus.JoinedVector(v1, v2);
    // copy properties
    v1.getProperties().forEach(function (val, key) {
      if (!morpheus.VectorKeys.COPY_IGNORE.has(key)) {
        v.properties.set(key, val);
      }
    });
    v2.getProperties().forEach(function (val, key) {
      if (!morpheus.VectorKeys.COPY_IGNORE.has(key)) {
        v.properties.set(key, val);
      }
    });

    this.vectors.push(v);
  }
};
morpheus.JoinedMetadataModel.prototype = {
  add: function (name) {
    var index = morpheus.MetadataUtil.indexOf(this, name);
    var oldVector;
    if (index !== -1) {
      oldVector = this.remove(index);
    }
    var v = new morpheus.Vector(name, this.getItemCount());
    if (oldVector != null) {
      // copy properties
      oldVector.getProperties().forEach(function (val, key) {
        v.getProperties().set(key, val);
      });
      // copy values
      for (var i = 0, size = oldVector.size(); i < size; i++) {
        v.setValue(i, oldVector.getValue(i));
      }
    }
    this.vectors.push(v);
    return v;
  },
  getItemCount: function () {
    return this.m1.getItemCount() + this.m2.getItemCount();
  },
  get: function (index) {
    return this.vectors[index];
  },
  remove: function (index) {
    return this.vectors.splice(index, 1)[0];
  },
  getByName: function (name) {
    for (var i = 0, length = this.vectors.length; i < length; i++) {
      if (name === this.vectors[i].getName()) {
        return this.vectors[i];
      }
    }
  },
  getMetadataCount: function () {
    return this.vectors.length;
  }
};

/**
 *
 *@implements {morpheus.MetadataModelInterface}
 */
morpheus.MetadataModelAdapter = function (model) {
  this.model = model;
};
morpheus.MetadataModelAdapter.prototype = {
  add: function (name) {
    return this.model.add(name);
  },
  getItemCount: function () {
    return this.model.getItemCount();
  },
  get: function (index) {
    return this.model.get(index);
  },
  remove: function (index) {
    return this.model.remove(index);
  },
  getByName: function (name) {
    return this.model.getByName(name);
  },
  getMetadataCount: function () {
    return this.model.getMetadataCount();
  }
};

morpheus.MetadataModelColumnView = function (model, indices) {
  this.model = model;
  this.indices = indices;
};
morpheus.MetadataModelColumnView.prototype = {
  add: function (name) {
    var vector = this.model.add(name);
    var index = morpheus.MetadataUtil.indexOf(this.model, name);
    this.indices.push(index);
    return vector;
  },
  getMetadataCount: function () {
    return this.indices.length;
  },
  get: function (index) {
    if (index < 0 || index >= this.indices.length) {
      throw 'index out of bounds';
    }
    return this.model.get(this.indices[index]);
  },
  remove: function (index) {
    if (index < 0 || index >= this.indices.length) {
      throw 'index out of bounds';
    }
    var v = this.model.remove(this.indices[index]);
    this.indices.splice(index, 1);
    return v;
  },
  getByName: function (name) {
    var index = morpheus.MetadataUtil.indexOf(this, name);
    return index !== -1 ? this.get(index) : undefined;
  }
};
morpheus.Util.extend(morpheus.MetadataModelColumnView,
  morpheus.MetadataModelAdapter);

/**
 * Stores annotations for the rows or columns of a dataset.
 * @interface morpheus.MetadataModelInterface
 *
 */

/**
 * Appends the specified vector to this meta data. If an existing vector
 * with the same name already exists, it is removed and existing properties
 * and values copied to the new vector before appending the new vector.
 * @function
 * @name morpheus.MetadataModelInterface#add
 * @param name {String} The vector name to be inserted into this meta data instance.
 * @param options {object}
 * @return {morpheus.VectorInterface} the added vector.
 */

/**
 * Returns the number of items that a vector in this meta data model
 * contains.
 *
 * @function
 * @name morpheus.MetadataModelInterface#getItemCount
 * @return {number} the item count
 */

/**
 * Returns the vector at the specified metadata index.
 *
 * @function
 * @name morpheus.MetadataModelInterface#get
 * @param index {number} the metadata index
 * @return {morpheus.VectorInterface} the vector
 */

/**
 * Removes the column at the specified position in this meta data instance
 * Shifts any subsequent columns to the left (subtracts one from their
 * indices).
 *
 * @function
 * @name morpheus.MetadataModelInterface#remove
 * @param index {number} the meta data index to remove.
 * @return {morpheus.VectorInterface} the removed vector
 * @throws Error if index < 0 or >= getMetadataCount
 */

/**
 * Returns the vector witht the specified name.
 *
 * @function
 * @name morpheus.MetadataModelInterface#getByName
 * @param name {string} the vector name
 * @return {morpheus.VectorInterface} the vector
 */

/**
 * Returns the number of vectors in this meta data instance.
 *
 * @function
 * @name morpheus.MetadataModelInterface#getMetadataCount
 * @return {number} the number of vectors.
 */



morpheus.MetadataModelItemView = function (model, indices) {
  this.model = model;
  this.indices = indices;
};
morpheus.MetadataModelItemView.prototype = {
  add: function (name) {
    var v = this.model.add(name);
    return new morpheus.SlicedVector(v, this.indices);
  },
  getItemCount: function () {
    return this.indices.length;
  },
  get: function (index) {
    var v = this.model.get(index);
    if (v === undefined) {
      return undefined;
    }
    return new morpheus.SlicedVector(v, this.indices);
  },
  getByName: function (name) {
    var v = this.model.getByName(name);
    if (v === undefined) {
      return undefined;
    }
    return new morpheus.SlicedVector(v, this.indices);
  },
  getMetadataCount: function () {
    return this.model.getMetadataCount();
  }
};
morpheus.Util.extend(morpheus.MetadataModelItemView,
  morpheus.MetadataModelAdapter);

/**
 * Creates a new meta data model instance.
 *
 * @param itemCount {number}
 *            the number of items that vectors in this instances will hold.
 * @implements {morpheus.MetadataModelInterface}
 * @constructor
 */
morpheus.MetadataModel = function (itemCount) {
  this.itemCount = itemCount;
  this.vectors = [];
};
morpheus.MetadataModel.prototype = {
  add: function (name, options) {
    var index = morpheus.MetadataUtil.indexOf(this, name);
    var oldVector;
    if (index !== -1) {
      oldVector = this.remove(index);
    }
    var v = new morpheus.Vector(name, this.getItemCount());
    if (oldVector != null) {
      // copy properties?
//			oldVector.getProperties().forEach(function(val, key) {
//				if (!morpheus.VectorKeys.COPY_IGNORE.has(key)) {
//					v.getProperties().set(key, val);
//				}
//
//			});
      // copy values
      for (var i = 0, size = oldVector.size(); i < size; i++) {
        var val = oldVector.getValue(i);
        v.setValue(i, val);
      }
    }
    this.vectors.push(v);
    return v;
  },
  getItemCount: function () {
    return this.itemCount;
  },
  get: function (index) {
    if (index < 0 || index >= this.vectors.length) {
      throw 'index ' + index + ' out of range';
    }
    return this.vectors[index];
  },
  remove: function (index) {
    if (index < 0 || index >= this.vectors.length) {
      throw 'index ' + index + ' out of range';
    }
    return this.vectors.splice(index, 1)[0];
  },
  getByName: function (name) {
    var index = morpheus.MetadataUtil.indexOf(this, name);
    return index !== -1 ? this.get(index) : undefined;
  },
  getMetadataCount: function () {
    return this.vectors.length;
  }
};

morpheus.MetadataUtil = function () {
};

morpheus.MetadataUtil.renameFields = function (dataset, options) {
  _.each(options.rows, function (item) {
    if (item.renameTo) {
      var v = dataset.getRowMetadata().getByName(item.field);
      if (v) {
        v.setName(item.renameTo);
      }
    }
  });
  _.each(options.columns, function (item) {
    if (item.renameTo) {
      var v = dataset.getColumnMetadata().getByName(item.field);
      if (v) {
        v.setName(item.renameTo);
      }
    }
  });
};

/**
 * @param options.model
 *            Metadata model of currently visible tracks
 * @param options.fullModel
 *            Metadata model of all metadata tracks
 * @param options.text
 *            Search text
 * @param options.isColumns
 *            Whether to search columns
 * @param options.defaultMatchMode
 *            'exact' or 'contains'
 * @param options.matchAllPredicates Whether to match all predicates
 *
 */
morpheus.MetadataUtil.search = function (options) {
  var model = options.model;
  var fullModel = options.fullModel;
  if (!fullModel) {
    fullModel = model;
  }
  var text = options.text;
  var isColumns = options.isColumns;
  text = $.trim(text);
  if (text === '') {
    return null;
  }
  var tokens = morpheus.Util.getAutocompleteTokens(text);
  if (tokens.length == 0) {
    return null;
  }
  var indexField = 'INDEX';
  var fieldNames = morpheus.MetadataUtil.getMetadataNames(fullModel);
  fieldNames.push(indexField);
  var predicates = morpheus.Util.createSearchPredicates({
    tokens: tokens,
    fields: fieldNames,
    defaultMatchMode: options.defaultMatchMode
  });
  var vectors = [];
  var nameToVector = new morpheus.Map();
  for (var j = 0; j < fullModel.getMetadataCount(); j++) {
    var v = fullModel.get(j);
    var dataType = morpheus.VectorUtil.getDataType(v);
    var wrapper = {
      vector: v,
      dataType: dataType,
      isArray: dataType.indexOf('[') === 0
    };
    nameToVector.set(v.getName(), wrapper);
    if (model.getByName(v.getName()) != null) {
      vectors.push(wrapper);
    }

  }
  // TODO only search numeric fields for range searches
  var indices = [];
  var npredicates = predicates.length;
  for (var p = 0; p < npredicates; p++) {
    var predicate = predicates[p];
    var filterColumnName = predicate.getField();
    if (filterColumnName != null && !predicate.isNumber()) {
      var wrapper = nameToVector.get(filterColumnName);
      if (wrapper && (wrapper.dataType === 'number' || wrapper.dataType === '[number]')) {
        if (predicate.getText) {
          predicates[p] = new morpheus.Util.EqualsPredicate(filterColumnName, parseFloat(predicate.getText()));
        } else if (predicate.getValues) {
          var values = [];
          predicate.getValues().forEach(function (val) {
            values.push(parseFloat(val));
          });
          predicate[p] = new morpheus.Util.ExactTermsPredicate(filterColumnName, values);
        }
      }
    }

  }

  var matchAllPredicates = options.matchAllPredicates === true;

  function isPredicateMatch(predicate) {
    var filterColumnName = predicate.getField();
    if (filterColumnName != null) {
      var value = null;
      if (filterColumnName === indexField) {
        value = i + 1;
        if (predicate.accept(value)) {
          return true;
        }
      } else {
        var wrapper = nameToVector.get(filterColumnName);
        if (wrapper) {
          value = wrapper.vector.getValue(i);
          if (wrapper.isArray) {
            if (value != null) {
              for (var k = 0; k < value.length; k++) {
                if (predicate.accept(value[k])) {
                  return true;

                }
              }
            }
          } else {
            if (predicate.accept(value)) {
              return true;
            }
          }

        }
      }

    }
    else { // try all fields
      for (var j = 0; j < nfields; j++) {
        var wrapper = vectors[j];
        var value = wrapper.vector.getValue(i);

        if (wrapper.isArray) {
          if (value != null) {
            for (var k = 0; k < value.length; k++) {
              if (predicate.accept(value[k])) {
                return true;
              }
            }
          }
        } else {
          if (predicate.accept(value)) {
            return true;
          }
        }

      }
    }

  }

  var nfields = vectors.length;
  for (var i = 0, nitems = model.getItemCount(); i < nitems; i++) {
    if (!matchAllPredicates) { // at least one predicate matches
      for (var p = 0; p < npredicates; p++) {
        var predicate = predicates[p];
        if (isPredicateMatch(predicate)) {
          indices.push(i);
          break;
        }
      }
    } else {
      var matches = true;
      for (var p = 0; p < npredicates; p++) {
        var predicate = predicates[p];
        if (!isPredicateMatch(predicate)) {
          matches = false;
          break;
        }
      }
      if (matches) {
        indices.push(i);
      }
    }

  }
  return indices;
};

morpheus.MetadataUtil.shallowCopy = function (model) {
  var copy = new morpheus.MetadataModel(model.getItemCount());
  for (var i = 0; i < model.getMetadataCount(); i++) {
    var v = model.get(i);
    // copy properties b/c they can be modified via ui
    var newVector = new morpheus.VectorAdapter(v);
    newVector.properties = new morpheus.Map();
    newVector.getProperties = function () {
      return this.properties;
    };

    v.getProperties().forEach(function (val, key) {
      if (!morpheus.VectorKeys.COPY_IGNORE.has(key)) {
        newVector.properties.set(key, val);
      }

    });

    copy.vectors.push(newVector);
  }
  return copy;
};
morpheus.MetadataUtil.autocomplete = function (model) {
  return function (tokens, cb) {
    // check for term:searchText
    var matches = [];
    var regex = null;
    var regexMatch = null;
    var searchModel = model;
    var token = tokens != null && tokens.length > 0 ? tokens[tokens.selectionStartIndex]
      : '';
    token = $.trim(token);
    var fieldSearchFieldName = null;
    if (token !== '') {
      var semi = token.indexOf(':');
      if (semi > 0) { // field search?
        if (token.charCodeAt(semi - 1) !== 92) { // \:
          var possibleField = $.trim(token.substring(0, semi));
          if (possibleField.length > 0
            && possibleField[0] === '"'
            && possibleField[token.length - 1] === '"') {
            possibleField = possibleField.substring(1,
              possibleField.length - 1);
          }
          var index = morpheus.MetadataUtil.indexOf(searchModel,
            possibleField);
          if (index !== -1) {
            fieldSearchFieldName = possibleField;
            token = $.trim(token.substring(semi + 1));
            searchModel = new morpheus.MetadataModelColumnView(
              model, [index]);
          }
        }

      }
      var set = new morpheus.Set();
      // regex used to determine if a string starts with substring `q`

      regex = new RegExp(morpheus.Util.escapeRegex(token), 'i');
      regexMatch = new RegExp('(' + morpheus.Util.escapeRegex(token) + ')', 'i');
      // iterate through the pool of strings and for any string that
      // contains the substring `q`, add it to the `matches` array
      var max = 10;

      var vectors = [];
      var isArray = [];
      for (var j = 0; j < searchModel.getMetadataCount(); j++) {
        var v = searchModel.get(j);
        var dataType = morpheus.VectorUtil.getDataType(v);
        if (dataType === 'string' || dataType === '[string]') { // skip
          // numeric
          // fields
          vectors.push(v);
          isArray.push(dataType === '[string]');
        }
      }

      var nfields = vectors.length;

      loop: for (var i = 0, nitems = searchModel.getItemCount(); i < nitems; i++) {
        for (var j = 0; j < nfields; j++) {
          var v = vectors[j];
          var val = v.getValue(i);
          if (val != null) {
            if (isArray[j]) {
              for (var k = 0; k < val.length; k++) {
                var id = new morpheus.Identifier([val[k],
                  v.getName()]);
                if (!set.has(id) && regex.test(val[k])) {
                  set.add(id);
                  if (set.size() === max) {
                    break loop;
                  }
                }
              }
            } else {
              var id = new morpheus.Identifier([val,
                v.getName()]);
              if (!set.has(id) && regex.test(val)) {
                set.add(id);
                if (set.size() === max) {
                  break loop;
                }
              }
            }
          }

        }
      }

      set.forEach(function (id) {
        var array = id.getArray();
        var field = array[1];
        var val = array[0];
        var quotedField = field;
        if (quotedField.indexOf(' ') !== -1) {
          quotedField = '"' + quotedField + '"';
        }
        var quotedValue = val;
        if (quotedValue.indexOf(' ') !== -1) {
          quotedValue = '"' + quotedValue + '"';
        }
        matches.push({
          value: quotedField + ':' + quotedValue,
          label: '<span style="font-weight:300;">' + field
          + ':</span>'
          + '<span>' + val.replace(regexMatch, '<b>$1</b>')
          + '</span>'
        });

      });
    }

    // field names
    if (regex == null) {
      regex = new RegExp('.*', 'i');
    }

    for (var j = 0; j < searchModel.getMetadataCount(); j++) {
      var v = searchModel.get(j);
      var dataType = morpheus.VectorUtil.getDataType(v);
      var field = v.getName();
      if (dataType === 'number' || dataType === 'string'
        || dataType === '[string]') {
        if (regex.test(field) && field !== fieldSearchFieldName) {
          var quotedField = field;
          if (quotedField.indexOf(' ') !== -1) {
            quotedField = '"' + quotedField + '"';
          }
          matches.push({
            value: quotedField + ':',
            label: '<span style="font-weight:300;">' + (regexMatch == null ? field : field.replace(regexMatch, '<b>$1</b>'))
            + ':</span>' + (dataType === 'number' ? ('<span' +
            ' style="font-weight:300;font-size:85%;">.., >, <, >=, <=,' +
            ' =</span>') : ''),
            show: true
          });
        }
      }
    }
    cb(matches);
  };
};

morpheus.MetadataUtil.getMetadataNames = function (metadataModel) {
  var names = [];
  for (var i = 0, count = metadataModel.getMetadataCount(); i < count; i++) {
    names.push(metadataModel.get(i).getName(i));
  }
  names.sort(function (a, b) {
    a = a.toLowerCase();
    b = b.toLowerCase();
    return (a < b ? -1 : (a === b ? 0 : 1));
  });
  return names;
};
morpheus.MetadataUtil.getVectors = function (metadataModel, names) {
  var vectors = [];
  names.forEach(function (name) {
    var v = metadataModel.getByName(name);
    if (!v) {
      throw name + ' not found. Available fields are '
      + morpheus.MetadataUtil.getMetadataNames(metadataModel);
    }
    vectors.push(v);
  });
  return vectors;
};
morpheus.MetadataUtil.indexOf = function (metadataModel, name) {
  for (var i = 0, length = metadataModel.getMetadataCount(); i < length; i++) {
    if (name === metadataModel.get(i).getName()) {
      return i;
    }
  }
  return -1;
};

morpheus.MetadataUtil.DEFAULT_STRING_ARRAY_FIELDS = ['target', 'gene_target', 'moa'];

morpheus.MetadataUtil.DEFAULT_HIDDEN_FIELDS = new morpheus.Set();
['pr_analyte_id', 'pr_gene_title', 'pr_gene_id', 'pr_analyte_num',
  'pr_bset_id', 'pr_lua_id', 'pr_pool_id', 'pr_is_bing', 'pr_is_inf',
  'pr_is_lmark', 'qc_slope', 'qc_f_logp', 'qc_iqr', 'bead_batch',
  'bead_revision', 'bead_set', 'det_mode', 'det_plate', 'det_well',
  'mfc_plate_dim', 'mfc_plate_id', 'mfc_plate_name', 'mfc_plate_quad',
  'mfc_plate_well', 'pert_dose_unit', 'pert_id_vendor', 'pert_mfc_desc',
  'pert_mfc_id', 'pert_time', 'pert_time_unit', 'pert_univ_id',
  'pert_vehicle', 'pool_id', 'rna_plate', 'rna_well', 'count_mean',
  'count_cv', 'provenance_code'].forEach(function (name) {
  morpheus.MetadataUtil.DEFAULT_HIDDEN_FIELDS.add(name);
});

morpheus.MetadataUtil.maybeConvertStrings = function (metadata,
                                                      metadataStartIndex) {
  for (var i = metadataStartIndex, count = metadata.getMetadataCount(); i < count; i++) {
    morpheus.VectorUtil.maybeConvertStringToNumber(metadata.get(i));
  }
  morpheus.MetadataUtil.DEFAULT_STRING_ARRAY_FIELDS.forEach(function (field) {
    if (metadata.getByName(field)) {
      morpheus.VectorUtil.maybeConvertToStringArray(metadata
        .getByName(field), ',');
    }
  });

};
morpheus.MetadataUtil.copy = function (src, dest) {
  if (src.getItemCount() != dest.getItemCount()) {
    throw 'Item count not equal in source and destination. '
    + src.getItemCount() + ' != ' + dest.getItemCount();
  }
  var itemCount = src.getItemCount();
  var metadataColumns = src.getMetadataCount();
  for (var j = 0; j < metadataColumns; j++) {
    var srcVector = src.get(j);
    var destVector = dest.getByName(srcVector.getName());
    if (destVector == null) {
      destVector = dest.add(srcVector.getName());
    }
    for (var i = 0; i < itemCount; i++) {
      destVector.setValue(i, srcVector.getValue(i));
    }
  }
};
morpheus.MetadataUtil.addVectorIfNotExists = function (metadataModel, name) {
  var v = metadataModel.getByName(name);
  if (!v) {
    v = metadataModel.add(name);
  }
  return v;
};
morpheus.MetadataUtil.getMatchingIndices = function (metadataModel, tokens) {
  var indices = {};
  for (var itemIndex = 0, nitems = metadataModel.getItemCount(); itemIndex < nitems; itemIndex++) {
    var matches = false;
    for (var metadataIndex = 0, metadataCount = metadataModel
      .getMetadataCount(); metadataIndex < metadataCount && !matches; metadataIndex++) {
      var vector = metadataModel.get(metadataModel
        .getColumnName(metadataIndex));
      var value = vector.getValue(itemIndex);
      for (var i = 0, length = tokens.length; i < length; i++) {
        if (tokens[i] == value) {
          matches = true;
          break;
        }
      }
    }
    if (matches) {
      indices[itemIndex] = 1;
    }
  }
  return indices;
};

morpheus.MolarConcentration = function () {

};
/*
 *
 millimolar 	mM 	10-3 molar 	10-0 mol/m3
 micromolar 	uM 	10-6 molar 	10-3 mol/m3
 nanomolar 	nM 	10-9 molar 	10-6 mol/m3
 picomolar 	pM 	10-12 molar 	10-9 mol/m3
 femtomolar 	fM 	10-15 molar 	10-12 mol/m3
 attomolar 	aM 	10-18 molar 	10-15 mol/m3
 zeptomolar 	zM 	10-21 molar 	10-18 mol/m3
 yoctomolar 	yM[3] 	10-24 molar	10-27 mol/m3
 */
morpheus.MolarConcentration.getMicroMolarConcentration = function (text) {
  /** concentration in molar*/
  text = text.toLowerCase();
  for (var i = 0; i < morpheus.MolarConcentration.CONCENTRATIONS.length; i++) {
    var pair = morpheus.MolarConcentration.CONCENTRATIONS[i];
    var key = pair[0];
    var factorToMolar = pair[1];
    var index = text.indexOf(key);
    if (index != -1) {
      var value = text.substring(0, index).trim();
      var factor = factorToMolar / 10E6;
      var conc = parseFloat(value);
      return conc / factor;

    }
  }
};
morpheus.MolarConcentration.CONCENTRATIONS = [
  ['mm', 10E3],
  ['um', 10E6],
  ['\u00B5' + 'm', 10E6],
  ['nm', 10E9],
  ['pm', 10E12],
  ['fm', 10E15],
  ['am', 10E18],
  ['zm', 10E21],
  ['ym', 10E24],
  ['m', 1]];





morpheus.Positions = function () {
  this.spaces = undefined;
  this.defaultPositionFunction = function (index) {
    return (this.size * index);
  };
  this.squishedPositionFunction = function (index) {
    return this.positions[index];
  };
  this.positionFunction = this.defaultPositionFunction;
  this.squishedIndices = {};
  this.isSquished = false;
};
morpheus.Positions.getBottom = function (rect, rowPositions) {
  var bottom = rowPositions.getLength();
  if (rect != null) {
    bottom = 1 + rowPositions.getIndex(rect.y + rect.height, false);
    bottom = Math.max(0, bottom);
    bottom = Math.min(rowPositions.getLength(), bottom);
  }
  return bottom;
};
morpheus.Positions.getTop = function (rect, rowPositions) {
  var top = 0;
  if (rect != null) {
    top = rowPositions.getIndex(rect.y, false) - 1;
    top = Math.max(0, top);
    top = Math.min(rowPositions.getLength(), top);
  }
  return top;
};
morpheus.Positions.getLeft = function (rect, columnPositions) {
  var left = 0;
  if (rect != null) {
    left = columnPositions.getIndex(rect.x, false) - 1;
    left = Math.max(0, left);
    left = Math.min(columnPositions.getLength(), left);
  }
  return left;
};
morpheus.Positions.getRight = function (rect, columnPositions) {
  var right = columnPositions.getLength();
  if (rect != null) {
    right = 1 + columnPositions.getIndex(rect.x + rect.width, false);
    right = Math.min(columnPositions.getLength(), right);
  }
  return right;
};
morpheus.Positions.prototype = {
  length: 0,
  size: 13,
  squishFactor: 0.1,
  compress: true,
  copy: function () {
    var copy = new morpheus.Positions();
    if (this.spaces) {
      copy.spaces = this.spaces.slice();
    }
    copy.compress = this.compress;
    copy.squishFactor = this.squishFactor;
    copy.size = this.size;
    copy.length = this.length;
    if (this.isSquished) {
      copy.positionFunction = copy.squishedPositionFunction;
      copy.squishedIndices = _.clone(this.squishedIndices);
      copy.isSquished = true;
    }
    return copy;
  },
  getIndex: function (position, exact) {
    if (this.getLength() === 0) {
      return -1;
    }
    if (exact) {
      return this.binaryExactSearch(position);
    } else {
      return this.binaryInExactSearch(position);
    }
  },
  getLength: function () {
    return this.length;
  },
  getPosition: function (index) {
    return this.positionFunction(index)
      + (this.spaces !== undefined ? this.spaces[index] : 0);
  },
  getItemSize: function (index) {
    return this.squishedIndices[index] === true ? this.size
    * this.squishFactor : this.size;
  },
  getSize: function () {
    return this.size;
  },
  setSpaces: function (spaces) {
    this.spaces = spaces;
  },
  setLength: function (length) {
    this.length = length;
  },
  setSize: function (size) {
    this.size = size;
    if (this.isSquished) {
      this.setSquishedIndices(this.squishedIndices);
    }
  },
  setSquishedIndices: function (squishedIndices) {
    if (squishedIndices != null) {
      var compress = this.compress;
      this.squishedIndices = squishedIndices;
      var positions = [];
      var squishFactor = this.squishFactor;
      var size = this.size;
      var position = 0;
      for (var i = 0, length = this.getLength(); i < length; i++) {
        var itemSize;
        if (squishedIndices[i] === true) {
          positions.push(position);
          itemSize = size * squishFactor;
          position += itemSize;
        } else {
          if (!compress) {
            position = size * i;
          }
          positions.push(position);
          position += size;
        }
      }
      this.isSquished = true;
      this.positions = positions;
      this.positionFunction = this.squishedPositionFunction;
    } else {
      this.squishedIndices = {};
      this.isSquished = false;
      this.positionFunction = this.defaultPositionFunction;
    }
  },
  setSquishFactor: function (f) {
    if (this.squishFactor !== f) {
      this.squishFactor = f;
      if (this.isSquished) {
        this.setSquishedIndices(this.squishedIndices);
      }
    }
  },
  getSquishFactor: function () {
    return this.squishFactor;
  },
  binaryExactSearch: function (position) {
    var low = 0;
    var high = this.length - 1;
    while (low <= high) {
      var mid = (low + high) >> 1;
      var midVal = this.getPosition(mid);
      var size = this.getItemSize(mid);
      if (midVal <= position && position < (midVal + size)) {
        return mid;
      }
      if (midVal < position) {
        low = mid + 1;
      } else if (midVal > position) {
        high = mid - 1;
      } else {
        return mid;
        // key found
      }
    }
    return -1;
    // key not found
  },
  binaryInExactSearch: function (position) {
    var low = 0;
    var high = this.getLength() - 1;
    var maxIndex = this.getLength() - 1;
    if (position <= this.getPosition(0)) {
      return 0;
    }
    while (low <= high) {
      var mid = (low + high) >> 1;
      var midVal = this.getPosition(mid);
      var size = this.getItemSize(mid);
      var nextStart = maxIndex === mid ? midVal + size : this
        .getPosition(mid + 1);
      if (midVal <= position && position < nextStart) {
        return mid;
      }
      if (midVal < position) {
        low = mid + 1;
      } else if (midVal > position) {
        high = mid - 1;
      } else {
        return mid;
        // key found
      }
    }
    return low - 1;
    // key not found
  }
};

/**
 *
 * @param dataset
 * @constructor
 */
morpheus.Project = function (dataset) {
  this.originalDataset = dataset;
  this.rowIndexMapper = new morpheus.IndexMapper(this, true);
  this.columnIndexMapper = new morpheus.IndexMapper(this, false);
  this.groupRows = [];
  this.groupColumns = [];
  this.rowColorModel = new morpheus.VectorColorModel();
  this.columnColorModel = new morpheus.VectorColorModel();
  this.rowShapeModel = new morpheus.VectorShapeModel();
  this.columnShapeModel = new morpheus.VectorShapeModel();
  this.hoverColumnIndex = -1;
  this.hoverRowIndex = -1;
  this.columnSelectionModel = new morpheus.SelectionModel(this, true);
  this.rowSelectionModel = new morpheus.SelectionModel(this, false);
  this.elementSelectionModel = new morpheus.ElementSelectionModel(this);
  this.symmetricProjectListener = null;
  morpheus.Project._recomputeCalculatedFields(this.originalDataset);
  morpheus.Project
    ._recomputeCalculatedFields(new morpheus.TransposedDatasetView(
      this.originalDataset));
  this.history = [];
};
morpheus.Project.Events = {
  DATASET_CHANGED: 'datasetChanged',
  ROW_GROUP_BY_CHANGED: 'rowGroupByChanged',
  COLUMN_GROUP_BY_CHANGED: 'columnGroupByChanged',
  ROW_FILTER_CHANGED: 'rowFilterChanged',
  COLUMN_FILTER_CHANGED: 'columnFilterChanged',
  ROW_SORT_ORDER_CHANGED: 'rowSortOrderChanged',
  COLUMN_SORT_ORDER_CHANGED: 'columnSortOrderChanged',
  ROW_TRACK_REMOVED: 'rowTrackRemoved',
  COLUMN_TRACK_REMOVED: 'columnTrackRemoved'
};

morpheus.Project._recomputeCalculatedFields = function (dataset) {
  var metadata = dataset.getColumnMetadata();
  var view = new morpheus.DatasetColumnView(dataset);
  for (var metadataIndex = 0,
         count = metadata.getMetadataCount(); metadataIndex < count; metadataIndex++) {
    var vector = metadata.get(metadataIndex);
    if (vector.getProperties().get(morpheus.VectorKeys.FUNCTION) != null
      && vector.getProperties().get(morpheus.VectorKeys.RECOMPUTE_FUNCTION)) {
      var f = morpheus.VectorUtil.jsonToFunction(vector, morpheus.VectorKeys.FUNCTION);
      for (var j = 0, size = vector.size(); j < size; j++) {
        view.setIndex(j);
        vector.setValue(j, f(view, dataset, j));
      }
    }
  }

};
morpheus.Project.prototype = {
  isSymmetric: function () {
    return this.symmetricProjectListener != null;
  },
  setSymmetric: function (heatMap) {
    if (heatMap != null) {
      if (this.symmetricProjectListener == null) {
        this.symmetricProjectListener = new morpheus.SymmetricProjectListener(heatMap.getProject(), heatMap.vscroll, heatMap.hscroll);
      }
    } else {
      if (this.symmetricProjectListener != null) {
        this.symmetricProjectListener.dispose();
      }
      this.symmetricProjectListener = null;
    }
  },
  getHoverColumnIndex: function () {
    return this.hoverColumnIndex;
  },
  setHoverColumnIndex: function (index) {
    this.hoverColumnIndex = index;
  },
  getHoverRowIndex: function () {
    return this.hoverRowIndex;
  },
  setHoverRowIndex: function (index) {
    this.hoverRowIndex = index;
  },
  getRowColorModel: function () {
    return this.rowColorModel;
  },
  getRowShapeModel: function () {
    return this.rowShapeModel;
  },
  getColumnShapeModel: function () {
    return this.columnShapeModel;
  },
  getGroupRows: function () {
    return this.groupRows;
  },
  getGroupColumns: function () {
    return this.groupColumns;
  },
  getFullDataset: function () {
    return this.originalDataset;
  },
  getColumnSelectionModel: function () {
    return this.columnSelectionModel;
  },
  getRowSelectionModel: function () {
    return this.rowSelectionModel;
  },
  getFilteredSortedRowIndices: function () {
    return this.rowIndexMapper.convertToView();
  },
  getFilteredSortedColumnIndices: function () {
    return this.columnIndexMapper.convertToView();
  },
  getElementSelectionModel: function () {
    return this.elementSelectionModel;
  },
  setFullDataset: function (dataset, notify) {
    this.originalDataset = dataset;
    this.rowIndexMapper.setFilter(this.rowIndexMapper.getFilter());
    this.columnIndexMapper.setFilter(this.columnIndexMapper.getFilter());
    this.columnSelectionModel.clear();
    this.rowSelectionModel.clear();
    this.elementSelectionModel.clear();
    if (notify) {
      this.trigger(morpheus.Project.Events.DATASET_CHANGED);
    }
  },
  setGroupRows: function (keys, notify) {
    this.groupRows = keys;
    for (var i = 0, nkeys = keys.length; i < nkeys; i++) {
      if (keys[i].isColumns() === undefined) {
        keys[i].setColumns(false);
      }
    }
    if (notify) {
      this.trigger(morpheus.Project.Events.ROW_GROUP_BY_CHANGED);
    }
  },
  setGroupColumns: function (keys, notify) {
    this.groupColumns = keys;
    for (var i = 0, nkeys = keys.length; i < nkeys; i++) {
      if (keys[i].isColumns() === undefined) {
        keys[i].setColumns(true);
      }
    }
    if (notify) {
      this.trigger(morpheus.Project.Events.COLUMN_GROUP_BY_CHANGED);
    }
  },
  setRowFilter: function (filter, notify) {
    this._saveSelection(false);
    this.rowIndexMapper.setFilter(filter);
    this._restoreSelection(false);
    if (notify) {
      this.trigger(morpheus.Project.Events.ROW_FILTER_CHANGED);
    }
  },
  getRowFilter: function () {
    return this.rowIndexMapper.getFilter();
  },
  getColumnFilter: function () {
    return this.columnIndexMapper.getFilter();
  },
  setColumnFilter: function (filter, notify) {
    this._saveSelection(true);
    this.columnIndexMapper.setFilter(filter);
    this._restoreSelection(true);
    if (notify) {
      this.trigger(morpheus.Project.Events.COLUMN_FILTER_CHANGED);
    }
  },
  getColumnColorModel: function () {
    return this.columnColorModel;
  },
  getSortedFilteredDataset: function () {
    return morpheus.DatasetUtil.slicedView(this.getFullDataset(),
      this.rowIndexMapper.convertToView(), this.columnIndexMapper
        .convertToView());
  },
  getSelectedDataset: function (options) {
    options = $.extend({}, {
      selectedRows: true,
      selectedColumns: true,
      emptyToAll: true
    }, options);
    var dataset = this.getSortedFilteredDataset();
    var rows = null;
    if (options.selectedRows) {
      rows = this.rowSelectionModel.getViewIndices().values().sort(
        function (a, b) {
          return (a === b ? 0 : (a < b ? -1 : 1));
        });
      if (rows.length === 0 && options.emptyToAll) {
        rows = null;
      }
    }
    var columns = null;
    if (options.selectedColumns) {
      columns = this.columnSelectionModel.getViewIndices().values().sort(
        function (a, b) {
          return (a === b ? 0 : (a < b ? -1 : 1));
        });
      if (columns.length === 0 && options.emptyToAll) {
        columns = null;
      }
    }
    return rows == null && columns == null ? dataset : new morpheus.SlicedDatasetView(dataset, rows, columns);
  },
  _saveSelection: function (isColumns) {
    this.elementSelectionModel.save();
    if (isColumns) {
      this.columnSelectionModel.save();
    } else {
      this.rowSelectionModel.save();
    }
  },
  _restoreSelection: function (isColumns) {
    if (isColumns) {
      this.columnSelectionModel.restore();
    } else {
      this.rowSelectionModel.restore();
    }
    this.elementSelectionModel.restore();
  },
  setRowSortKeys: function (keys, notify) {
    this._saveSelection(false);
    for (var i = 0, nkeys = keys.length; i < nkeys; i++) {
      if (keys[i].isColumns() === undefined) {
        keys[i].setColumns(false);
      }
    }
    this.rowIndexMapper.setSortKeys(keys);
    this._restoreSelection(false);
    if (notify) {
      this.trigger(morpheus.Project.Events.ROW_SORT_ORDER_CHANGED);
    }
  },
  setColumnSortKeys: function (keys, notify) {
    this._saveSelection(true);
    for (var i = 0, nkeys = keys.length; i < nkeys; i++) {
      if (keys[i].isColumns() === undefined) {
        keys[i].setColumns(true);
      }
    }
    this.columnIndexMapper.setSortKeys(keys);
    this._restoreSelection(true);
    if (notify) {
      this.trigger(morpheus.Project.Events.COLUMN_SORT_ORDER_CHANGED);
    }
  },
  getRowSortKeys: function () {
    return this.rowIndexMapper.sortKeys;
  },
  getColumnSortKeys: function () {
    return this.columnIndexMapper.sortKeys;
  },
  convertViewColumnIndexToModel: function (viewIndex) {
    return this.columnIndexMapper.convertViewIndexToModel(viewIndex);
  },
  convertViewRowIndexToModel: function (viewIndex) {
    return this.rowIndexMapper.convertViewIndexToModel(viewIndex);
  },
  convertModelRowIndexToView: function (modelIndex) {
    return this.rowIndexMapper.convertModelIndexToView(modelIndex);
  },
  convertModelColumnIndexToView: function (modelIndex) {
    return this.columnIndexMapper.convertModelIndexToView(modelIndex);
  },
  isColumnViewIndexSelected: function (index) {
    return this.columnSelectionModel.isViewIndexSelected(index);
  },
  isRowViewIndexSelected: function (index) {
    return this.rowSelectionModel.isViewIndexSelected(index);
  }
};
morpheus.Util.extend(morpheus.Project, morpheus.Events);

morpheus.QNorm = function () {

};
/**
 * Performs quantile normalization.
 */
morpheus.QNorm.execute = function (data) {
  var rows = data.getRowCount();
  var cols = data.getColumnCount();
  var i, j, ind;
  var dimat;
  var row_mean = new Float32Array(rows);
  var ranks = new Float32Array(rows);
  /* # sort original columns */
  dimat = morpheus.QNorm.get_di_matrix(data);
  for (j = 0; j < cols; j++) {
    dimat[j].sort(function (s1, s2) {
      if (s1.data < s2.data) {
        return -1;
      }
      if (s1.data > s2.data) {
        return 1;
      }
      return 0;
    });

  }
  /* # calculate means */
  for (i = 0; i < rows; i++) {
    var sum = 0.0;
    var numNonMissing = 0;
    for (j = 0; j < cols; j++) {
      var f = dimat[j][i].data;
      if (!isNaN(f)) {
        sum += f;
        numNonMissing++;
      }
    }
    row_mean[i] = sum / numNonMissing;
  }

  /* # unsort mean columns */
  for (j = 0; j < cols; j++) {
    morpheus.QNorm.get_ranks(ranks, dimat[j], rows);
    for (i = 0; i < rows; i++) {
      ind = dimat[j][i].rank;
      if (ranks[i] - Math.floor(ranks[i]) > 0.4) {
        data.setValue(ind, j, 0.5 * (row_mean[Math.floor(ranks[i]) - 1] + row_mean[Math.floor(ranks[i])]));
      } else {
        data.setValue(ind, j, row_mean[Math.floor(ranks[i]) - 1]);
      }
    }
  }
};

/**
 * ************************************************************************
 * * * dataitem **get_di_matrix(var *data, var rows, var cols) * * given
 * data form a matrix of dataitems, each element of * matrix holds datavalue
 * and original index so that * normalized data values can be resorted to
 * the original order *
 * ************************************************************************
 */

morpheus.QNorm.get_di_matrix = function (data) {
  var i, j;
  var rows = data.getRowCount();
  var cols = data.getColumnCount();
  var dimat = [];
  for (j = 0; j < cols; j++) {
    dimat.push([]);
    for (i = 0; i < rows; i++) {
      dimat[j][i] = {};
      dimat[j][i].data = data.getValue(i, j);
      dimat[j][i].rank = i;
    }
  }
  return dimat;
};

/**
 * ************************************************************************
 * * * var *get_ranks(dataitem *x,var n) * * getParameterValue ranks in
 * the same manner as R does. Assume that *x is * already sorted *
 * ************************************************************************
 */

morpheus.QNorm.get_ranks = function (rank, x, n) {
  var i, j, k;
  i = 0;
  while (i < n) {
    j = i;
    while ((j < n - 1) && (x[j].data == x[j + 1].data)) {
      j++;
    }
    if (i != j) {
      for (k = i; k <= j; k++) {
        rank[k] = (i + j + 2) / 2.0;
      }
    } else {
      rank[i] = i + 1;
    }
    i = j + 1;
  }
};


morpheus.SelectionModel = function (project, isColumns) {
  this.viewIndices = new morpheus.Set();
  this.project = project;
  this.isColumns = isColumns;
};
morpheus.SelectionModel.prototype = {
  setViewIndices: function (indices, notify) {
    this.viewIndices = indices;
    if (notify) {
      this.trigger('selectionChanged');
    }
  },
  isViewIndexSelected: function (index) {
    return this.viewIndices.has(index);
  },
  clear: function () {
    this.viewIndices = new morpheus.Set();
  },
  /**
   *
   * @returns {morpheus.Set}
   */
  getViewIndices: function () {
    return this.viewIndices;
  },
  count: function () {
    return this.viewIndices.size();
  },
  toModelIndices: function () {
    var project = this.project;
    var f = this.isColumns ? project.convertViewColumnIndexToModel
      : project.convertViewRowIndexToModel;
    f = _.bind(f, project);
    var modelIndices = [];
    this.viewIndices.forEach(function (index) {
      var m = f(index);
      modelIndices.push(m);
    });
    return modelIndices;
  },
  save: function () {
    this.modelIndices = this.toModelIndices();
  },
  restore: function () {
    var project = this.project;
    this.viewIndices = new morpheus.Set();
    var f = this.isColumns ? project.convertModelColumnIndexToView
      : project.convertModelRowIndexToView;
    f = _.bind(f, project);
    for (var i = 0, length = this.modelIndices.length; i < length; i++) {
      var index = f(this.modelIndices[i]);
      if (index !== -1) {
        this.viewIndices.add(index);
      }
    }
  },
};
morpheus.Util.extend(morpheus.SelectionModel, morpheus.Events);

morpheus.SlicedDatasetView = function (dataset, rowIndices, columnIndices) {
  morpheus.DatasetAdapter.call(this, dataset);
  if (rowIndices == null) {
    rowIndices = null;
  }
  if (columnIndices == null) {
    columnIndices = null;
  }
  this.rowIndices = rowIndices;
  this.columnIndices = columnIndices;
  //morpheus.DatasetUtil.toESSessionPromise(this);
};
morpheus.SlicedDatasetView.prototype = {
  setESSession: function (session) {
    //console.log("morpheus.SlicedDatasetView.prototype.setESSession ::", this, session);
    this.dataset.setESSession(session);
  },
  getESSession: function () {
    //console.log("morpheus.SlicedDatasetView.prototype.getESSession ::", this);
    return this.dataset.getESSession();
  },
  getRowCount: function () {
    return this.rowIndices !== null ? this.rowIndices.length : this.dataset
      .getRowCount();
  },
  getColumnCount: function () {
    return this.columnIndices !== null ? this.columnIndices.length
      : this.dataset.getColumnCount();
  },
  getValue: function (i, j, seriesIndex) {
    return this.dataset.getValue(
      this.rowIndices !== null ? this.rowIndices[i] : i,
      this.columnIndices !== null ? this.columnIndices[j] : j,
      seriesIndex);
  },
  setValue: function (i, j, value, seriesIndex) {
    this.dataset.setValue(
      this.rowIndices !== null ? this.rowIndices[i] : i,
      this.columnIndices !== null ? this.columnIndices[j] : j, value,
      seriesIndex);
  },
  getRowMetadata: function () {
    return this.rowIndices !== null ? new morpheus.MetadataModelItemView(
      this.dataset.getRowMetadata(), this.rowIndices) : this.dataset
      .getRowMetadata();
  },
  getColumnMetadata: function () {
    return this.columnIndices !== null ? new morpheus.MetadataModelItemView(
      this.dataset.getColumnMetadata(), this.columnIndices)
      : this.dataset.getColumnMetadata();
  },
  toString: function () {
    return this.getName();
  }
};
morpheus.Util.extend(morpheus.SlicedDatasetView, morpheus.DatasetAdapter);

morpheus.SlicedVector = function (v, indices) {
  morpheus.VectorAdapter.call(this, v);
  this.indices = indices;
};
morpheus.SlicedVector.prototype = {
  setValue: function (i, value) {
    this.v.setValue(this.indices[i], value);
  },
  getValue: function (i) {
    return this.v.getValue(this.indices[i]);
  },
  size: function () {
    return this.indices.length;
  }
};
morpheus.Util.extend(morpheus.SlicedVector, morpheus.VectorAdapter);

morpheus.MatchesOnTopSortKey = function (project, modelIndices, name, columns) {
  var highlightedModelIndices = {};
  var p = project;
  var viewIndices = [];
  for (var i = 0, j = modelIndices.length, length = modelIndices.length; i < length; i++, j--) {
    highlightedModelIndices[modelIndices[i]] = -1; // tie
    viewIndices.push(i);
  }
  this.comparator = function (i1, i2) {
    var a = highlightedModelIndices[i1];
    if (a === undefined) {
      a = 0;
    }
    var b = highlightedModelIndices[i2];
    if (b === undefined) {
      b = 0;
    }
    return (a === b ? 0 : (a < b ? -1 : 1));
  };
  this.indices = viewIndices;
  this.name = name;
  this.columns = columns;
};
morpheus.MatchesOnTopSortKey.prototype = {
  /**
   * Indicates whether this key is sorting rows or columns.
   * @return {*}
   */
  isColumns: function () {
    return this.columns;
  },
  setColumns: function (columns) {
    this.columns = columns;
  },
  init: function () {
  },
  getSortOrder: function () {
    return 2;
  },
  getComparator: function () {
    return this.comparator;
  },
  getValue: function (i) {
    return i;
  },
  toString: function (i) {
    return this.name;
  }
};
morpheus.SortKey = function (field, sortOrder, columns) {
  if (typeof sortOrder === 'string') {
    sortOrder = morpheus.SortKey.SortOrder[sortOrder.toUpperCase()];
  }
  this.field = field;
  this.sortOrder = sortOrder;
  this.v = null;
  this.c = null;
  this.setSortOrder(sortOrder);
  this.columns = columns;
};

morpheus.SortKey.prototype = {
  isColumns: function () {
    return this.columns;
  },
  setColumns: function (columns) {
    this.columns = columns;
  },
  init: function (dataset, visibleModelIndices) {
    this.v = dataset.getRowMetadata().getByName(this.field);
    if (!this.v) {
      this.v = {};
      this.v.getValue = function () {
        return 0;
      };
      this.c = this.sortOrder === morpheus.SortKey.SortOrder.ASCENDING ? morpheus.SortKey.ASCENDING_COMPARATOR
        : morpheus.SortKey.DESCENDING_COMPARATOR;
    } else {
      var dataType = morpheus.VectorUtil.getDataType(this.v);
      if (dataType === 'number') {
        this.c = this.sortOrder === morpheus.SortKey.SortOrder.ASCENDING ? morpheus.SortKey.NUMBER_ASCENDING_COMPARATOR
          : morpheus.SortKey.NUMBER_DESCENDING_COMPARATOR;
      } else if (dataType === '[number]') {
        var summary = this.v.getProperties().get(
            morpheus.VectorKeys.ARRAY_SUMMARY_FUNCTION)
          || morpheus.SortKey.ARRAY_MAX_SUMMARY_FUNCTION;

        this.c = this.sortOrder === morpheus.SortKey.SortOrder.ASCENDING ? morpheus.SortKey
          .ARRAY_ASCENDING_COMPARATOR(summary)
          : morpheus.SortKey.ARRAY_DESCENDING_COMPARATOR(summary);
      } else {
        this.c = this.sortOrder === morpheus.SortKey.SortOrder.ASCENDING ? morpheus.SortKey.ASCENDING_COMPARATOR
          : morpheus.SortKey.DESCENDING_COMPARATOR;
      }
    }
    if (this.sortOrder === morpheus.SortKey.SortOrder.TOP_N) {
      var pairs = [];
      var missingIndices = [];
      for (var i = 0, nrows = visibleModelIndices.length; i < nrows; i++) {
        var index = visibleModelIndices[i];
        var value = this.v.getValue(index);
        if (!isNaN(value)) {
          pairs.push({
            index: index,
            value: value
          });
        } else {
          missingIndices.push(index);
        }
      }
      // sort values in descending order
      var c = this.c;
      this.c = morpheus.SortKey.NUMBER_ASCENDING_COMPARATOR;
      pairs
        .sort(function (pair1, pair2) {
          return c(pair1.value, pair2.value);
        });

      var modelIndexToValue = [];
      var nInGroup = Math.min(pairs.length, 10);
      var counter = 0;
      var topIndex = 0;

      var half = Math.floor(pairs.length / 2);
      var topPairs = pairs.slice(0, half);
      var bottomPairs = pairs.slice(half);
      var bottomIndex = bottomPairs.length - 1;
      var ntop = topPairs.length;
      var npairs = pairs.length;
      while (counter < npairs) {
        for (var i = 0; i < nInGroup && topIndex < ntop; i++, topIndex++, counter++) {
          modelIndexToValue[topPairs[topIndex].index] = counter;
        }
        var indexCounterPairs = [];
        for (var i = 0; i < nInGroup && bottomIndex >= 0; i++, bottomIndex--, counter++) {
          indexCounterPairs.push([bottomPairs[bottomIndex].index,
            counter]);
        }
        for (var i = indexCounterPairs.length - 1, j = 0; i >= 0; i--, j++) {
          var item_i = indexCounterPairs[i];
          var item_j = indexCounterPairs[j];
          modelIndexToValue[item_i[0]] = item_j[1];
        }

      }

      // add on missing
      for (var i = 0, length = missingIndices.length; i < length; i++, counter++) {
        modelIndexToValue[missingIndices[i]] = counter;
      }
      this.modelIndexToValue = modelIndexToValue;

    }
    else {
      delete this.modelIndexToValue;
    }
  },
  getComparator: function () {
    return this.c;
  }
  ,
  getValue: function (i) {
    return this.modelIndexToValue ? this.modelIndexToValue[i] : this.v.getValue(i);
  }
  ,
  setSortOrder: function (sortOrder) {
    this.sortOrder = sortOrder;
  }
  ,
  getSortOrder: function () {
    return this.sortOrder;
  }
  ,
  toString: function () {
    return this.field;
  }
}
;
/**
 * @param modelIndices
 *            Selected rows or columns
 * @param isColumnSort -
 *            sort columns by selected rows.
 */
morpheus.SortByValuesKey = function (modelIndices, sortOrder, isColumnSort) {
  this.field = 'selection';
  this.bothCount = 10;
  this.modelIndices = modelIndices;
  this.sortOrder = sortOrder;
  this.isColumnSort = isColumnSort;
  this.setSortOrder(sortOrder);

};
morpheus.SortByValuesKey.prototype = {
  isColumns: function () {
    return this.isColumnSort;
  },
  setColumns: function (columns) {
    this.isColumnSort = columns;
  },
  init: function (dataset, visibleModelIndices) {
    // isColumnSort-sort columns by selected rows
    // dataset is transposed if !isColumnSort
    this.dataset = morpheus.DatasetUtil.slicedView(dataset, null,
      this.modelIndices);
    this.rowView = new morpheus.DatasetRowView(this.dataset);
    this.summaryFunction = this.modelIndices.length > 1 ? morpheus.Median
      : function (row) {
      return row.getValue(0);
    };
    if (this.sortOrder === morpheus.SortKey.SortOrder.TOP_N) {
      var pairs = [];
      var missingIndices = [];
      for (var i = 0, nrows = visibleModelIndices.length; i < nrows; i++) {
        var index = visibleModelIndices[i];
        var value = this.summaryFunction(this.rowView.setIndex(index));
        if (!isNaN(value)) {
          pairs.push({
            index: index,
            value: value
          });
        } else {
          missingIndices.push(index);
        }
      }
      // sort values in descending order
      pairs
        .sort(function (a, b) {
          return (a.value < b.value ? 1
            : (a.value === b.value ? 0 : -1));
        });

      var modelIndexToValue = [];
      var nInGroup = Math.min(pairs.length, this.bothCount);
      var counter = 0;
      var topIndex = 0;

      var half = Math.floor(pairs.length / 2);
      var topPairs = pairs.slice(0, half);
      var bottomPairs = pairs.slice(half);
      var bottomIndex = bottomPairs.length - 1;
      var ntop = topPairs.length;
      var npairs = pairs.length;
      while (counter < npairs) {
        for (var i = 0; i < nInGroup && topIndex < ntop; i++, topIndex++, counter++) {
          modelIndexToValue[topPairs[topIndex].index] = counter;
        }
        var indexCounterPairs = [];
        for (var i = 0; i < nInGroup && bottomIndex >= 0; i++, bottomIndex--, counter++) {
          indexCounterPairs.push([bottomPairs[bottomIndex].index,
            counter]);
        }
        for (var i = indexCounterPairs.length - 1, j = 0; i >= 0; i--, j++) {
          var item_i = indexCounterPairs[i];
          var item_j = indexCounterPairs[j];
          modelIndexToValue[item_i[0]] = item_j[1];
        }

      }

      // add on missing
      for (var i = 0, length = missingIndices.length; i < length; i++, counter++) {
        modelIndexToValue[missingIndices[i]] = counter;
      }
      this.modelIndexToValue = modelIndexToValue;

    } else {
      delete this.modelIndexToValue;
    }
  },
  getComparator: function () {
    return this.c;
  },
  getValue: function (i) {
    return this.modelIndexToValue ? this.modelIndexToValue[i] : this
      .summaryFunction(this.rowView.setIndex(i));
  },
  setSortOrder: function (sortOrder) {
    if (typeof sortOrder === 'string') {
      sortOrder = morpheus.SortKey.SortOrder[sortOrder.toUpperCase()];
    }
    this.sortOrder = sortOrder;
    if (this.sortOrder === morpheus.SortKey.SortOrder.ASCENDING) {
      this.c = morpheus.SortKey.ELEMENT_ASCENDING_COMPARATOR;
    } else if (this.sortOrder === morpheus.SortKey.SortOrder.DESCENDING) {
      this.c = morpheus.SortKey.ELEMENT_DESCENDING_COMPARATOR;
    } else {
      this.c = morpheus.SortKey.NUMBER_ASCENDING_COMPARATOR;
    }

  },
  getSortOrder: function () {
    return this.sortOrder;
  },
  toString: function () {
    return 'values';
  }
};
/**
 * @param modelIndices
 *            Array of model indices
 * @param nvisible
 *            The number of visible indices at the time this sort key was
 *            created. Used by dendrogram to determine if dendrogram should be
 *            shown.
 * @param name
 *            This sort key name
 * @param columns Whether column sort
 */
morpheus.SpecifiedModelSortOrder = function (modelIndices, nvisible, name, columns) {
  this.nvisible = nvisible;
  var modelIndexToValue = [];
  for (var i = 0, length = modelIndices.length; i < length; i++) {
    modelIndexToValue[modelIndices[i]] = i;
  }
  this.modelIndices = modelIndices;
  this.modelIndexToValue = modelIndexToValue;
  this.name = name;
  this.c = morpheus.SortKey.NUMBER_ASCENDING_COMPARATOR;
  this.columns = columns;
};
morpheus.SpecifiedModelSortOrder.prototype = {
  isColumns: function () {
    return this.columns;
  },
  setColumns: function (columns) {
    this.columns = columns;
  },
  init: function (dataset) {
  },
  getComparator: function (a, b) {
    return this.c;
  },
  getValue: function (i) {
    return this.modelIndexToValue[i];
  },
  setSortOrder: function (sortOrder) {
    this.sortOrder = sortOrder;
    this.c = this.sortOrder === morpheus.SortKey.SortOrder.ASCENDING ? morpheus.SortKey.NUMBER_ASCENDING_COMPARATOR
      : morpheus.SortKey.NUMBER_DESCENDING_COMPARATOR;
  },
  getSortOrder: function () {
    return this.sortOrder;
  },
  getName: function () {
    return this.name;
  }
};

/**
 * Group by key
 *
 * @param values
 */
morpheus.SpecifiedGroupByKey = function (clusterIds, columns) {
  this.clusterIds = clusterIds;
  this.c = function (a, b) {
    return (a === b ? 0 : // Values are equal
      (a < b ? -1 : // (-0.0, 0.0) or (!NaN, NaN)
        1));
  };
  this.columns = columns;
};
morpheus.SpecifiedGroupByKey.prototype = {
  isColumns: function () {
    return this.columns;
  },
  setColumns: function (columns) {
    this.columns = columns;
  },
  init: function (dataset) {
  },
  getComparator: function (a, b) {
    return this.c;
  },
  getValue: function (i) {
    return this.clusterIds[i];
  },
  setSortOrder: function (sortOrder) {
  },
  getSortOrder: function () {
  },
  getName: function () {
    return 'Dendrogram Cut';
  }
};
morpheus.SortKey.SortOrder = {
  ASCENDING: 0,
  DESCENDING: 1,
  UNSORTED: 2,
  CUSTOM: 3,
  TOP_N: 4
};
/**
 * Comparator to sort ascending using lowercase string comparison
 */
morpheus.SortKey.ASCENDING_COMPARATOR = function (a, b) {
  // we want NaNs to end up at the bottom
  var aNaN = (a == null);
  var bNaN = (b == null);
  if (aNaN && bNaN) {
    return 0;
  }
  if (aNaN) {
    return 1;
  }
  if (bNaN) {
    return -1;
  }
  a = ('' + a).toLowerCase();
  b = ('' + b).toLowerCase();
  return (a === b ? 0 : (a < b ? -1 : 1));
};
/**
 * Comparator to sort descending using lowercase string comparison
 */
morpheus.SortKey.DESCENDING_COMPARATOR = function (a, b) {
  var aNaN = (a == null);
  var bNaN = (b == null);
  if (aNaN && bNaN) {
    return 0;
  }
  if (aNaN) {
    return 1;
  }
  if (bNaN) {
    return -1;
  }
  a = ('' + a).toLowerCase();
  b = ('' + b).toLowerCase();
  return (a === b ? 0 : (a < b ? 1 : -1));
};

morpheus.SortKey.NUMBER_ASCENDING_COMPARATOR = function (a, b) {
  // we want NaNs to end up at the bottom
  var aNaN = (a == null || isNaN(a));
  var bNaN = (b == null || isNaN(b));
  if (aNaN && bNaN) {
    return 0;
  }
  if (aNaN) {
    return 1;
  }
  if (bNaN) {
    return -1;
  }
  return (a === b ? 0 : (a < b ? -1 : 1));
};

morpheus.SortKey.NUMBER_DESCENDING_COMPARATOR = function (a, b) {
  var aNaN = (a == null || isNaN(a));
  var bNaN = (b == null || isNaN(b));
  if (aNaN && bNaN) {
    return 0;
  }
  //noinspection JSConstructorReturnsPrimitive
  if (aNaN) {
    return 1;
  }
  if (bNaN) {
    return -1;
  }
  return (a === b ? 0 : (a < b ? 1 : -1));
};

morpheus.SortKey.STRING_ASCENDING_COMPARATOR = function (a, b) {
  a = (a == null || a.toLowerCase === undefined) ? null : a.toLowerCase();
  b = (b == null || b.toLowerCase === undefined) ? null : b.toLowerCase();
  return (a === b ? 0 : (a < b ? -1 : 1));
};
morpheus.SortKey.STRING_DESCENDING_COMPARATOR = function (a, b) {
  a = (a == null || a.toLowerCase === undefined) ? null : a.toLowerCase();
  b = (b == null || b.toLowerCase === undefined) ? null : b.toLowerCase();
  return (a === b ? 0 : (a < b ? 1 : -1));
};

morpheus.SortKey.ELEMENT_ASCENDING_COMPARATOR = function (obj1, obj2) {
  var a = +obj1;
  var b = +obj2;
  var aNaN = isNaN(a);
  var bNaN = isNaN(b);
  if (aNaN && bNaN) {
    return 0;
  }
  if (aNaN) {
    return 1;
  }
  if (bNaN) {
    return -1;
  }

  if (a === b) {
    if (obj1.toObject && obj2.toObject) {
      var a1 = obj1.toObject();
      var b1 = obj2.toObject();
      for (var name in a1) {
        a = a1[name];
        b = b1[name];

        var c = (a === b ? 0 : (a < b ? -1 : 1));
        if (c !== 0) {
          return c;
        }
      }
    }
  }
  return (a === b ? 0 : (a < b ? -1 : 1));
};

morpheus.SortKey.ELEMENT_DESCENDING_COMPARATOR = function (obj1, obj2) {
  // we want NaNs to end up at the bottom
  var a = +obj1;
  var b = +obj2;
  var aNaN = isNaN(a);
  var bNaN = isNaN(b);
  if (aNaN && bNaN) {
    return 0;
  }
  if (aNaN) {
    return 1;
  }
  if (bNaN) {
    return -1;
  }
  if (a === b) {
    if (obj1.toObject && obj2.toObject) {
      var a1 = obj1.toObject();
      var b1 = obj2.toObject();
      for (var name in a1) {
        a = a1[name];
        b = b1[name];
        var c = (a === b ? 0 : (a < b ? 1 : -1));
        if (c !== 0) {
          return c;
        }
      }
    }
  }
  return (a === b ? 0 : (a < b ? 1 : -1));
};
morpheus.SortKey.BOX_PLOT_SUMMARY_FUNCTION = function (array) {
  var box = array.box;
  if (box == null) {
    var v = morpheus.VectorUtil.arrayAsVector(array);
    box = morpheus
      .BoxPlotItem(this.indices != null ? new morpheus.SlicedVector(
        v, this.indices) : v);
    array.box = box;
  }

  return box.q3;
};

morpheus.SortKey.ARRAY_MAX_SUMMARY_FUNCTION = function (array) {
  var a = 0;
  if (array != null) {
    var aPosMax = -Number.MAX_VALUE;
    var aNegMax = Number.MAX_VALUE;
    for (var i = 0, length = array.length; i < length; i++) {
      var value = array[i];
      if (!isNaN(value)) {
        if (value >= 0) {
          aPosMax = value > aPosMax ? value : aPosMax;
        } else {
          aNegMax = value < aNegMax ? value : aNegMax;
        }
      }
    }

    if (aPosMax !== -Number.MAX_VALUE) {
      a = aPosMax;
    }
    if (aNegMax !== Number.MAX_VALUE) {
      a = Math.abs(aNegMax) > a ? aNegMax : a;
    }
  }
  return a;
};
morpheus.SortKey.ARRAY_ASCENDING_COMPARATOR = function (summary) {
  return function (a, b) {
    var aNaN = a == null;
    var bNaN = b == null;
    if (aNaN && bNaN) {
      return 0;
    }
    if (aNaN) {
      return 1;
    }
    if (bNaN) {
      return -1;
    }
    a = summary(a);
    b = summary(b);
    aNaN = isNaN(a);
    bNaN = isNaN(b);
    if (aNaN && bNaN) {
      return 0;
    }
    if (aNaN) {
      return 1;
    }
    if (bNaN) {
      return -1;
    }
    return (a === b ? 0 : (a < b ? -1 : 1));
  };
};

morpheus.SortKey.ARRAY_DESCENDING_COMPARATOR = function (summary) {
  return function (a, b) {
    var aNaN = a == null;
    var bNaN = b == null;
    if (aNaN && bNaN) {
      return 0;
    }
    if (aNaN) {
      return 1;
    }
    if (bNaN) {
      return -1;
    }
    a = summary(a);
    b = summary(b);
    aNaN = isNaN(a);
    bNaN = isNaN(b);
    if (aNaN && bNaN) {
      return 0;
    }
    if (aNaN) {
      return 1;
    }
    if (bNaN) {
      return -1;
    }
    return (a === b ? 0 : (a < b ? 1 : -1));
  };
};

morpheus.SortKey.reverseComparator = function (c) {
  return function (a, b) {
    return c(b, a);
  };
};
morpheus.SortKey.keepExistingSortKeys = function (newSortKeys, existingSortKeys) {
  var dendrogramSortKey = null;
  var matchesOnTopSortKey = null;
  for (var i = 0, length = existingSortKeys.length; i < length; i++) {
    var key = existingSortKeys[i];
    if (key instanceof morpheus.MatchesOnTopSortKey && key.toString() === 'matches on top') {
      matchesOnTopSortKey = key;
    }
    if (key instanceof morpheus.SpecifiedModelSortOrder
      && key.name === 'dendrogram') {
      dendrogramSortKey = key;
    }
  }
  if (matchesOnTopSortKey) {
    newSortKeys.splice(0, 0, matchesOnTopSortKey);
  }
  if (dendrogramSortKey) {
    newSortKeys.splice(newSortKeys.length, 0, dendrogramSortKey);
  }
  return newSortKeys;
};

morpheus.SortKey.fromJSON = function (project, json) {
  var sortKeys = [];
  json.forEach(function (key) {
    if (key.type === 'annotation') {
      sortKeys.push(new morpheus.SortKey(key.field, key.order, key.isColumns));
    } else if (key.type === 'byValues') {
      sortKeys.push(new morpheus.SortByValuesKey(key.modelIndices, key.order, key.isColumns));
    } else if (key.type === 'specified') {
      sortKeys.push(new morpheus.SpecifiedModelSortOrder(key.modelIndices, key.nvisible, key.name, key.isColumns));
    } else if (key.type === 'matchesOnTop') {
      sortKeys.push(new morpheus.MatchesOnTopSortKey(project, key.modelIndices, key.name, key.isColumns));
    } else {
      if (key.field != null) {
        sortKeys.push(new morpheus.SortKey(key.field, key.order));
      } else {
        console.log('Unknown key: ' + key);
      }
    }
  });
  return sortKeys;
};

morpheus.SortKey.toJSON = function (sortKeys) {
  var json = [];
  sortKeys.forEach(function (key) {
    if (key instanceof morpheus.SortKey) {
      json.push({
        isColumns: key.isColumns(),
        order: key.getSortOrder(),
        type: 'annotation',
        field: '' + key,
      });
    } else if (key instanceof morpheus.SortByValuesKey) {
      json.push({
        isColumns: key.isColumns(),
        order: key.getSortOrder(),
        type: 'byValues',
        modelIndices: key.modelIndices
      });
    } else if (key instanceof morpheus.SpecifiedModelSortOrder) {
      json.push({
        isColumns: key.isColumns(),
        order: key.getSortOrder(),
        type: 'specified',
        modelIndices: key.modelIndices,
        name: key.name,
        nvisible: key.nvisible
      });
    } else if (key instanceof morpheus.MatchesOnTopSortKey) {
      json.push({
        isColumns: key.isColumns(),
        order: key.getSortOrder(),
        type: 'matchesOnTop',
        modelIndices: key.modelIndices,
        name: key.name
      });
    } else {
      console.log('Unknown sort key type');
    }
  });
  return json;
};

morpheus.SymmetricProjectListener = function (project, vscroll, hscroll) {
  var ignoreEvent = false;
  var rowGroupBy;
  var columnGroupBy;
  var rowFilter;
  var columnFilter;
  var rowSortOrder;
  var columnSortOrder;
  var columnSelection;
  var rowSelection;
  var vscrollFunction;
  var hscrollFunction;
  project.on(morpheus.Project.Events.ROW_GROUP_BY_CHANGED, rowGroupBy = function () {
    if (ignoreEvent) {
      return;
    }
    ignoreEvent = true;
    project.setGroupColumns(project.getGroupRows(), true);
    ignoreEvent = false;
  });
  project.on(morpheus.Project.Events.COLUMN_GROUP_BY_CHANGED, columnGroupBy = function () {
    if (ignoreEvent) {
      return;
    }
    ignoreEvent = true;
    project.setGroupRows(project.getGroupColumns(), true);
    ignoreEvent = false;
  });
  project.on(morpheus.Project.Events.ROW_FILTER_CHANGED, rowFilter = function () {
    if (ignoreEvent) {
      return;
    }
    ignoreEvent = true;
    project.setColumnFilter(project.getRowFilter(), true);
    ignoreEvent = false;
  });
  project.on(morpheus.Project.Events.COLUMN_FILTER_CHANGED, columnFilter = function () {
    if (ignoreEvent) {
      return;
    }
    ignoreEvent = true;
    project.setRowFilter(project.getColumnFilter(), true);
    ignoreEvent = false;
  });
  project.on(morpheus.Project.Events.ROW_SORT_ORDER_CHANGED, rowSortOrder = function () {
    if (ignoreEvent) {
      return;
    }
    ignoreEvent = true;
    project.setColumnSortKeys(project.getRowSortKeys(), true);
    ignoreEvent = false;
  });
  project.on(morpheus.Project.Events.COLUMN_SORT_ORDER_CHANGED, columnSortOrder = function () {
    if (ignoreEvent) {
      return;
    }
    ignoreEvent = true;
    project.setRowSortKeys(project.getColumnSortKeys(), true);
    ignoreEvent = false;
  });
  project.getColumnSelectionModel().on('selectionChanged', columnSelection = function () {
    if (ignoreEvent) {
      return;
    }
    ignoreEvent = true;
    project.getRowSelectionModel().setViewIndices(project.getColumnSelectionModel().getViewIndices(), true);
    ignoreEvent = false;
  });
  project.getRowSelectionModel().on('selectionChanged', rowSelection = function () {
    if (ignoreEvent) {
      return;
    }
    ignoreEvent = true;
    project.getColumnSelectionModel().setViewIndices(project.getRowSelectionModel().getViewIndices(), true);
    ignoreEvent = false;
  });
  vscroll.on('scroll', vscrollFunction = function () {
    if (ignoreEvent) {
      return;
    }
    ignoreEvent = true;
    var f = vscroll.getMaxValue() === 0 ? 0 : vscroll.getValue() / vscroll.getMaxValue();
    hscroll.setValue(f * hscroll.getMaxValue(), true);
    ignoreEvent = false;
  });
  hscroll.on('scroll', hscrollFunction = function () {
    if (ignoreEvent) {
      return;
    }
    ignoreEvent = true;
    var f = hscroll.getMaxValue() === 0 ? 0 : hscroll.getValue() / hscroll.getMaxValue();
    vscroll.setValue(f * vscroll.getMaxValue(), true);
    ignoreEvent = false;
  });

  this.dispose = function () {
    project.off(morpheus.Project.Events.ROW_GROUP_BY_CHANGED, rowGroupBy);
    project.off(morpheus.Project.Events.COLUMN_GROUP_BY_CHANGED, columnGroupBy);
    project.off(morpheus.Project.Events.ROW_FILTER_CHANGED, rowFilter);
    project.off(morpheus.Project.Events.COLUMN_FILTER_CHANGED, columnFilter);
    project.off(morpheus.Project.Events.ROW_SORT_ORDER_CHANGED, rowSortOrder);
    project.off(morpheus.Project.Events.COLUMN_SORT_ORDER_CHANGED, columnSortOrder);
    project.getColumnSelectionModel().off('selectionChanged', columnSelection);
    project.getRowSelectionModel().off('selectionChanged', rowSelection);
    vscroll.off('scroll', vscrollFunction);
    hscroll.off('scroll', hscrollFunction);
  };
};




morpheus.TransposedDatasetView = function (dataset) {
  morpheus.DatasetAdapter.call(this, dataset);
};
morpheus.TransposedDatasetView.prototype = {
  getRowCount: function () {
    return this.dataset.getColumnCount();
  },
  getColumnCount: function () {
    return this.dataset.getRowCount();
  },
  getValue: function (i, j, seriesIndex) {
    return this.dataset.getValue(j, i, seriesIndex);
  },
  setValue: function (i, j, value, seriesIndex) {
    this.dataset.setValue(j, i, value, seriesIndex);
  },
  getRowMetadata: function () {
    return this.dataset.getColumnMetadata();
  },
  getColumnMetadata: function () {
    return this.dataset.getRowMetadata();
  }
};
morpheus.Util.extend(morpheus.TransposedDatasetView, morpheus.DatasetAdapter);

/**
 * Provides percentile computation.
 * <p>
 * There are several commonly used methods for estimating percentiles (a.k.a.
 * quantiles) based on sample data. For large samples, the different methods
 * agree closely, but when sample sizes are small, different methods will give
 * significantly different results. The algorithm implemented here works as
 * follows:
 * <ol>
 * <li>Let <code>n</code> be the length of the (sorted) array and
 * <code>0 < p <= 100</code> be the desired percentile.</li>
 * <li>If <code> n = 1 </code> return the unique array element (regardless of
 * the value of <code>p</code>); otherwise</li>
 * <li>Compute the estimated percentile position
 * <code> pos = p * (n + 1) / 100</code> and the difference, <code>d</code>
 * between <code>pos</code> and <code>floor(pos)</code> (i.e. the fractional
 * part of <code>pos</code>). If <code>pos >= n</code> return the largest
 * element in the array; otherwise</li>
 * <li>Let <code>lower</code> be the element in position
 * <code>floor(pos)</code> in the array and let <code>upper</code> be the
 * next element in the array. Return <code>lower + d * (upper - lower)</code></li>
 * </ol>
 *
 * @param p Percentile between 0 and 100
 */
morpheus.Percentile = function (vector, p, isSorted) {
  return morpheus.ArrayPercentile(morpheus.RemoveNaN(vector), p, isSorted);
};
/**
 * @private
 * @ignore
 */
morpheus.RemoveNaN = function (values) {
  var array = [];
  for (var i = 0, size = values.size(); i < size; i++) {
    var value = values.getValue(i);
    if (!isNaN(value)) {
      array.push(value);
    }
  }
  return array;
};
morpheus.Median = function (vector) {
  return morpheus.ArrayPercentile(morpheus.RemoveNaN(vector), 50, false);
};
morpheus.Median.toString = function () {
  return 'Median';
};
/**
 * @ignore
 */
morpheus.ArrayPercentile = function (values, p, isSorted) {

  if (!isSorted) {
    values.sort(function (a, b) {
      return (a < b ? -1 : (a === b ? 0 : 1));
    });
  }
  return d3.quantile(values, p / 100);
};
/**
 * @ignore
 */
morpheus.MaxPercentiles = function (percentiles) {
  var f = function (vector) {
    var values = [];
    for (var i = 0, size = vector.size(); i < size; i++) {
      var value = vector.getValue(i);
      if (!isNaN(value)) {
        values.push(value);
      }
    }
    if (values.length === 0) {
      return NaN;
    }
    values.sort(function (a, b) {
      return (a < b ? -1 : (a === b ? 0 : 1));
    });
    var max = 0;
    for (var i = 0; i < percentiles.length; i++) {
      var p = morpheus.ArrayPercentile(values, percentiles[i], true);
      if (Math.abs(p) > Math.abs(max)) {
        max = p;
      }
    }
    return max;
  };
  f.toString = function () {
    var s = ['Maximum of '];
    for (var i = 0, length = percentiles.length; i < length; i++) {
      if (i > 0 && length > 2) {
        s.push(', ');
      }
      if (i === length - 1) {
        s.push(length == 2 ? ' and ' : 'and ');
      }
      s.push(percentiles[i]);
    }
    s.push(' percentiles');
    return s.join('');
  };
  return f;
};
morpheus.Mean = function (vector) {
  var sum = 0;
  var count = 0;
  for (var i = 0, length = vector.size(); i < length; i++) {
    var val = vector.getValue(i);
    if (!isNaN(val)) {
      sum += val;
      count++;
    }
  }
  return count === 0 ? NaN : sum / count;
};
morpheus.Mean.toString = function () {
  return 'Mean';
};
morpheus.Sum = function (vector) {
  var sum = 0;
  var found = false;
  for (var i = 0, length = vector.size(); i < length; i++) {
    var val = vector.getValue(i);
    if (!isNaN(val)) {
      found = true;
      sum += val;
    }
  }
  return !found ? NaN : sum;
};
morpheus.Sum.toString = function () {
  return 'Sum';
};
morpheus.CountNonNaN = function (vector) {
  var count = 0;
  for (var i = 0, length = vector.size(); i < length; i++) {
    var val = vector.getValue(i);
    if (!isNaN(val)) {
      count++;
    }
  }
  return count;
};
morpheus.CountNonNaN.toString = function () {
  return 'Count non-NaN';
};

morpheus.Max = function (vector) {
  var max = -Number.MAX_VALUE;
  var found = false;
  for (var i = 0, length = vector.size(); i < length; i++) {
    var val = vector.getValue(i);
    if (!isNaN(val)) {
      found = true;
      max = Math.max(max, val);
    }
  }
  return !found ? NaN : max;
};
morpheus.Max.toString = function () {
  return 'Max';
};
morpheus.Min = function (vector) {
  var min = Number.MAX_VALUE;
  var found = false;
  for (var i = 0, length = vector.size(); i < length; i++) {
    var val = vector.getValue(i);
    if (!isNaN(val)) {
      found = true;
      min = Math.min(min, val);
    }
  }
  return !found ? NaN : min;
};
morpheus.Min.toString = function () {
  return 'Min';
};
morpheus.Variance = function (list, mean) {
  if (mean == undefined) {
    mean = morpheus.Mean(list);
  }
  var sum = 0;
  var n = 0;
  for (var j = 0, size = list.size(); j < size; j++) {
    var x = list.getValue(j);
    if (!isNaN(x)) {
      var diff = x - mean;
      diff = diff * diff;
      sum += diff;
      n++;
    }
  }
  if (n <= 1) {
    return NaN;
  }
  n = n - 1;
  if (n < 1) {
    n = 1;
  }
  var variance = sum / n;
  return variance;
};
morpheus.Variance.toString = function () {
  return 'Variance';
};

morpheus.StandardDeviation = function (list, mean) {
  return Math.sqrt(morpheus.Variance(list, mean));
};
morpheus.StandardDeviation.toString = function () {
  return 'Standard deviation';
};

var LOG_10 = Math.log(10);
morpheus.Log10 = function (x) {
  return x <= 0 ? 0 : Math.log(x) / LOG_10;
};
var LOG_2 = Math.log(2);
morpheus.Log2 = function (x) {
  return x <= 0 ? 0 : Math.log(x) / LOG_2;
};

/**
 * Computes the False Discovery Rate using the BH procedure.
 *
 * @param nominalPValues
 *            Array of nominal p-values.
 */
morpheus.FDR_BH = function (nominalPValues) {
  var size = nominalPValues.length;
  var fdr = [];
  var pValueIndices = morpheus.Util.indexSort(nominalPValues, true);
  var ranks = morpheus.Util.rankIndexArray(pValueIndices);

  // check for ties
  for (var i = pValueIndices.length - 1; i > 0; i--) {
    var bigPValue = nominalPValues[pValueIndices[i]];
    var smallPValue = nominalPValues[pValueIndices[i - 1]];
    if (bigPValue == smallPValue) {
      ranks[pValueIndices[i - 1]] = ranks[pValueIndices[i]];
    }
  }
  for (var i = 0; i < size; i++) {
    var rank = ranks[i];
    var p = nominalPValues[i];
    fdr[i] = (p * size) / rank;
  }

  // ensure fdr is monotonically decreasing
  var pIndices = morpheus.Util.indexSort(nominalPValues, false);
  for (var i = 0; i < pIndices.length - 1; i++) {
    var highIndex = pIndices[i];
    var lowIndex = pIndices[i + 1];
    fdr[lowIndex] = Math.min(fdr[lowIndex], fdr[highIndex]);
  }
  for (var i = 0; i < size; i++) {
    fdr[i] = Math.min(fdr[i], 1);
  }
  return fdr;
};

morpheus.FDR_BH.tString = function () {
  return 'FDR(BH)';
};

morpheus.MAD = function (list, median) {
  if (median == null) {
    median = morpheus.Percentile(list, 50);
  }
  var temp = [];
  for (var j = 0, size = list.size(); j < size; j++) {
    var value = list.getValue(j);
    if (!isNaN(value)) {
      temp.push(Math.abs(value - median));
    }
  }
  var r = morpheus.Percentile(new morpheus.Vector('', temp.length)
    .setArray(temp), 50);
  return 1.4826 * r;
};
morpheus.MAD.toString = function () {
  return 'Median absolute deviation';
};
morpheus.CV = function (list) {
  var mean = morpheus.Mean(list);
  var stdev = Math.sqrt(morpheus.Variance(list, mean));
  return stdev / mean;
};
morpheus.CV.toString = function () {
  return 'Coefficient of variation';
};

morpheus.BoxPlotItem = function (list) {
  var values = morpheus.RemoveNaN(list);
  values.sort(function (a, b) {
    return (a === b ? 0 : (a < b ? -1 : 1));
  });
  if (values.length === 0) {
    return {
      median: NaN,
      q1: NaN,
      q3: NaN,
      lowerAdjacentValue: NaN,
      upperAdjacentValue: NaN
    };
  }
  var median = morpheus.ArrayPercentile(values, 50, true);
  var q1 = morpheus.ArrayPercentile(values, 25, true);
  var q3 = morpheus.ArrayPercentile(values, 75, true);
  var w = 1.5;
  var upperAdjacentValue = -Number.MAX_VALUE;
  var lowerAdjacentValue = Number.MAX_VALUE;
  // The upper adjacent value (UAV) is the largest observation that is
  // less than or equal to
  // the upper inner fence (UIF), which is the third quartile plus
  // 1.5*IQR.
  //
  // The lower adjacent value (LAV) is the smallest observation that is
  // greater than or equal
  // to the lower inner fence (LIF), which is the first quartile minus
  // 1.5*IQR.
  var upperOutlier = q3 + w * (q3 - q1);
  var lowerOutlier = q1 - w * (q3 - q1);
  var sum = 0;
  for (var i = 0, length = values.length; i < length; i++) {
    var value = values[i];
    if (value <= upperOutlier) {
      upperAdjacentValue = Math.max(upperAdjacentValue, value);
    }
    if (value >= lowerOutlier) {
      lowerAdjacentValue = Math.min(lowerAdjacentValue, value);
    }
    sum += value;
    // if (value > upperOutlier) {
    // upperOutliers.add(new Outlier(i, j, value));
    // }
    // if (value < lowerOutlier) {
    // lowerOutliers.add(new Outlier(i, j, value));
    // }
  }
  var mean = sum / values.length;
  if (lowerAdjacentValue > q1) {
    lowerAdjacentValue = q1;
  }
  if (upperAdjacentValue < q3) {
    upperAdjacentValue = q3;
  }

  return {
    mean: mean,
    median: median,
    q1: q1, // Lower Quartile
    q3: q3, // Upper Quartile
    lowerAdjacentValue: lowerAdjacentValue, // Lower Whisker
    upperAdjacentValue: upperAdjacentValue
    // Upper Whisker
  };

};

morpheus.VectorColorModel = function () {
  this.vectorNameToColorMap = new morpheus.Map();
  this.vectorNameToColorScheme = new morpheus.Map();
  this.colors = morpheus.VectorColorModel.TWENTY_COLORS;
};

morpheus.VectorColorModel.YES_COLOR = '#d8b365';
morpheus.VectorColorModel.FEMALE = '#ff99ff';
morpheus.VectorColorModel.MALE = '#66ccff';

// tableau 20-same as d3 category20
morpheus.VectorColorModel.TWENTY_COLORS = ['#1f77b4', '#aec7e8', '#ff7f0e',
  '#ffbb78', '#2ca02c', '#98df8a', '#d62728', '#ff9896', '#9467bd',
  '#c5b0d5', '#8c564b', '#c49c94', '#e377c2', '#f7b6d2', '#7f7f7f',
  '#c7c7c7', '#bcbd22', '#dbdb8d', '#17becf', '#9edae5'];
morpheus.VectorColorModel.CATEGORY_20A = morpheus.VectorColorModel.TWENTY_COLORS;
morpheus.VectorColorModel.CATEGORY_20B = ['#393b79', '#5254a3', '#6b6ecf',
  '#9c9ede', '#637939', '#8ca252', '#b5cf6b', '#cedb9c', '#8c6d31',
  '#bd9e39', '#e7ba52', '#e7cb94', '#843c39', '#ad494a', '#d6616b',
  '#e7969c', '#7b4173', '#a55194', '#ce6dbd', '#de9ed6'];
morpheus.VectorColorModel.CATEGORY_20C = ['#3182bd', '#6baed6', '#9ecae1',
  '#c6dbef', '#e6550d', '#fd8d3c', '#fdae6b', '#fdd0a2', '#31a354',
  '#74c476', '#a1d99b', '#c7e9c0', '#756bb1', '#9e9ac8', '#bcbddc',
  '#dadaeb', '#636363', '#969696', '#bdbdbd', '#d9d9d9'];

morpheus.VectorColorModel.CATEGORY_ALL = [].concat(
  morpheus.VectorColorModel.CATEGORY_20A,
  morpheus.VectorColorModel.CATEGORY_20B,
  morpheus.VectorColorModel.CATEGORY_20C);

morpheus.VectorColorModel.TABLEAU10 = ['#1f77b4', '#ff7f0e', '#2ca02c',
  '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22',
  '#17becf'];
morpheus.VectorColorModel.STANDARD_COLORS = {
  'na': '#c0c0c0',
  'nan': '#c0c0c0',
  '': '#ffffff',
  'wt': '#ffffff',
  'n': '#ffffff',
  '0': '#ffffff',
  'y': morpheus.VectorColorModel.YES_COLOR,
  '1': morpheus.VectorColorModel.YES_COLOR,
  'male': morpheus.VectorColorModel.MALE,
  'm': morpheus.VectorColorModel.MALE,
  'female': morpheus.VectorColorModel.FEMALE,
  'f': morpheus.VectorColorModel.FEMALE,
  'kd': '#C675A8',
  'oe': '#56b4e9',
  'cp': '#FF9933',
  'trt_sh.cgs': '#C675A8',
  'trt_oe': '#56b4e9',
  'trt_cp': '#FF9933',
  'a375': '#1490C1',
  'a549': '#AAC8E9',
  'hcc515': '#1C9C2A',
  'hepg2': '#94DC89',
  'ht29': '#946DBE',
  'mcf7': '#C5B2D5',
  'pc3': '#38C697',
  'asc': '#FF8000',
  'cd34': '#FFBB75',
  'ha1e': '#FB4124',
  'neu': '#FF9A94',
  'npc': '#E57AC6',
  'cancer': '#1490C1',
  'immortalized normal': '#FF8000'
};
morpheus.VectorColorModel.getStandardColor = function (value) {
  if (value == null) {
    return '#ffffff';
  }
  var stringValue = value.toString().toLowerCase();
  return morpheus.VectorColorModel.STANDARD_COLORS[stringValue];

};
morpheus.VectorColorModel.getColorMapForNumber = function (length) {
  var colors;
  if (length < 3) {
    colors = colorbrewer.Set1[3];
  } else {
    colors = colorbrewer.Paired[length];
  }
  return colors ? colors : morpheus.VectorColorModel.TWENTY_COLORS;
};
morpheus.VectorColorModel.prototype = {
  toJSON: function () {
    var json = {};
    this.vectorNameToColorScheme.forEach(function (colorScheme, name) {
      var colorSchemeJSON = morpheus.AbstractColorSupplier.toJSON(colorScheme);
      colorSchemeJSON.continuous = true;
      json[name] = colorSchemeJSON;
    });
    this.vectorNameToColorMap.forEach(function (colorMap, name) {
      json[name] = colorMap;
    });
    return json;
  },
  fromJSON: function (json) {
    for (var name in json) {
      if (json.continuous) {
        this.vectorNameToColorScheme.set(name, morpheus.AbstractColorSupplier.fromJSON());
      } else {
        this.vectorNameToColorMap.set(name, morpheus.Map.fromJSON(json[name]));
      }
    }
  },
  clear: function (vector) {
    this.vectorNameToColorMap.remove(vector.getName());
    this.vectorNameToColorScheme.remove(vector.getName());
  },
  copy: function () {
    var c = new morpheus.VectorColorModel();
    c.colors = this.colors.slice(0);
    this.vectorNameToColorMap.forEach(function (colorMap, name) {
      var newColorMap = new morpheus.Map();
      newColorMap.setAll(colorMap); // copy existing values
      c.vectorNameToColorMap.set(name, newColorMap);
    });
    this.vectorNameToColorScheme.forEach(function (colorScheme, name) {
      c.vectorNameToColorScheme.set(name, colorScheme
        .copy(new morpheus.Project(new morpheus.Dataset({
          name: '',
          rows: 1,
          columns: 1
        }))));
    });
    return c;
  },
  clearAll: function () {
    this.vectorNameToColorMap = new morpheus.Map();
    this.vectorNameToColorScheme = new morpheus.Map();
  },
  containsDiscreteColor: function (vector, value) {
    var metadataValueToColorMap = this.vectorNameToColorMap.get(vector
      .getName());
    if (metadataValueToColorMap === undefined) {
      return false;
    }
    var c = metadataValueToColorMap.get(value);
    return c != null;
  },
  setDiscreteColorMap: function (colors) {
    this.colors = colors;
  },
  getContinuousColorScheme: function (vector) {
    return this.vectorNameToColorScheme.get(vector.getName());
  },
  getDiscreteColorScheme: function (vector) {
    return this.vectorNameToColorMap.get(vector.getName());
  },
  createContinuousColorMap: function (vector) {
    var minMax = morpheus.VectorUtil.getMinMax(vector);
    var min = minMax.min;
    var max = minMax.max;
    var cs = new morpheus.HeatMapColorScheme(new morpheus.Project(
      new morpheus.Dataset({
        name: '',
        rows: 1,
        columns: 1
      })), {
      type: 'fixed',
      map: [{
        value: min,
        color: colorbrewer.Greens[3][0]
      }, {
        value: max,
        color: colorbrewer.Greens[3][2]
      }]
    });
    this.vectorNameToColorScheme.set(vector.getName(), cs);
    return cs;

  },
  _getColorForValue: function (value) {
    var color = morpheus.VectorColorModel.getStandardColor(value);
    if (color == null) { // try to reuse existing color map
      var existingMetadataValueToColorMap = this.vectorNameToColorMap
        .values();
      for (var i = 0, length = existingMetadataValueToColorMap.length; i < length; i++) {
        color = existingMetadataValueToColorMap[i].get(value);
        if (color !== undefined) {
          return color;
        }
      }
    }
    return color;
  },
  getContinuousMappedValue: function (vector, value) {
    var cs = this.vectorNameToColorScheme.get(vector.getName());
    if (cs === undefined) {
      cs = this.createContinuousColorMap(vector);
    }
    return cs.getColor(0, 0, value);
  },
  getMappedValue: function (vector, value) {
    //console.log("getMappedValue", vector, value);
    var metadataValueToColorMap = this.vectorNameToColorMap.get(vector
      .getName());
    if (metadataValueToColorMap === undefined) {
      metadataValueToColorMap = new morpheus.Map();
      this.vectorNameToColorMap.set(vector.getName(),
        metadataValueToColorMap);
      // set all possible colors
      var values = morpheus.VectorUtil.getValues(vector);
      var ncolors = 0;
      var colors = null;
      if (values.length < 3) {
        colors = colorbrewer.Dark2[3];
      } else {
        colors = colorbrewer.Paired[values.length];
      }
      console.log("getMappedValue", colors);

      if (!colors) {
        if (values.length <= 20) {
          colors = d3.scale.category20().range();
        } else {
          colors = morpheus.VectorColorModel.CATEGORY_ALL;
        }
      }
      console.log("getMappedValue", colors);

      if (colors) {
        var ncolors = colors.length;
        for (var i = 0, nvalues = values.length; i < nvalues; i++) {
          var color = this._getColorForValue(values[i]);
          console.log(i, color, values[i], colors[i % ncolors]);
          if (color == null) {
            color = colors[i % ncolors];
          }
          metadataValueToColorMap.set(values[i], color);
        }
      } else {
        var _this = this;
        _.each(values, function (val) {
          _this.getMappedValue(vector, val);
        });
      }
      console.log(metadataValueToColorMap);
    }
    var color = metadataValueToColorMap.get(value);
    if (color == null) {
      color = this._getColorForValue(value);
      if (color == null) {
        var index = metadataValueToColorMap.size();
        color = this.colors[index % this.colors.length];
      }
      metadataValueToColorMap.set(value, color);
    }
    return color;
  },
  setMappedValue: function (vector, value, color) {
    var metadataValueToColorMap = this.vectorNameToColorMap.get(vector
      .getName());
    if (metadataValueToColorMap === undefined) {
      metadataValueToColorMap = new morpheus.Map();
      this.vectorNameToColorMap.set(vector.getName(),
        metadataValueToColorMap);
    }
    metadataValueToColorMap.set(value, color);
  }
};

/**
 * An interface for an ordered collection of values.
 *
 * @interface morpheus.VectorInterface
 */

/**
 * Returns the value at the specified index.
 *
 * @function
 * @name morpheus.VectorInterface#getValue
 * @param index the index
 * @return the value
 */

/**
 * Gets the key-value pairs associated with this vector.
 *
 * @function
 * @name morpheus.VectorInterface#getProperties
 * @return {morpheus.Map}
 */

/**
 * Returns the number of elements in this vector.
 *
 * @function
 * @name morpheus.VectorInterface#size
 * @return {number} the size.
 */

/**
 * Returns the name of this vector.
 *
 * @function
 * @name morpheus.VectorInterface#getName
 * @return {string} the name
 */




morpheus.VectorKeys = {};
/** [string] of field names in array */
morpheus.VectorKeys.FIELDS = 'morpheus.fields';
morpheus.VectorKeys.VALUE_TO_INDICES = 'morpheus.valueToIndices';
/** [int] of visible field indices in morpheus.VectorKeys.FIELDS */
morpheus.VectorKeys.VISIBLE_FIELDS = 'morpheus.visibleFields';
morpheus.VectorKeys.DATA_TYPE = 'morpheus.dataType';
/** Function to map an array to a single value for sorting */
morpheus.VectorKeys.ARRAY_SUMMARY_FUNCTION = 'morpheus.arraySummaryFunct';
/** Key for object (e.g. box plot) that summarizes data values */
morpheus.VectorKeys.HEADER_SUMMARY = 'morpheus.headerSummary';
/** Key indicating to show header summary */
morpheus.VectorKeys.SHOW_HEADER_SUMMARY = 'morpheus.showHeaderSummary';

morpheus.VectorKeys.TITLE = 'morpheus.title';
/** Function to compute vector value */
morpheus.VectorKeys.FUNCTION = 'morpheus.funct';

/** Indicates that vector values are dynamically computed based on selection */
morpheus.VectorKeys.SELECTION = 'morpheus.selection';

/** Whether to recompute a function when creating a new heat map */
morpheus.VectorKeys.RECOMPUTE_FUNCTION = 'morpheus.recompute.funct';

/** Boolean, whether to recompute a function when heat map selection changes */
morpheus.VectorKeys.RECOMPUTE_FUNCTION_SELECTION = 'morpheus.recompute.funct.selection';

morpheus.VectorKeys.COPY_IGNORE = new morpheus.Set();
morpheus.VectorKeys.COPY_IGNORE.add(morpheus.VectorKeys.HEADER_SUMMARY);
morpheus.VectorKeys.COPY_IGNORE.add(morpheus.VectorKeys.DATA_TYPE);
morpheus.VectorKeys.COPY_IGNORE.add(morpheus.VectorKeys.VALUE_TO_INDICES);

morpheus.VectorKeys.JSON_WHITELIST = new morpheus.Set();
morpheus.VectorKeys.JSON_WHITELIST.add(morpheus.VectorKeys.FIELDS);
morpheus.VectorKeys.JSON_WHITELIST.add(morpheus.VectorKeys.DATA_TYPE);
morpheus.VectorKeys.JSON_WHITELIST.add(morpheus.VectorKeys.TITLE);

morpheus.VectorShapeModel = function () {
  this.shapes = morpheus.VectorShapeModel.SHAPES;
  this.vectorNameToShapeMap = new morpheus.Map();
};

morpheus.VectorShapeModel.SHAPES = ['circle', 'square', 'plus', 'x',
  'asterisk', 'diamond', 'triangle-up', 'triangle-down', 'triangle-left',
  'triangle-right', 'minus'];
morpheus.VectorShapeModel.STANDARD_SHAPES = {
  cp: 'diamond',
  oe: 'plus',
  pcl: 'asterisk',
  kd: 'minus',
  ctrl: 'circle'
};

morpheus.VectorShapeModel.prototype = {
  clear: function (vector) {
    this.vectorNameToShapeMap.remove(vector.getName());
  },
  copy: function () {
    var c = new morpheus.VectorShapeModel();
    c.shapes = this.shapes.slice(0);
    this.vectorNameToShapeMap.forEach(function (shapeMap, name) {
      var newShapeMap = new morpheus.Map();
      newShapeMap.setAll(shapeMap); // copy existing values
      c.vectorNameToShapeMap.set(name, newShapeMap);
    });

    return c;
  },
  clearAll: function () {
    this.vectorNameToShapeMap = new morpheus.Map();
  },
  _getShapeForValue: function (value) {
    if (value == null) {
      return 'none';
    }
    var str = value.toString().toLowerCase();
    var mapped = morpheus.VectorShapeModel.STANDARD_SHAPES[str];
    if (mapped !== undefined) {
      return mapped;
    }

    // try to reuse existing map
    var existingMetadataValueToShapeMap = this.vectorNameToShapeMap
      .values();
    for (var i = 0, length = existingMetadataValueToShapeMap.length; i < length; i++) {
      var shape = existingMetadataValueToShapeMap[i].get(value);
      if (shape !== undefined) {
        return shape;
      }
    }

  },
  getMap: function (name) {
    return this.vectorNameToShapeMap.get(name);
  },
  getMappedValue: function (vector, value) {
    var metadataValueToShapeMap = this.vectorNameToShapeMap.get(vector
      .getName());
    if (metadataValueToShapeMap === undefined) {
      metadataValueToShapeMap = new morpheus.Map();
      this.vectorNameToShapeMap.set(vector.getName(),
        metadataValueToShapeMap);
      // set all possible shapes
      var values = morpheus.VectorUtil.getValues(vector);
      for (var i = 0, nvalues = values.length; i < nvalues; i++) {
        var shape = this._getShapeForValue(values[i]);
        if (shape == null) {
          shape = this.shapes[i % this.shapes.length];
        }
        metadataValueToShapeMap.set(values[i], shape);
      }
    }
    var shape = metadataValueToShapeMap.get(value);
    if (shape == null) {
      shape = this._getShapeForValue(value);
      if (shape == null) {
        var index = metadataValueToShapeMap.size();
        shape = this.shapes[index % this.shapes.length];
      }
      metadataValueToShapeMap.set(value, shape);
    }
    return shape;
  },
  setMappedValue: function (vector, value, shape) {
    var metadataValueToShapeMap = this.vectorNameToShapeMap.get(vector
      .getName());
    if (metadataValueToShapeMap === undefined) {
      metadataValueToShapeMap = new morpheus.Map();
      this.vectorNameToShapeMap.set(vector.getName(),
        metadataValueToShapeMap);
    }
    metadataValueToShapeMap.set(value, shape);
  }
};

morpheus.VectorUtil = function () {
};

morpheus.VectorUtil.jsonToFunction = function (vector, key) {
  var f = vector.getProperties().get(key);
  if (typeof f === 'object') {
    var binSize = f.binSize;
    var min = f.domain[0];
    var max = f.domain[1];
    var numberOfBins = Math.ceil((max - min) / binSize);
    var percent = f.percent;
    var cumulative = f.cumulative;
    var histogramFunction = function (view, selectedDataset, columnIndex) {
      var total = 0;
      var binNumberToOccurences = new Uint32Array(numberOfBins);
      for (var i = 0, nrows = selectedDataset.getRowCount(); i < nrows; i++) {
        var value = selectedDataset.getValue(i, columnIndex);
        if (!isNaN(value)) {
          if (value >= min && value <= max) {
            var bin = Math.floor(((value - min) / binSize));
            if (bin < 0) {
              bin = 0;
            } else if (bin >= numberOfBins) {
              bin = numberOfBins - 1;
            }
            binNumberToOccurences[bin]++;
          }
          total++;
        }
      }
      if (cumulative) {
        for (var i = numberOfBins - 2; i >= 0; i--) {
          binNumberToOccurences[i] += binNumberToOccurences[i + 1];
        }
      }
      if (percent) {
        var percents = new Float32Array(numberOfBins);
        for (var i = 0; i < numberOfBins; i++) {
          percents[i] = 100 * (binNumberToOccurences[i] / total);
        }
        return percents;
      }
      return binNumberToOccurences;
    };
    vector.getProperties().set(key, histogramFunction);
    var jsonSpec = f;
    f = histogramFunction;
    f.toJSON = function () {
      return jsonSpec;
    };
  }
  return f;
};
morpheus.VectorUtil.createValueToIndexMap = function (vector, splitArrayValues) {
  var map = new morpheus.Map();
  var isArray = splitArrayValues && morpheus.VectorUtil.getDataType(vector)[0] === '[';
  for (var j = 0, size = vector.size(); j < size; j++) {
    var val = vector.getValue(j);
    if (isArray) {
      if (val != null) {
        for (var k = 0; k < val.length; k++) {
          map.set(val[k], j);
        }
      }
    } else {
      map.set(val, j);
    }
  }
  return map;
};

morpheus.VectorUtil.createValueToIndicesMap = function (vector, splitArrayValues) {
  if (!vector) {
    throw 'vector is null';
  }
  var isArray = splitArrayValues && morpheus.VectorUtil.getDataType(vector)[0] === '[';
  var map = new morpheus.Map();
  for (var j = 0, size = vector.size(); j < size; j++) {
    var val = vector.getValue(j);
    if (isArray) {
      if (val != null) {
        for (var k = 0; k < val.length; k++) {
          var list = map.get(val[k]);
          if (list === undefined) {
            list = [];
            map.set(val[k], list);
          }
          list.push(j);
        }
      }
    } else {
      var list = map.get(val);
      if (list === undefined) {
        list = [];
        map.set(val, list);
      }
      list.push(j);
    }
  }
  return map;
};

morpheus.VectorUtil.createValueToCountMap = function (vector) {
  if (!vector) {
    throw 'vector is null';
  }
  var map = new morpheus.Map();
  var dataType = morpheus.VectorUtil.getDataType(vector);
  var isArray = dataType[0] === '[';
  for (var j = 0, size = vector.size(); j < size; j++) {
    var val = vector.getValue(j);
    if (val != null) {
      if (isArray) {
        for (var k = 0; k < val.length; k++) {
          var count = map.get(val[k]) || 0;
          map.set(val[k], count + 1);
        }
      } else {
        var count = map.get(val) || 0;
        map.set(val, count + 1);
      }
    }
  }
  return map;
};

morpheus.VectorUtil.createValuesToIndicesMap = function (vectors) {
  var map = new morpheus.Map();
  var nvectors = vectors.length;
  if (vectors[0] == null) {
    throw 'no vectors found';
  }
  for (var i = 0, nitems = vectors[0].size(); i < nitems; i++) {
    var array = [];
    for (var j = 0; j < nvectors; j++) {
      var vector = vectors[j];
      var val = vector.getValue(i);
      array.push(val);
    }
    var key = new morpheus.Identifier(array);
    var list = map.get(key);
    if (list === undefined) {
      list = [];
      map.set(key, list);
    }
    list.push(i);
  }
  return map;
};
morpheus.VectorUtil.createValuesToIndexMap = function (vectors) {
  var map = new morpheus.Map();
  var nvectors = vectors.length;
  if (vectors[0] == null) {
    throw 'no vectors found';
  }
  for (var i = 0, nitems = vectors[0].size(); i < nitems; i++) {
    var array = [];
    for (var j = 0; j < nvectors; j++) {
      var vector = vectors[j];
      var val = vector.getValue(i);
      array.push(val);
    }
    var key = new morpheus.Identifier(array);
    map.set(key, i);
  }
  return map;
};

morpheus.VectorUtil.createValuesToCountMap = function (vectors) {
  var map = new morpheus.Map();
  var nvectors = vectors.length;
  if (vectors[0] == null) {
    throw 'no vectors found';
  }
  for (var i = 0, nitems = vectors[0].size(); i < nitems; i++) {
    var array = [];
    for (var j = 0; j < nvectors; j++) {
      var vector = vectors[j];
      var val = vector.getValue(i);
      array.push(val);
    }
    var key = new morpheus.Identifier(array);
    var count = map.get(key) || 0;
    map.set(key, count + 1);
  }
  return map;
};

/**
 *
 * @param vector
 * @param excludeNull
 * @returns A sorted array of unique values contained in the vector. Note that array values are
 * not split.
 */
morpheus.VectorUtil.getValues = function (vector, excludeNull) {
  var set = new morpheus.Set();
  for (var j = 0, size = vector.size(); j < size; j++) {
    var val = vector.getValue(j);
    if (excludeNull && val == null) {
      continue;
    }
    set.add(val);
  }
  var array = set.values();
  array.sort(morpheus.SortKey.ASCENDING_COMPARATOR);
  return array;
};

morpheus.VectorUtil.getSet = function (vector, splitArrayValues) {
  var set = new morpheus.Set();
  var isArray = splitArrayValues && morpheus.VectorUtil.getDataType(vector)[0] === '[';
  for (var j = 0, size = vector.size(); j < size; j++) {
    var value = vector.getValue(j);
    if (isArray) {
      if (value != null) {
        for (var k = 0, nvalues = value.length; k < nvalues; k++) {
          set.add(value[k]);
        }
      }
    } else {
      set.add(value);
    }

  }
  return set;
};
morpheus.VectorUtil.maybeConvertToStringArray = function (vector, delim) {
  var newValues = [];
  var regex = new RegExp(delim);
  var found = false;

  for (var i = 0, nrows = vector.size(); i < nrows; i++) {
    var s = vector.getValue(i);
    if (s != null) {
      if (!s.split) {
        return false;
      }
      var tokens = s.split(regex);
      newValues.push(tokens);
      if (!found && tokens.length > 1) {
        found = true;
      }
    }

  }
  if (found) {
    for (var i = 0, nrows = newValues.length; i < nrows; i++) {
      vector.setValue(i, newValues[i]);
    }
    vector.getProperties().set(morpheus.VectorKeys.DATA_TYPE, '[string]');
  }

  return found;
};

morpheus.VectorUtil.maybeConvertStringToNumber = function (vector) {
  var newValues = [];
  var found = false;
  for (var i = 0, nrows = vector.size(); i < nrows; i++) {
    var s = vector.getValue(i);
    if (s != null && s !== '' && s !== 'NA' && s !== 'NaN') {
      if (!$.isNumeric(s)) {
        return false;
      } else {
        found = true;
      }
    }
    newValues.push(parseFloat(s));
  }
  if (!found) {
    return false;
  }
  for (var i = 0, nrows = newValues.length; i < nrows; i++) {
    vector.setValue(i, newValues[i]);
  }
  vector.getProperties().set(morpheus.VectorKeys.DATA_TYPE, 'number');
  return true;
};
morpheus.VectorUtil.containsMoreThanOneValue = function (vector) {
  return morpheus.VectorUtil.containsMoreThanNValues(vector, 1);
};
morpheus.VectorUtil.containsMoreThanNValues = function (vector, n) {
  var s = new morpheus.Set();
  for (var j = 0, size = vector.size(); j < size; j++) {
    var val = vector.getValue(j);
    s.add(val);
    if (s.size() > n) {
      return true;
    }
  }
  return false;
};

morpheus.VectorUtil.createSpanMap = function (vector) {
  var previous = vector.getValue(0);
  // find 1st row with different value
  var startIndexToEndIndex = new morpheus.Map();
  var start = 0;
  for (var i = 1, nrows = vector.size(); i < nrows; i++) {
    var val = vector.getValue(i);
    if (previous !== val) {
      previous = val;
      // start inclusive, end exclusive
      startIndexToEndIndex.set(start, i);
      start = i;
    }
  }
  startIndexToEndIndex.set(start, vector.size());
  return startIndexToEndIndex;
};
morpheus.VectorUtil.toArray = function (vector) {
  var array = [];
  for (var i = 0, length = vector.size(); i < length; i++) {
    var val = vector.getValue(i);
    array.push(val);
  }
  return array;
};

morpheus.VectorUtil.arrayAsVector = function (array, name) {
  var v = new morpheus.Vector(name, array.length);
  v.array = array;
  return v;
};
morpheus.VectorUtil.toString = function (vector) {
  var array = [];
  for (var i = 0, length = vector.size(); i < length; i++) {
    var val = vector.getValue(i);
    array.push(val);
  }
  return array.join(', ');
};

morpheus.VectorUtil.getDataType = function (vector) {
  var dataType = vector.getProperties().get(morpheus.VectorKeys.DATA_TYPE);
  if (dataType === undefined) {
    var firstNonNull = morpheus.VectorUtil.getFirstNonNull(vector);
    dataType = morpheus.Util.getDataType(firstNonNull);
    vector.getProperties().set(morpheus.VectorKeys.DATA_TYPE, dataType);
  }
  return dataType;

};

morpheus.VectorUtil.getMinMax = function (vector) {
  var min = Number.MAX_VALUE;
  var max = -Number.MAX_VALUE;
  var fields = vector.getProperties().get(morpheus.VectorKeys.FIELDS);
  var isArray = morpheus.VectorUtil.getDataType(vector)[0] === '[';
  if (fields != null) {
    var nvalues = fields.length;
    for (var i = 0, size = vector.size(); i < size; i++) {
      var array = vector.getValue(i);
      if (array) {
        for (var j = 0; j < nvalues; j++) {
          var value = array[j];
          if (!isNaN(value)) {
            min = value < min ? value : min;
            max = value > max ? value : max;
          }
        }
      }
    }
  } else if (isArray) {
    for (var i = 0, size = vector.size(); i < size; i++) {
      var array = vector.getValue(i);
      if (array != null) {
        for (var j = 0, nvalues = array.length; j < nvalues; j++) {
          var value = array[j];
          if (!isNaN(value)) {
            min = value < min ? value : min;
            max = value > max ? value : max;
          }
        }
      }
    }
  } else {
    for (var i = 0, size = vector.size(); i < size; i++) {
      var value = vector.getValue(i);
      if (!isNaN(value)) {
        min = value < min ? value : min;
        max = value > max ? value : max;
      }
    }
  }
  return {
    min: min,
    max: max
  };
}
;
morpheus.VectorUtil.getFirstNonNull = function (vector) {
  for (var i = 0, length = vector.size(); i < length; i++) {
    var val = vector.getValue(i);
    if (val != null) {
      return val;
    }
  }
  return null;
};
morpheus.VectorUtil.isNumber = function (vector) {
  return morpheus.VectorUtil.getDataType(vector) === 'number';
};

/**
 * An ordered collection of values.
 *
 * Creates a new vector with the given name and size.
 *
 * @param name
 *            the vector name
 * @param size
 *            the number of elements in this vector
 * @constructor
 */
morpheus.Vector = function (name, size) {
  this.array = [];
  morpheus.AbstractVector.call(this, name, size);
};
/**
 * @static
 */
morpheus.Vector.fromArray = function (name, array) {
  var v = new morpheus.Vector(name, array.length);
  v.array = array;
  return v;
};
morpheus.Vector.prototype = {
  /**
   * @ignore
   * @param value
   */
  push: function (value) {
    this.array.push(value);
  },
  /**
   * Sets the value at the specified index.
   *
   * @param index
   *            the index
   * @param value
   *            the value
   */
  setValue: function (index, value) {
    this.array[index] = value;
  },
  getValue: function (index) {
    return this.array[index];
  },
  /**
   * @ignore
   * @param name
   */
  setName: function (name) {
    this.name = name;
  },
  /**
   * @ignore
   * @param array
   * @returns {morpheus.Vector}
   */
  setArray: function (array) {
    this.array = array;
    return this;
  }
};
morpheus.Util.extend(morpheus.Vector, morpheus.AbstractVector);

morpheus.LandingPage = function (pageOptions) {
  pageOptions = $.extend({}, {
    el: $('#vis')
  }, pageOptions);
  this.pageOptions = pageOptions;
  var _this = this;

  var $el = $('<div class="container" style="display: none;"></div>');
  this.$el = $el;
  var html = [];
  html.push('<div data-name="help" class="pull-right"></div>');

  html
    .push('<div style="margin-bottom:10px;"><svg width="32px" height="32px"><g><rect x="0" y="0" width="32" height="14" style="fill:#ca0020;stroke:none"/><rect x="0" y="18" width="32" height="14" style="fill:#0571b0;stroke:none"/></g></svg> <div data-name="brand" style="display:inline-block; vertical-align: top;font-size:24px;font-family:sans-serif;">');
  html.push('<span>M</span>');
  html.push('<span>o</span>');
  html.push('<span>r</span>');
  html.push('<span>p</span>');
  html.push('<span>h</span>');
  html.push('<span>e</span>');
  html.push('<span>u</span>');
  html.push('<span>s</span>');
  html.push('</span>');
  html.push('</div>');

  html.push('<h4>Open your own file</h4>');
  html.push('<div data-name="formRow" class="center-block"></div>');
  html.push('<div style="display: none;" data-name="preloadedDataset"><h4>Or select a preloaded' +
    ' dataset</h4></div>');
  html.push('</div>');
  var $html = $(html.join(''));
  var colorScale = d3.scale.linear().domain([0, 4, 7]).range(['#ca0020', '#999999', '#0571b0']).clamp(true);
  var brands = $html.find('[data-name="brand"] > span');
  $html.appendTo($el);
  new morpheus.HelpMenu().$el.appendTo($el.find('[data-name=help]'));
  var formBuilder = new morpheus.FormBuilder();
  formBuilder.append({
    name: 'file',
    showLabel: false,
    value: '',
    type: 'file',
    required: true,
    help: morpheus.DatasetUtil.DATASET_FILE_FORMATS
  });
  formBuilder.$form.appendTo($el.find('[data-name=formRow]'));
  this.formBuilder = formBuilder;
  this.$sampleDatasetsEl = $el.find('[data-name=preloadedDataset]');
  var index = 0;
  var step = function () {
    brands[index].style.color = colorScale(index);
    index++;
    if (index < brands.length) {
      setTimeout(step, 200);
    }
  };
  setTimeout(step, 300);
  this.tabManager = new morpheus.TabManager({landingPage: this});
  this.tabManager.on('change rename add remove', function (e) {
    var title = _this.tabManager.getTabText(_this.tabManager.getActiveTabId());
    if (title == null || title === '') {
      title = 'Morpheus';
    }
    document.title = title;
  });

  this.tabManager.$nav.appendTo($(this.pageOptions.el));
  this.tabManager.$tabContent.appendTo($(this.pageOptions.el));
  // for (var i = 0; i < brands.length; i++) {
  // 	brands[i].style.color = colorScale(i);
  // }
};

morpheus.LandingPage.prototype = {
  open: function (openOptions) {
    this.dispose();
    var optionsArray = _.isArray(openOptions) ? openOptions : [openOptions];
    var _this = this;
    for (var i = 0; i < optionsArray.length; i++) {
      var options = optionsArray[i];
      options.tabManager = _this.tabManager;
      options.focus = i === 0;
      options.landingPage = _this;
      new morpheus.HeatMap(options);
    }

  },
  dispose: function () {
    this.formBuilder.setValue('file', '');
    this.$el.hide();
    $(window)
      .off(
        'paste.morpheus drop.morpheus dragover.morpheus dragenter.morpheus');
    this.formBuilder.off('change');
  },
  show: function () {
    var _this = this;
    if (navigator.onLine && !this.sampleDatasets) {
      this.sampleDatasets = new morpheus.SampleDatasets({
        $el: this.$sampleDatasetsEl,
        show: true,
        callback: function (heatMapOptions) {
          _this.open(heatMapOptions);
        }
      });
    }

    this.$el.show();

    this.formBuilder.on('change', function (e) {
      var value = e.value;
      if (value !== '' && value != null) {
        _this.openFile(value);
      }
    });

    $(window).on('beforeunload.morpheus', function () {
      if (_this.tabManager.getTabCount() > 0) {
        return 'Are you sure you want to close Morpheus?';
      }
    });
    $(window).on('paste.morpheus', function (e) {
      var tagName = e.target.tagName;
      if (tagName == 'INPUT' || tagName == 'SELECT' || tagName == 'TEXTAREA') {
        return;
      }

      var text = e.originalEvent.clipboardData.getData('text/plain');
      if (text != null && text.length > 0) {
        e.preventDefault();
        e.stopPropagation();
        var url;
        if (text.indexOf('http') === 0) {
          url = text;
        } else {
          var blob = new Blob([text]);
          url = window.URL.createObjectURL(blob);
        }

        _this.openFile(url);
      }

    }).on('dragover.morpheus dragenter.morpheus', function (e) {
      e.preventDefault();
      e.stopPropagation();
    }).on(
      'drop.morpheus',
      function (e) {
        if (e.originalEvent.dataTransfer
          && e.originalEvent.dataTransfer.files.length) {
          e.preventDefault();
          e.stopPropagation();
          var files = e.originalEvent.dataTransfer.files;
          _this.openFile(files[0]);
        } else if (e.originalEvent.dataTransfer) {
          var url = e.originalEvent.dataTransfer.getData('URL');
          e.preventDefault();
          e.stopPropagation();
          _this.openFile(url);
        }
      });
  },
  openFile: function (value) {
    var _this = this;
    var fileName = morpheus.Util.getFileName(value);
    if (fileName.toLowerCase().indexOf('.json') === fileName.length - 5) {
      morpheus.Util.getText(value).done(function (text) {
        _this.open(JSON.parse(text));
      }).fail(function (err) {
        morpheus.FormBuilder.showMessageModal({
          title: 'Error',
          message: 'Unable to load session'
        });
      });
    } else {
      var options = {
        dataset: {
          file: value,
          options: {interactive: true}
        }
      };

      morpheus.OpenDatasetTool.fileExtensionPrompt(fileName, function (readOptions) {
        if (readOptions) {
          for (var key in readOptions) {
            options.dataset.options[key] = readOptions[key];
          }
        }
        _this.open(options);
      });
    }
  }
};

morpheus.SampleDatasets = function (options) {
  if (!options.openText) {
    options.openText = 'Open';
  }
  var _this = this;
  var $el = options.$el;
  this.callback = options.callback;
  $el.on('click', '[name=ccle]', function (e) {
    var $this = $(this);
    var obj = {};
    $this.parents('tr').find('input:checked').each(function (i, c) {
      obj[$(c).data('type')] = true;
    });

    _this.openCCLE(obj);
    e.preventDefault();
  });

  $el.on('click', '[name=tcgaLink]', function (e) {
    e.preventDefault();
    var $this = $(this);
    var type = $this.data('disease-type');
    var obj = {};
    $this.parents('tr').find('input:checked').each(function (i, c) {
      obj[$(c).data('type')] = true;
    });
    var disease;
    for (var i = 0; i < _this.diseases.length; i++) {
      if (_this.diseases[i].type === type) {
        disease = _this.diseases[i];
        break;
      }
    }
    obj.type = type;
    obj.name = disease.name;
    _this.openTcga(obj);
  });
  $el
    .on(
      'click',
      '[data-toggle=dataTypeToggle]',
      function (e) {
        var $this = $(this);
        var $button = $this.parents('tr').find('button');
        var isDisabled = $this.parents('tr').find(
            'input:checked').length === 0;
        $button.prop('disabled', isDisabled);
        if (!isDisabled) {
          $button
            .removeClass('animated flash')
            .addClass('animated flash')
            .one(
              'webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend',
              function () {
                $(this).removeClass(
                  'animated flash');
              });
        }
      });
  $
    .ajax(
      'https://s3.amazonaws.com/data.clue.io/morpheus/tcga/tcga_index.txt')
    .done(
      function (text) {
        var exampleHtml = [];
        exampleHtml.push('<table class="table table-condensed table-bordered">');
        exampleHtml.push('<thead><tr><th>Name</th><th>Gene' +
          ' Expression</th><th>Copy Number By Gene</th><th>Mutations</th><th>Gene' +
          ' Essentiality</th><th></th></tr></thead>');
        exampleHtml.push('<tbody>');
        exampleHtml.push('<tr>');
        exampleHtml
          .push('<td>Cancer Cell Line Encyclopedia (CCLE), Project Achilles</td>');
        exampleHtml
          .push('<td><input type="checkbox" style="margin-left:4px;" data-toggle="dataTypeToggle" data-type="mrna"> </td>');

        exampleHtml
          .push('<td><input type="checkbox" style="margin-left:4px;" data-toggle="dataTypeToggle" data-type="cn"> </td>');

        exampleHtml
          .push('<td><input type="checkbox" style="margin-left:4px;" data-toggle="dataTypeToggle" data-type="sig_genes"> </td>');

        exampleHtml
          .push('<td><input type="checkbox" style="margin-left:4px;" data-toggle="dataTypeToggle" data-type="ach"> </td>');

        exampleHtml
          .push('<td><button disabled type="button" class="btn btn-link" name="ccle">'
            + options.openText + '</button></td>');
        exampleHtml.push('</tr></tbody></table>');

        exampleHtml
          .push('<div class="text-muted">TCGA data version 1/11/2015</div><span class="text-muted">Please adhere to <a target="_blank" href="http://cancergenome.nih.gov/abouttcga/policies/publicationguidelines"> the TCGA publication guidelines</a></u> when using TCGA data in your publications.</span>');

        exampleHtml.push('<div data-name="tcga"></div>');
        $(exampleHtml.join('')).appendTo($el);
        if (options.show) {
          $el.show();
        }
        var lines = text.split('\n');
        var diseases = [];
        for (var i = 0; i < lines.length; i++) {
          var line = lines[i];
          if (line === '') {
            continue;
          }
          var tokens = line.split('\t');
          var type = tokens[0];
          var dataTypes = tokens[1].split(',');
          var name = morpheus.TcgaUtil.DISEASE_STUDIES[type];
          var disease = {
            mrna: dataTypes
              .indexOf('mRNAseq_RSEM_normalized_log2.txt') !== -1,
            sig_genes: dataTypes.indexOf('sig_genes.txt') !== -1,
            gistic: dataTypes
              .indexOf('all_lesions.conf_99.txt') !== -1,
            sample_info: dataTypes.indexOf('All_CDEs.txt') !== -1,
            mutation: dataTypes
              .indexOf('mutations_merged.maf.txt') !== -1,
            rppa: dataTypes.indexOf('rppa.txt') !== -1,
            methylation: dataTypes
              .indexOf('meth.by_mean.data.txt') !== -1,
            name: name,
            type: type,
            dataTypes: dataTypes
          };
          if (disease.mrna || disease.gistic
            || disease.sig_genes || disease.rppa
            || disease.methylation) {
            diseases.push(disease);
          }
        }
        diseases.sort(function (a, b) {
          a = a.name.toLowerCase();
          b = b.name.toLowerCase();
          return (a === b ? 0 : (a < b ? -1 : 1));

        });
        var tcga = [];
        _this.diseases = diseases;

        tcga.push('<table class="table table-condensed table-bordered">');
        tcga.push('<thead><tr>');
        tcga.push('<th>Disease</th>');
        tcga.push('<th>Gene Expression</th>');
        tcga.push('<th>GISTIC Copy Number</th>');
        tcga.push('<th>Copy Number By Gene</th>');
        tcga.push('<th>Mutations</th>');
        tcga.push('<th>Proteomics</th>');
        tcga.push('<th>Methylation</th>');
        tcga.push('<th></th>');
        tcga.push('</tr></thead>');
        tcga.push('<tbody>');
        for (var i = 0; i < diseases.length; i++) {
          var disease = diseases[i];
          tcga.push('<tr>');

          tcga.push('<td>' + disease.name + '</td>');
          tcga.push('<td>');
          if (disease.mrna) {
            tcga
              .push('<input type="checkbox" style="margin-left:4px;" data-toggle="dataTypeToggle" data-type="mrna"> ');
          }
          tcga.push('</td>');

          tcga.push('<td>');
          if (disease.gistic) {
            tcga
              .push('<input type="checkbox" style="margin-left:4px;" data-toggle="dataTypeToggle" data-type="gistic"> ');
          }
          tcga.push('</td>');

          tcga.push('<td>');
          if (disease.gistic) {
            tcga
              .push('<input type="checkbox" style="margin-left:4px;" data-toggle="dataTypeToggle" data-type="gisticGene"> ');
          }
          tcga.push('</td>');

          tcga.push('<td>');
          if (disease.sig_genes) {
            tcga
              .push('<input type="checkbox" style="margin-left:4px;" data-toggle="dataTypeToggle" data-type="sig_genes"> ');
          }
          tcga.push('</td>');

          tcga.push('<td>');
          if (disease.rppa) {
            tcga
              .push('<input type="checkbox" style="margin-left:4px;" data-toggle="dataTypeToggle" data-type="rppa"> ');
          }
          tcga.push('</td>');
          tcga.push('<td>');
          if (disease.methylation) {
            tcga
              .push('<input type="checkbox" style="margin-left:4px;" data-toggle="dataTypeToggle" data-type="methylation"> ');
          }
          tcga.push('</td>');

          tcga
            .push('<td><button disabled type="button" class="btn btn-link" name="tcgaLink" data-disease-type="'
              + disease.type
              + '">'
              + options.openText
              + '</button></td>');

          tcga.push('</tr>');
        }
        tcga.push('</tbody>');
        tcga.push('</table>');
        $(tcga.join('')).appendTo($el.find('[data-name=tcga]'));
      });
};

morpheus.SampleDatasets.getTcgaDataset = function (options) {
  var baseUrl = 'https://s3.amazonaws.com/data.clue.io/morpheus/tcga/'
    + options.type + '/';
  var datasetOptions = {};
  if (options.mrna) {
    datasetOptions.mrna = baseUrl + 'mRNAseq_RSEM_normalized_log2.txt';
  }

  if (options.methylation) {
    datasetOptions.methylation = baseUrl + 'meth.by_mean.data.txt';
  }
  if (options.sig_genes) {
    datasetOptions.mutation = baseUrl + 'mutations_merged.maf.txt';
    datasetOptions.sigGenes = baseUrl + 'sig_genes.txt';
  }
  // datasetOptions.seg = baseUrl + 'snp.seg.txt';
  if (options.rppa) {
    datasetOptions.rppa = baseUrl + 'rppa.txt';
  }
  if (options.gistic) {
    datasetOptions.gistic = baseUrl + 'all_lesions.conf_99.txt';
  }
  if (options.gisticGene) {
    datasetOptions.gisticGene = baseUrl + 'all_data_by_genes.txt';
  }

  datasetOptions.mrnaClust = baseUrl + 'bestclus.txt';

  datasetOptions.columnAnnotations = [{
    file: baseUrl + 'All_CDEs.txt',
    datasetField: 'participant_id',
    fileField: 'patient_id'
  }];
  return morpheus.TcgaUtil.getDataset(datasetOptions);

};
morpheus.SampleDatasets.getCCLEDataset = function (options) {
  var datasets = [];
  if (options.sig_genes) {
    datasets
      .push('https://s3.amazonaws.com/data.clue.io/morpheus/CCLE_hybrid_capture1650_hg19_NoCommonSNPs_NoNeutralVariants_CDS_2012.05.07.maf.txt');
    // datasets
    // .push({
    // dataset :
    // '//s3.amazonaws.com/data.clue.io/morpheus/1650_HC_plus_RD_muts.maf.txt'
    // });
  }
  if (options.cn) {
    datasets
      .push('https://s3.amazonaws.com/data.clue.io/morpheus/CCLE_copynumber_byGene_2013-12-03.gct');
  }

  if (options.mrna) {
    datasets
      .push('https://s3.amazonaws.com/data.clue.io/morpheus/CCLE_Expression_Entrez_2012-09-29.txt');
  }
  if (options.ach) {
    datasets
      .push('https://s3.amazonaws.com/data.clue.io/morpheus/Achilles_QC_v2.4.3.rnai.Gs.gct');
  }
  var columnAnnotations = [];
  if (options.ach) {
    // there are several cell lines that are in Achilles but not CCLE
    columnAnnotations
      .push({
        file: 'https://s3.amazonaws.com/data.clue.io/morpheus/Achilles_v2.4_SampleInfo_small.txt',
        datasetField: 'id',
        fileField: 'id'
      });

  }
  columnAnnotations.push({
    file: 'https://s3.amazonaws.com/data.clue.io/morpheus/CCLE_Sample_Info.txt',
    datasetField: 'id',
    fileField: 'id'
  });

  var returnDeferred = $.Deferred();
  var datasetDef = morpheus.DatasetUtil.readDatasetArray(datasets);

  var annotationDef = morpheus.DatasetUtil.annotate({
    annotations: columnAnnotations,
    isColumns: true
  });
  var datasetToReturn;
  datasetDef.done(function (d) {
    datasetToReturn = d;
  });
  datasetDef.fail(function (message) {
    returnDeferred.reject(message);
  });
  var annotationCallbacks;
  annotationDef.done(function (callbacks) {
    annotationCallbacks = callbacks;
  });
  annotationDef.fail(function (message) {
    returnDeferred.reject(message);
  });

  $.when.apply($, [datasetDef, annotationDef]).then(function () {

    annotationCallbacks.forEach(function (f) {
      f(datasetToReturn);
    });
    morpheus.DatasetUtil.toESSessionPromise(datasetToReturn);
    returnDeferred.resolve(datasetToReturn);
  });

  return returnDeferred;
};
morpheus.SampleDatasets.prototype = {

  openTcga: function (options) {
    this
      .callback({
        name: options.name,
        renderReady: function (heatMap) {
          var whitelist = [
            'age_at_initial_pathologic_diagnosis',
            'breast_carcinoma_estrogen_receptor_status',
            'breast_carcinoma_progesterone_receptor_status',
            'lab_proc_her2_neu_immunohistochemistry_receptor_status',
            'days_to_death', 'ethnicity', 'gender',
            'histological_type', 'pathologic_stage'];

          var columnMetadata = heatMap.getProject()
            .getFullDataset().getColumnMetadata();
          for (var i = 0; i < whitelist.length; i++) {
            if (columnMetadata.getByName(whitelist[i])) {
              heatMap.addTrack(whitelist[i], true, 'color');
            }
          }
          // view in space of mutation sample ids only
          if (options.sig_genes) {
            if (heatMap.getTrackIndex('q_value', false) === -1) {
              heatMap.addTrack('q_value', false, 'text');
            }
          }
        },
        columns: [{
          field: 'participant_id',
          display: 'text'
        }, {
          field: 'sample_type',
          display: 'color'
        }, {
          field: 'mutation_summary',
          display: 'stacked_bar'
        }, {
          field: 'mutation_summary_selection',
          display: 'stacked_bar'
        }, {
          field: 'mRNAseq_cluster',
          display: 'color, highlight'
        }],
        dataset: morpheus.SampleDatasets.getTcgaDataset(options)
      });
  },
  openCCLE: function (options) {
    this.callback({
      name: 'CCLE',
      rows: [{
        field: 'id',
        display: 'text,tooltip'
      }, {
        field: 'mutation_summary',
        display: 'stacked_bar'
      }, {
        field: 'Source',
        display: 'color'
      }],
      columns: [{
        field: 'id',
        display: 'text,tooltip'
      }, {
        field: 'mutation_summary',
        display: 'stacked_bar'
      }, {
        field: 'gender',
        display: 'color, highlight'
      }, {
        field: 'histology',
        display: 'color, highlight'
      }, {
        field: 'histology subtype',
        display: 'color, highlight'
      }, {
        field: 'primary_site',
        display: 'color, highlight'
      }],
      dataset: morpheus.SampleDatasets.getCCLEDataset(options)
    });
  }
};

morpheus.AdjustDataTool = function () {
};
morpheus.AdjustDataTool.prototype = {
  toString: function () {
    return 'Adjust';
  },
  gui: function () {
    // z-score, robust z-score, log2, inverse log2
    return [{
      name: 'log_2',
      type: 'checkbox'
    }, {
      name: 'inverse_log_2',
      type: 'checkbox'
    }, {
      name: 'quantile_normalize',
      type: 'checkbox'
    }, {
      name: 'z-score',
      type: 'checkbox',
      help: 'Subtract mean, divide by standard deviation'
    }, {
      name: 'robust_z-score',
      type: 'checkbox',
      help: 'Subtract median, divide by median absolute deviation'
    }, {
      name: 'use_selected_rows_and_columns_only',
      type: 'checkbox'
    }];
  },
  execute: function (options) {
    var project = options.project;
    var heatMap = options.heatMap;

    if (options.input.log_2 || options.input.inverse_log_2
      || options.input['z-score'] || options.input['robust_z-score'] || options.input.quantile_normalize) {
      // clone the values 1st
      var sortedFilteredDataset = morpheus.DatasetUtil.copy(project
        .getSortedFilteredDataset());
      var rowIndices = project.getRowSelectionModel()
        .getViewIndices().values().sort(
          function (a, b) {
            return (a === b ? 0 : (a < b ? -1 : 1));
          });
      if (rowIndices.length === 0) {
        rowIndices = null;
      }
      var columnIndices = project.getColumnSelectionModel()
        .getViewIndices().values().sort(
          function (a, b) {
            return (a === b ? 0 : (a < b ? -1 : 1));
          });
      if (columnIndices.length === 0) {
        columnIndices = null;
      }
      var dataset = options.input.use_selected_rows_and_columns_only ? new morpheus.Slice
        : sortedFilteredDataset;
      var rowView = new morpheus.DatasetRowView(dataset);
      var functions = [];
      var changed = false;
      if (options.input.log_2) {
        for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
          for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
            dataset.setValue(i, j, morpheus.Log2(dataset.getValue(
              i, j)));
          }
        }
        changed = true;
      }
      if (options.input.inverse_log_2) {
        for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
          for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
            var value = dataset.getValue(i, j);
            if (value >= 0) {
              dataset.setValue(i, j, Math.pow(2, value));
            }
          }
        }
        changed = true;
      }
      if (options.input.quantile_normalize) {
        morpheus.QNorm.execute(dataset);
        changed = true;
      }
      if (options.input['z-score']) {
        for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
          rowView.setIndex(i);
          var mean = morpheus.Mean(rowView);
          var stdev = Math.sqrt(morpheus.Variance(rowView));
          for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
            dataset.setValue(i, j, (dataset.getValue(i, j) - mean)
              / stdev);
          }
        }
      }
      if (options.input['robust_z-score']) {
        for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
          rowView.setIndex(i);
          var median = morpheus.Median(rowView);
          var mad = morpheus.MAD(rowView, median);
          for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
            dataset.setValue(i, j,
              (dataset.getValue(i, j) - median) / mad);
          }
        }
        changed = true;
      }

      /* if (changed) {
       morpheus.DatasetUtil.toESSessionPromise(dataset);
       }*/
      return new morpheus.HeatMap({
        name: heatMap.getName(),
        dataset: dataset,
        parent: heatMap,
        symmetric: project.isSymmetric() && dataset.getColumnCount() === dataset.getRowCount()
      });
    }
  }
};
morpheus.AnnotateDendrogramTool = function (isColumns) {
  this._isColumns = isColumns;
};
morpheus.AnnotateDendrogramTool.prototype = {
  toString: function () {
    return 'Annotate Dendrogram';
  },
  gui: function () {
    return [{
      name: 'file',
      value: '',
      type: 'file',
      required: true,
      help: 'an xlsx file or a tab-delimitted text file'
    }];
  },
  execute: function (options) {
    var fileOrUrl = options.input.file;
    var isColumns = this._isColumns;
    var heatMap = options.heatMap;
    var result = morpheus.Util.readLines(fileOrUrl);
    var fileName = morpheus.Util.getFileName(fileOrUrl);
    var dendrogram = isColumns ? heatMap.columnDendrogram
      : heatMap.rowDendrogram;
    var nameToNode = new morpheus.Map();
    morpheus.DendrogramUtil.dfs(dendrogram.tree.rootNode,
      function (node) {
        nameToNode.set(node.name, node);
        return true;
      });
    var tab = /\t/;
    result.done(function (lines) {
      var header = lines[0].split(tab);
      var promptTool = {};
      // node.info = {foo:['a', 'b'], bar:[3]}
      promptTool.execute = function (options) {
        var nodeIdField = options.input.node_id_field;
        var nodeIdIndex = _.indexOf(header, nodeIdField);
        var numberOfMatchingNodes = 0;
        for (var i = 1; i < lines.length; i++) {
          var array = lines[i].split(tab);
          var nodeName = array[nodeIdIndex];
          var node = nameToNode.get(nodeName);
          if (node !== undefined) {
            numberOfMatchingNodes++;
            var info = node.info || (node.info = {});
            for (var j = 0; j < array.length; j++) {
              if (j === nodeIdIndex) {
                continue;
              }
              var vals = info[header[j]];
              if (vals === undefined) {
                vals = [];
                info[header[j]] = vals;
              }
              vals.push(array[j]);
            }
          }
        }
        heatMap.trigger('dendrogramAnnotated', {
          isColumns: isColumns
        });
        dendrogram.setInvalid(true);
        dendrogram.repaint();
      };
      promptTool.toString = function () {
        return 'Select Node Id Field';
      };
      promptTool.gui = function () {
        return [{
          name: 'node_id_field',
          type: 'select',
          options: _.map(header, function (item) {
            return {
              name: item,
              value: item
            };
          }),
          required: true
        }];
      };
      morpheus.HeatMap.showTool(promptTool, heatMap);
    });
  }
};

/**
 * @param chartOptions.project
 *            morpheus.Project
 * @param chartOptions.getVisibleTrackNames
 *            {Function}
 */
morpheus.ChartTool = function (chartOptions) {
  var _this = this;
  this.getVisibleTrackNames = chartOptions.getVisibleTrackNames;
  this.project = chartOptions.project;
  var project = this.project;
  this.$el = $('<div class="container-fluid">'
    + '<div class="row">'
    + '<div data-name="configPane" class="col-xs-2"></div>'
    + '<div class="col-xs-10"><div style="position:relative;" data-name="chartDiv"></div></div>'
    + '</div></div>');

  var formBuilder = new morpheus.FormBuilder({
    vertical: true
  });
  this.formBuilder = formBuilder;
  formBuilder.append({
    name: 'chart_type',
    type: 'bootstrap-select',
    options: ['boxplot', 'row scatter matrix', 'column scatter matrix', 'row' +
    ' profile', 'column' +
    ' profile']
  });
  var rowOptions = [];
  var columnOptions = [];
  var numericRowOptions = [];
  var numericColumnOptions = [];
  var options = [];
  var numericOptions = [];
  var updateOptions = function () {
    var dataset = project.getFullDataset();
    rowOptions = [{
      name: '(None)',
      value: ''
    }];
    columnOptions = [{
      name: '(None)',
      value: ''
    }];
    numericRowOptions = [{
      name: '(None)',
      value: ''
    }];
    numericColumnOptions = [{
      name: '(None)',
      value: ''
    }];
    options = [{
      name: '(None)',
      value: ''
    }];
    numericOptions = [{
      name: '(None)',
      value: ''
    }];

    morpheus.MetadataUtil.getMetadataNames(dataset.getRowMetadata())
      .forEach(
        function (name) {
          var dataType = morpheus.VectorUtil
            .getDataType(dataset.getRowMetadata()
              .getByName(name));
          if (dataType === 'number'
            || dataType === '[number]') {
            numericRowOptions.push({
              name: name + ' (row)',
              value: name + '_r'
            });
          }
          rowOptions.push({
            name: name + ' (row)',
            value: name + '_r'
          });
        });

    morpheus.MetadataUtil.getMetadataNames(dataset.getColumnMetadata())
      .forEach(
        function (name) {
          var dataType = morpheus.VectorUtil
            .getDataType(dataset.getColumnMetadata()
              .getByName(name));
          if (dataType === 'number'
            || dataType === '[number]') {
            numericColumnOptions.push({
              name: name + ' (column)',
              value: name + '_c'
            });
          }
          columnOptions.push({
            name: name + ' (column)',
            value: name + '_c'
          });
        });

    options = options.concat(rowOptions.slice(1));
    options = options.concat(columnOptions.slice(1));

    numericOptions = numericOptions.concat(numericRowOptions.slice(1));
    numericOptions = numericOptions.concat(numericColumnOptions.slice(1));
  };

  updateOptions();
  formBuilder.append({
    name: 'group_columns_by',
    type: 'bootstrap-select',
    options: options
  });
  formBuilder.append({
    name: 'group_rows_by',
    type: 'bootstrap-select',
    options: options
  });

  formBuilder.append({
    name: 'axis_label',
    type: 'bootstrap-select',
    options: rowOptions
  });
  formBuilder.append({
    name: 'show_points',
    type: 'checkbox',
    value: true
  });

  formBuilder.append({
    name: 'color',
    type: 'bootstrap-select',
    options: options
  });

  formBuilder.append({
    name: 'size',
    type: 'bootstrap-select',
    options: numericOptions
  });
  formBuilder.append({
    name: 'tooltip',
    type: 'bootstrap-select',
    multiple: true,
    search: true,
    options: options.slice(1)
  });

  formBuilder.append({
    name: 'chart_width',
    type: 'range',
    value: 400,
    min: 60,
    max: 800,
    step: 10
  });
  formBuilder.append({
    name: 'chart_height',
    type: 'range',
    value: 400,
    min: 20,
    max: 800,
    step: 10
  });

  // series filter for boxplot
  formBuilder.addSeparator();
  var boxPlotFormNames = ['series', 'lower_selector', 'lower', 'upper_selector', 'upper'];
  formBuilder.append({
    name: 'series',
    type: 'bootstrap-select',
    options: ['(None)'].concat(morpheus.DatasetUtil
      .getSeriesNames(project.getFullDataset()))
  });
  formBuilder.append({
    showLabel: false,
    name: 'lower_selector',
    type: 'bootstrap-select',
    options: [{
      value: 'gte',
      name: '&gt;='
    }, {
      value: 'gt',
      name: '&gt;'
    }]
  });
  formBuilder.append({
    showLabel: false,
    name: 'lower',
    type: 'text'
  });

  formBuilder.append({
    showLabel: false,
    name: 'upper_selector',
    type: 'bootstrap-select',
    options: [{
      value: 'lte',
      name: '&lt;='
    }, {
      value: 'lt',
      name: '&lt;='
    }]
  });
  formBuilder.append({
    showLabel: false,
    name: 'upper',
    type: 'text'
  });

  function setVisibility() {
    var chartType = formBuilder.getValue('chart_type');
    if (chartType !== 'boxplot' && chartType !== 'histogram') {
      formBuilder.setOptions('axis_label',
        (chartType === 'row scatter matrix' || chartType === 'column profile') ? rowOptions : columnOptions,
        true);
      formBuilder.setOptions('color',
        (chartType === 'row scatter matrix' || chartType === 'column profile') ? columnOptions : rowOptions,
        true);
      formBuilder.setOptions('size',
        (chartType === 'row scatter matrix' || chartType === 'row profile') ? numericColumnOptions
          : numericRowOptions, true);

    } else {
      formBuilder.setOptions('color', options, true);
      formBuilder.setOptions('size', numericOptions, true);
    }
    boxPlotFormNames.forEach(function (name) {
      formBuilder.setVisible(name, chartType === 'boxplot');
    });

    formBuilder.setVisible('chart_width', chartType !== 'row profile' && chartType !== 'column profile');
    formBuilder.setVisible('chart_height', chartType !== 'row profile' && chartType !== 'column profile');
    formBuilder.setVisible('tooltip', chartType !== 'histogram');
    formBuilder.setVisible('group_rows_by', (chartType === 'boxplot' || chartType === 'histogram' || chartType === 'ecdf'));
    formBuilder.setVisible('group_columns_by', (chartType === 'boxplot' || chartType === 'histogram' || chartType === 'ecdf'));
    formBuilder.setVisible('color', chartType !== 'histogram');
    formBuilder.setVisible('size', chartType !== 'histogram' && chartType !== 'ecdf');
    formBuilder.setVisible('axis_label', (chartType !== 'boxplot' && chartType !== 'histogram' && chartType !== 'ecdf'));

  }

  this.tooltip = [];
  var draw = function () {
    _.debounce(_this.draw(), 100);
  };
  formBuilder.$form.on('change', 'select,input[type=range]', function (e) {
    if ($(this).attr('name') === 'tooltip') {
      var tooltipVal = _this.formBuilder.getValue('tooltip');
      _this.tooltip.length = 0; // clear array
      if (tooltipVal != null) {
        tooltipVal.forEach(function (tip) {
          _this.tooltip.push(morpheus.ChartTool.getVectorInfo(tip));
        });
      }
    } else {
      setVisibility();
      draw();
    }

  });

  formBuilder.$form.on('click', 'input[type=checkbox]', function (e) {
    draw();

  });
  formBuilder.$form.on('keypress', 'input[type=text]', function (e) {
    if (e.which === 13) {
      draw();
    }
  });

  setVisibility();

  var trackChanged = function () {
    updateOptions();
    setVisibility();
    formBuilder.setOptions('group_columns_by', options, true);
    formBuilder.setOptions('group_rows_by', options, true);
  };

  project.getColumnSelectionModel().on('selectionChanged.chart', draw);
  project.getRowSelectionModel().on('selectionChanged.chart', draw);
  project.on('trackChanged.chart', trackChanged);
  this.$chart = this.$el.find('[data-name=chartDiv]');
  var $dialog = $('<div style="background:white;" title="Chart"></div>');
  var $configPane = this.$el.find('[data-name=configPane]');
  formBuilder.$form.appendTo($configPane);
  this.$el.appendTo($dialog);
  $dialog.dialog({
    dialogClass: 'morpheus',
    close: function (event, ui) {
      project.off('trackChanged.chart', trackChanged);
      project.getRowSelectionModel().off('selectionChanged.chart', draw);
      project.getColumnSelectionModel().off('selectionChanged.chart',
        draw);
      _this.$el.empty();
    },

    resizable: true,
    height: 600,
    width: 900
  });
  this.$dialog = $dialog;
  this.draw();
};

morpheus.ChartTool.getPlotlyDefaults2 = function () {
  var plotly = morpheus.ChartTool.getPlotlyDefaults();
  plotly.layout.width = 600;
  plotly.layout.height = 600;
  plotly.layout.margin = {
    l: 40,
    r: 10,
    t: 40,
    b: 40,
    autoexpand: true
  };
  delete plotly.config.displayModeBar;
  return plotly;
};

morpheus.ChartTool.BUTTONS_TO_REMOVE_FOR_STATIC_CHART = ['select2d', 'lasso2d']; // ['zoom2d', 'pan2d', 'select2d', 'lasso2d', 'autoScale2d', 'resetScale2d'];
morpheus.ChartTool.getPlotlyDefaults = function () {
  var layout = {
    hovermode: 'closest',
    autosize: true,
    // paper_bgcolor: 'rgb(255,255,255)',
    // plot_bgcolor: 'rgb(229,229,229)',
    showlegend: false,
    margin: {
      l: 80,
      r: 10,
      t: 8, // leave space for modebar
      b: 14,
      autoexpand: true
    },
    titlefont: {
      size: 12
    },
    xaxis: {
      zeroline: false,
      titlefont: {
        size: 12
      },
      // gridcolor: 'rgb(255,255,255)',
      showgrid: true,
      //   showline: true,
      showticklabels: true,
      tickcolor: 'rgb(127,127,127)',
      ticks: 'outside'
    },
    yaxis: {
      zeroline: false,
      titlefont: {
        size: 12
      },
      // gridcolor: 'rgb(255,255,255)',
      showgrid: true,
      //   showline: true,
      showticklabels: true,
      tickcolor: 'rgb(127,127,127)',
      ticks: 'outside'
    }
  };

  // var toImage = {
  //   name: 'toImage',
  //   title: 'Download plot as a svg',
  //   icon: Icons.camera,
  //   click: function (gd) {
  //     var format = 'svg';
  //     Lib.notifier('Taking snapshot - this may take a few seconds', 'long');
  //     downloadImage(gd, {'format': format})
  //     .then(function (filename) {
  //       Lib.notifier('Snapshot succeeded - ' + filename, 'long');
  //     })
  //     .catch(function () {
  //       Lib.notifier('Sorry there was a problem downloading your snapshot!', 'long');
  //     });
  //   }
  // };
  var config = {
    modeBarButtonsToAdd: [],
    showLink: false,
    displayModeBar: true, // always show modebar
    displaylogo: false,
    staticPlot: false,
    showHints: true,
    modeBarButtonsToRemove: ['sendDataToCloud', 'zoomIn2d', 'zoomOut2d', 'hoverCompareCartesian', 'hoverClosestCartesian']
  };
  return {
    layout: layout,
    config: config
  };
};

morpheus.ChartTool.getVectorInfo = function (value) {
  var field = value.substring(0, value.length - 2);
  var isColumns = value.substring(value.length - 2) === '_c';
  return {
    field: field,
    isColumns: isColumns
  };
};
morpheus.ChartTool.prototype = {
  _addListeners: function (div) {
    var _this = this;
    div.on('plotly_beforeexport', function () {

    });

    div.on('plotly_afterexport', function () {
      var data = div.data; // convert text to string
      for (var i = 0; i < data.length; i++) {
        var text = data[i].text;
        data[i].text = data[i]._text;
      }
    });

  },
  annotate: function (options) {
    var _this = this;
    var formBuilder = new morpheus.FormBuilder();
    formBuilder.append({
      name: 'annotation_name',
      type: 'text',
      required: true
    });
    formBuilder.append({
      name: 'annotation_value',
      type: 'text',
      required: true
    });
    // formBuilder.append({
    // name : 'annotate',
    // type : 'radio',
    // required : true,
    // options : [ 'Rows', 'Columns', 'Rows And Columns' ],
    // value : 'Rows'
    // });
    morpheus.FormBuilder
      .showOkCancel({
        title: 'Annotate Selection',
        content: formBuilder.$form,
        okCallback: function () {
          var dataset = options.dataset;
          var eventData = options.eventData;
          var array = options.array;
          var value = formBuilder.getValue('annotation_value');
          var annotationName = formBuilder
            .getValue('annotation_name');
          // var annotate = formBuilder.getValue('annotate');
          var isRows = true;
          var isColumns = true;
          var existingRowVector = null;
          var rowVector = null;
          if (isRows) {
            existingRowVector = dataset.getRowMetadata()
              .getByName(annotationName);
            rowVector = dataset.getRowMetadata().add(
              annotationName);
          }
          var existingColumnVector = null;
          var columnVector = null;
          if (isColumns) {
            existingColumnVector = dataset.getColumnMetadata()
              .getByName(annotationName);
            columnVector = dataset.getColumnMetadata().add(
              annotationName);
          }

          for (var p = 0, nselected = eventData.points.length; p < nselected; p++) {
            var item = array[eventData.points[p].pointNumber];
            if (isRows) {
              if (_.isArray(item.row)) {
                item.row.forEach(function (r) {
                  rowVector.setValue(r, value);
                });

              } else {
                rowVector.setValue(item.row, value);
              }

            }
            if (isColumns) {
              columnVector.setValue(item.column, value);
            }
          }
          if (isRows) {
            morpheus.VectorUtil
              .maybeConvertStringToNumber(rowVector);
            _this.project.trigger('trackChanged', {
              vectors: [rowVector],
              render: existingRowVector != null ? []
                : [morpheus.VectorTrack.RENDER.TEXT],
              columns: false
            });
          }
          if (isColumns) {
            morpheus.VectorUtil
              .maybeConvertStringToNumber(columnVector);
            _this.project.trigger('trackChanged', {
              vectors: [columnVector],
              render: existingColumnVector != null ? []
                : [morpheus.VectorTrack.RENDER.TEXT],
              columns: true
            });
          }
        }
      });

  },
  _createScatter: function (options) {
    var dataset = options.dataset;
    var colorByVector = options.colorByVector;
    var colorModel = options.colorModel;
    var sizeByVector = options.sizeByVector;
    var sizeFunction = options.sizeFunction;
    var heatmap = this.heatmap;
    var myPlot = options.myPlot;
    var isColumnChart = options.isColumnChart;
    // scatter
    var x = [];
    var y = [];
    var text = [];
    var color = colorByVector ? [] : '#1f78b4';
    var size = sizeByVector ? [] : 6;
    for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
      y.push(dataset.getValue(options.rowIndexOne, j));
      x.push(dataset.getValue(options.rowIndexTwo, j));
      if (colorByVector) {
        var colorByValue = colorByVector.getValue(j);
        color.push(colorModel.getMappedValue(colorByVector,
          colorByValue));
      }
      if (sizeByVector) {
        var sizeByValue = sizeByVector.getValue(j);
        size.push(sizeFunction(sizeByValue));
      }
      var obj = {
        i: [options.rowIndexOne, options.rowIndexTwo],
        j: j
      };

      obj.toString = function () {
        var s = [];
        for (var tipIndex = 0; tipIndex < _this.tooltip.length; tipIndex++) {
          var tip = _this.tooltip[tipIndex];
          var metadata;
          if (tip.isColumns) {
            metadata = isColumnChart ? dataset.getRowMetadata() : dataset.getColumnMetadata();
          } else {
            metadata = isColumnChart ? dataset.getColumnMetadata() : dataset.getRowMetadata();
          }
          var indices = this.i;
          var v = metadata.getByName(tip.field);
          for (var i = 0; i < indices.length; i++) {
            var index = indices[i];
            if (index === 0 || v.getValue(index) !== v.getValue(0)) {
              morpheus.HeatMapTooltipProvider.vectorToString(v,
                index, s, '<br>');
            }
          }
        }

        return s.join('');

      };
      text.push(obj);
    }

    // TODO add R^2
    var trace = {
      x: x,
      y: y,
      _tooltip: this.tooltip,
      _dataset: dataset,
      marker: {
        color: color,
        size: size,
        symbol: 'circle-open'
      },
      text: text,
      mode: 'markers',
      type: 'scatter' // scattergl
    };
    var selection = null;
    var _this = this;
    morpheus.ChartTool.newPlot(myPlot, [trace], options.layout, options.config);
    this._addListeners(myPlot);

  },
  _createProfile: function (options) {
    var dataset = options.dataset;
    // only allow coloring by row
    var colorByVector = options.colorByVector;
    var colorModel = options.colorModel;
    var sizeByVector = options.sizeByVector;
    var sizeFunction = options.sizeFunction;
    var axisLabelVector = options.axisLabelVector;
    var isColumnChart = options.isColumnChart;
    var heatmap = this.heatmap;
    var myPlot = options.myPlot;

    var traces = [];
    var ticktext = [];
    var tickvals = [];
    for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
      ticktext.push(axisLabelVector != null ? axisLabelVector.getValue(j) : '' + j);
      tickvals.push(j);
    }
    for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
      // each row is a new trace
      var x = [];
      var y = [];
      var text = [];
      var size = sizeByVector ? [] : 6;
      var color = colorByVector ? colorModel.getMappedValue(colorByVector,
        colorByVector.getValue(i)) : undefined;

      for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
        x.push(j);
        y.push(dataset.getValue(i, j));

        if (sizeByVector) {
          var sizeByValue = sizeByVector.getValue(j);
          size.push(sizeFunction(sizeByValue));
        }
        var obj = {
          i: i,
          j: j
        };
        obj.toString = function () {
          var s = [];
          for (var tipIndex = 0; tipIndex < _this.tooltip.length; tipIndex++) {
            var tip = _this.tooltip[tipIndex];
            if (tip.isColumns) {
              morpheus.HeatMapTooltipProvider.vectorToString(dataset.getColumnMetadata().getByName(tip.field),
                this.j, s, '<br>');
            } else {
              morpheus.HeatMapTooltipProvider.vectorToString(dataset.getRowMetadata().getByName(tip.field),
                this.i, s, '<br>');
            }
          }

          return s.join('');

        };

        text.push(obj);
      }
      var trace = {
          x: x,
          y: y,
          name: colorByVector ? colorByVector.getValue(i) : '',
          tickmode: 'array',
          marker: {
            size: size,
            symbol: 'circle'
          },
          text: text,
          mode: 'lines' + (options.showPoints ? '+markers' : ''
          ),
          type: 'scatter' // scattergl
        }
        ;
      traces.push(trace);
    }

    var selection = null;
    var _this = this;
    options.layout.xaxis.tickvals = tickvals;
    options.layout.xaxis.ticktext = ticktext;
    options.layout.xaxis.tickmode = 'array';

    // var config = $
    // .extend(
    //   true,
    //   {},
    //   options.config,
    //   {
    //     modeBarButtonsToAdd: [[{
    //       name: 'annotate',
    //       title: 'Annotate Selection',
    //       attr: 'dragmode',
    //       val: 'annotate',
    //       icon: {
    //         'width': 1792,
    //         'path': 'M491 1536l91-91-235-235-91 91v107h128v128h107zm523-928q0-22-22-22-10 0-17 7l-542 542q-7 7-7 17 0 22 22 22 10 0 17-7l542-542q7-7 7-17zm-54-192l416 416-832 832h-416v-416zm683 96q0 53-37 90l-166 166-416-416 166-165q36-38 90-38 53 0 91 38l235 234q37 39 37 91z',
    //         'ascent': 1792,
    //         'descent': 0
    //       },
    //       click: function () {
    //         if (!selection) {
    //           morpheus.FormBuilder
    //           .showInModal({
    //             title: 'Annotate Selection',
    //             html: 'Please select points in the chart',
    //             close: 'Close'
    //           });
    //         } else {
    //           _this.annotate({
    //             eventData: selection,
    //             dataset: dataset
    //           });
    //         }
    //       }
    //     }]]
    //   });
    var $parent = $(myPlot).parent();
    options.layout.width = $parent.width();
    options.layout.height = this.$dialog.height() - 30;
    morpheus.ChartTool.newPlot(myPlot, traces, options.layout, options.config);
    // myPlot.on('plotly_selected', function (eventData) {
    //   selection = eventData;
    // });

    function resize() {
      var width = $parent.width();
      var height = _this.$dialog.height() - 30;
      Plotly.relayout(myPlot, {
        width: width,
        height: height
      });
    }

    this.$dialog.on('dialogresize', resize);
    $(myPlot).on('remove', function () {
      _this.$dialog.off('dialogresize');
    });

  },

  _createHistogram: function (options) {
    var array = options.array; // array of items
    var myPlot = options.myPlot;
    var dataset = options.dataset;
    var x = [];
    for (var k = 0, nitems = array.length; k < nitems; k++) {
      var item = array[k];
      x.push(dataset.getValue(item.row, item.column));
    }
    var trace = {
      name: '',
      type: 'histogram'
    };
    var traces = [trace];
    if (options.horizontal) {
      trace.x = x;
    } else {
      trace.y = x;
    }

    var selection = null;
    var _this = this;

    morpheus.ChartTool.newPlot(myPlot, traces, options.layout, options.config);
    // myPlot.on('plotly_selected', function (eventData) {
    // 	selection = eventData;
    // });
  },
  _createEcdf: function (options) {
    var array = options.array; // array of items
    var myPlot = options.myPlot;
    var dataset = options.dataset;
    var colorByVector = options.colorByVector;
    var colorByGetter = options.colorByGetter;
    var colorModel = options.colorModel;
    var traces = [];
    // split by color by value

    var colorByValueToArray = new morpheus.Map();
    for (var k = 0, nitems = array.length; k < nitems; k++) {
      var item = array[k];
      var val = dataset.getValue(item.row, item.column);
      if (!isNaN(val)) {
        var colorByValue = colorByVector !== null ? colorByGetter(item) : '';
        var traceArray = colorByValueToArray.get(colorByValue);
        if (traceArray === undefined) {
          traceArray = [];
          colorByValueToArray.set(colorByValue, traceArray);
        }
        traceArray.push(val);
      }
    }
    var traces = [];
    colorByValueToArray.forEach(function (traceArray, colorByValue) {
      var y = [];
      var x = [];
      // FIXME
      traces.push({
        name: colorByValue,
        x: x,
        y: y,
        type: 'line'
      });
    });
    var selection = null;
    var _this = this;

    morpheus.ChartTool.newPlot(myPlot, traces, options.layout, options.config);
    // myPlot.on('plotly_selected', function (eventData) {
    // 	selection = eventData;
    // });
  },
  _createBoxPlot: function (options) {
    var _this = this;
    var transpose = options.transpose;
    var array = options.array; // array of items
    var points = options.points;
    var isHorizontal = options.horizontal;
    var colorByVector = options.colorByVector;
    var colorByGetter = options.colorByGetter;
    var colorModel = options.colorModel;
    var myPlot = options.myPlot;
    var dataset = options.dataset;
    var y = [];
    var color = points && colorByVector ? [] : '#1f78b4';
    var text = [];
    var x = [];
    var heatmap = this.heatmap;
    var sizeFunction = options.sizeFunction;
    var sizeByGetter = options.sizeByGetter;
    var size = sizeFunction ? [] : 6;
    var scale = d3.scale.linear().domain([0, 1]).range([-0.3, -1]);
    // TODO fix jitter
    for (var k = 0, nitems = array.length; k < nitems; k++) {
      var item = array[k];
      var value = dataset.getValue(item.row, item.column);
      y.push(value);
      if (points) {
        x.push(scale(Math.random()));
        if (colorByVector) {
          var colorByValue = colorByGetter(item);
          color.push(colorModel.getMappedValue(colorByVector,
            colorByValue));
        }
        if (sizeFunction) {
          var sizeByValue = sizeByGetter(item);
          size.push(sizeFunction(sizeByValue));
        }
        var obj = {
          i: item.row,
          j: item.column
        };
        obj.toString = function () {

          var s = [];
          for (var tipIndex = 0; tipIndex < _this.tooltip.length; tipIndex++) {
            var tip = _this.tooltip[tipIndex];
            var metadata;
            var index;
            if (tip.isColumns) {
              metadata = transpose ? dataset.getRowMetadata() : dataset.getColumnMetadata();
              index = transpose ? this.i : this.j;
            } else {
              metadata = transpose ? dataset.getColumnMetadata() : dataset.getRowMetadata();
              index = transpose ? this.j : this.i;
            }

            var v = metadata.getByName(tip.field);
            morpheus.HeatMapTooltipProvider.vectorToString(v,
              index, s, '<br>');

          }
          return s.join('');
        };
        text.push(obj);
      }

    }

    var valuesField = isHorizontal ? 'x' : 'y';
    var traces = [];
    var trace = {
      name: '',
      type: 'box',
      boxpoints: false,
      hoverinfo: valuesField + '+text'
    };
    trace[valuesField] = y;
    traces.push(trace);
    if (points) {
      trace = {
        name: '',
        hoverinfo: valuesField + '+text',
        mode: 'markers',
        type: 'scatter',
        text: text,
        marker: {
          symbol: 'circle-open',
          size: size,
          color: color
        }
      };
      var xField = isHorizontal ? 'y' : 'x';
      trace[xField] = x;
      trace[valuesField] = y;
      traces.push(trace);
    }
    // var selection = null;
    // var _this = this;
    // var config = $
    // .extend(
    //   true,
    //   {},
    //   options.config,
    //   {
    //     modeBarButtonsToAdd: [[{
    //       name: 'annotate',
    //       title: 'Annotate Selection',
    //       attr: 'dragmode',
    //       val: 'annotate',
    //       icon: {
    //         'width': 1792,
    //         'path': 'M491 1536l91-91-235-235-91 91v107h128v128h107zm523-928q0-22-22-22-10 0-17 7l-542 542q-7 7-7 17 0 22 22 22 10 0 17-7l542-542q7-7 7-17zm-54-192l416 416-832 832h-416v-416zm683 96q0 53-37 90l-166 166-416-416 166-165q36-38 90-38 53 0 91 38l235 234q37 39 37 91z',
    //         'ascent': 1792,
    //         'descent': 0
    //       },
    //       click: function () {
    //         if (!selection) {
    //           morpheus.FormBuilder
    //           .showInModal({
    //             title: 'Annotate Selection',
    //             html: 'Please select points in the chart',
    //             close: 'Close'
    //           });
    //         } else {
    //           _this.annotate({
    //             array: array,
    //             eventData: selection,
    //             dataset: dataset
    //           });
    //         }
    //       }
    //     }]]
    //   });

    morpheus.ChartTool.newPlot(myPlot, traces, options.layout, options.config);
    var $span = $('<div' +
      ' style="display:none;position:absolute;font-size:10px;left:2px;top:4px;">#' +
      ' points:' + morpheus.Util.intFormat(array.length) + '</div>');

    $span.appendTo($(myPlot));
    // myPlot.on('plotly_selected', function (eventData) {
    //   selection = eventData;
    // });
    myPlot.on('plotly_hover', function (eventData) {
      if (eventData.points && eventData.points.length > 0 && eventData.points[0].curveNumber === 0) {
        $span.show();
      } else {
        $span.hide();
      }
    });
    myPlot.on('plotly_unhover', function (eventData) {
      $span.hide();
    });

  },
  draw: function () {
    var _this = this;
    this.$chart.empty();
    var plotlyDefaults = morpheus.ChartTool.getPlotlyDefaults();
    var layout = plotlyDefaults.layout;
    var config = plotlyDefaults.config;
    // 140 to 800
    var gridWidth = parseInt(this.formBuilder.getValue('chart_width'));
    var gridHeight = parseInt(this.formBuilder.getValue('chart_height'));
    var showPoints = this.formBuilder.getValue('show_points');

    var groupColumnsBy = this.formBuilder.getValue('group_columns_by');
    var axisLabel = this.formBuilder.getValue('axis_label');
    var colorBy = this.formBuilder.getValue('color');
    var sizeBy = this.formBuilder.getValue('size');
    var groupRowsBy = this.formBuilder.getValue('group_rows_by');
    var chartType = this.formBuilder.getValue('chart_type');

    var seriesName = this.formBuilder.getValue('series');
    var v1Op = this.formBuilder.getValue('lower_selector');
    var v1 = parseFloat(this.formBuilder.getValue('lower'));
    var v2Op = this.formBuilder.getValue('upper_selector');
    var v2 = parseFloat(this.formBuilder.getValue('upper'));
    var gtf = function () {
      return true;
    };
    var ltf = function () {
      return true;
    };
    if (!isNaN(v1)) {
      gtf = v1Op === 'gt' ? function (val) {
        return val > v1;
      } : function (val) {
        return val >= v1;
      };
    }

    if (!isNaN(v2)) {
      ltf = v2Op === 'lt' ? function (val) {
        return val < v2;
      } : function (val) {
        return val <= v2;
      };
    }
    var dataset = this.project.getSelectedDataset({
      emptyToAll: false
    });

    var seriesIndex = morpheus.DatasetUtil.getSeriesIndex(dataset, seriesName);
    var datasetFilter = seriesIndex === -1 ? function () {
      return true;
    } : function (ds, item) {
      var val = ds.getValue(item.row, item.column, seriesIndex);
      return gtf(val) && ltf(val);
    };

    this.dataset = dataset;
    if (dataset.getRowCount() === 0 && dataset.getColumnCount() === 0) {
      $('<h4>Please select rows and columns in the heat map.</h4>')
        .appendTo(this.$chart);
      return;
    } else if (dataset.getRowCount() === 0) {
      $('<h4>Please select rows in the heat map.</h4>')
        .appendTo(this.$chart);
      return;
    }
    if (dataset.getColumnCount() === 0) {
      $('<h4>Please select columns in the heat map.</h4>')
        .appendTo(this.$chart);
      return;
    }

    var grid = [];

    var items = [];
    var heatmap = this.heatmap;
    var colorByInfo = morpheus.ChartTool.getVectorInfo(colorBy);
    var sizeByInfo = morpheus.ChartTool.getVectorInfo(sizeBy);
    var colorModel = !colorByInfo.isColumns ? this.project.getRowColorModel()
      : this.project.getColumnColorModel();
    var axisLabelInfo = morpheus.ChartTool.getVectorInfo(axisLabel);
    var axisLabelVector = axisLabelInfo.isColumns ? dataset.getColumnMetadata().getByName(axisLabelInfo.field) : dataset.getRowMetadata().getByName(
      axisLabelInfo.field);
    var sizeByVector = sizeByInfo.isColumns ? dataset.getColumnMetadata().getByName(sizeByInfo.field) : dataset.getRowMetadata().getByName(
      sizeByInfo.field);
    var colorByVector = colorByInfo.isColumns ? dataset.getColumnMetadata().getByName(colorByInfo.field) : dataset.getRowMetadata().getByName(
      colorByInfo.field);
    var rowIds = [undefined];
    var columnIds = [undefined];
    var sizeByScale = null;
    if (sizeByVector) {
      var minMax = morpheus.VectorUtil.getMinMax(sizeByVector);
      sizeByScale = d3.scale.linear().domain(
        [minMax.min, minMax.max]).range([3, 16])
        .clamp(true);
    }

    if (chartType === 'row profile' || chartType === 'column profile') {
      showPoints = showPoints && (dataset.getRowCount() * dataset.getColumnCount()) <= 100000;
      var $chart = $('<div></div>');
      var myPlot = $chart[0];
      $chart.appendTo(this.$chart);
      if (chartType === 'column profile') {
        dataset = new morpheus.TransposedDatasetView(dataset);
      }
      this
        ._createProfile({
          showPoints: showPoints,
          isColumnChart: chartType === 'column profile',
          axisLabelVector: axisLabelVector,
          colorByVector: colorByVector,
          colorModel: colorModel,
          sizeByVector: sizeByVector,
          sizeFunction: sizeByScale,
          myPlot: myPlot,
          dataset: dataset,
          config: config,
          layout: $
            .extend(
              true,
              {},
              layout,
              {
                showlegend: true,
                width: gridWidth,
                height: gridHeight,
                margin: {
                  b: 80
                },
                yaxis: {},
                xaxis: {}
              })
        });
    } else if (chartType === 'row scatter matrix' || chartType === 'column scatter matrix') {
      var transpose = chartType === 'column scatter matrix';
      showPoints = showPoints && (dataset.getRowCount() * dataset.getColumnCount()) <= 100000;
      if (transpose) {
        dataset = new morpheus.TransposedDatasetView(dataset);
      }
      if (dataset.getRowCount() > 20) {
        $('<h4>Maximum chart size exceeded.</h4>')
          .appendTo(this.$chart);
        return;
      }

      // rowIndexOne is along rows of chart (y axis), rowIndexTwo along x
      // axis

      // draw grid
      for (var rowIndexOne = 0, nrows = dataset.getRowCount(); rowIndexOne < nrows; rowIndexOne++) {
        for (var rowIndexTwo = 0; rowIndexTwo < nrows; rowIndexTwo++) {
          if (rowIndexOne > rowIndexTwo) {
            continue;
          }
          var $chart = $('<div style="position:absolute;left:'
            + (rowIndexTwo * gridWidth) + 'px;top:'
            + (rowIndexOne * gridHeight) + 'px;"></div>');
          var myPlot = $chart[0];
          $chart.appendTo(this.$chart);

          if (rowIndexOne === rowIndexTwo) { // boxplot
            var array = [];
            for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
              array.push({
                row: rowIndexTwo,
                column: j
              });
            }
            this
              ._createBoxPlot({
                array: array,
                points: showPoints,
                colorByVector: colorByVector,
                colorModel: colorModel,
                colorByGetter: function (item) {
                  return colorByVector
                    .getValue(item.column);
                },
                sizeByGetter: function (item) {
                  return sizeByVector
                    .getValue(item.column);
                },
                sizeFunction: sizeByScale,
                myPlot: myPlot,
                dataset: dataset,
                config: config,
                transpose: transpose,
                layout: $
                  .extend(
                    true,
                    {},
                    layout,
                    {
                      width: gridWidth,
                      height: gridHeight,
                      margin: {
                        b: 80
                      },
                      xaxis: {
                        title: axisLabelVector == null ? ''
                          : axisLabelVector
                          .getValue(rowIndexTwo),
                        showticklabels: false
                      }
                    })
              });

          } else {
            this
              ._createScatter({
                isColumnChart: transpose,
                rowIndexOne: rowIndexOne,
                rowIndexTwo: rowIndexTwo,
                colorByVector: colorByVector,
                colorModel: colorModel,
                colorByGetter: function (item) {
                  return colorByVector
                    .getValue(item.column);
                },
                sizeByVector: sizeByVector,
                sizeFunction: sizeByScale,
                myPlot: myPlot,
                dataset: dataset,
                config: config,
                layout: $
                  .extend(
                    true,
                    {},
                    layout,
                    {
                      width: gridWidth,
                      height: gridHeight,
                      margin: {
                        b: 80
                      },
                      yaxis: {
                        title: axisLabelVector == null ? ''
                          : axisLabelVector
                          .getValue(rowIndexOne),
                      },
                      xaxis: {
                        title: axisLabelVector == null ? ''
                          : axisLabelVector
                          .getValue(rowIndexTwo)
                      }
                    })
              });

          }
        }
      }
    } else if (chartType === 'boxplot' || chartType === 'histogram') {
      for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
        for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
          var item = {
            row: i,
            column: j
          };
          if (datasetFilter(dataset, item)) {
            items.push(item);
          }

        }
      }
      showPoints = showPoints && items.length <= 100000;
      var colorByInfo = morpheus.ChartTool.getVectorInfo(colorBy);
      var colorByVector = colorByInfo.isColumns ? dataset.getColumnMetadata()
        .getByName(colorByInfo.field) : dataset.getRowMetadata()
        .getByName(colorByInfo.field);

      var colorModel = !colorByInfo.isColumns ? this.project
        .getRowColorModel() : this.project.getColumnColorModel();
      var colorByGetter = colorByInfo.isColumns ? function (item) {
        return colorByVector.getValue(item.column);
      } : function (item) {
        return colorByVector.getValue(item.row);
      };
      var sizeByVector = sizeByInfo.isColumns ? dataset.getColumnMetadata()
        .getByName(sizeByInfo.field) : dataset.getRowMetadata()
        .getByName(sizeByInfo.field);
      var sizeByGetter = sizeByInfo.isColumns ? function (item) {
        return sizeByVector.getValue(item.column);
      } : function (item) {
        return sizeByVector.getValue(item.row);
      };
      var sizeByScale = null;
      if (sizeByVector) {
        var minMax = morpheus.VectorUtil.getMinMax(sizeByVector);
        sizeByScale = d3.scale.linear().domain([minMax.min, minMax.max])
          .range([3, 16]).clamp(true);
      }
      if (groupColumnsBy || groupRowsBy) {
        var rowIdToArray = new morpheus.Map();
        if (groupRowsBy) {
          var groupRowsByInfo = morpheus.ChartTool
            .getVectorInfo(groupRowsBy);
          var vector = groupRowsByInfo.isColumns ? dataset
            .getColumnMetadata().getByName(groupRowsByInfo.field)
            : dataset.getRowMetadata().getByName(
            groupRowsByInfo.field);

          var getter = groupRowsByInfo.isColumns ? function (item) {
            return vector.getValue(item.column);
          } : function (item) {
            return vector.getValue(item.row);
          };

          var isArray = morpheus.VectorUtil.getDataType(vector)[0] === '[';
          for (var i = 0, nitems = items.length; i < nitems; i++) {
            var item = items[i];
            var value = getter(item);
            if (isArray && value != null) {
              value.forEach(function (val) {
                var array = rowIdToArray.get(val);
                if (array == undefined) {
                  array = [];
                  rowIdToArray.set(val, array);
                }
                array.push(item);
              });
            } else {
              var array = rowIdToArray.get(value);
              if (array == undefined) {
                array = [];
                rowIdToArray.set(value, array);
              }
              array.push(item);
            }
          }
        } else {
          rowIdToArray.set(undefined, items);
        }

        if (groupColumnsBy) {
          var name = groupColumnsBy.substring(0,
            groupColumnsBy.length - 2);
          var isColumns = groupColumnsBy
              .substring(groupColumnsBy.length - 2) === '_c';
          var vector = isColumns ? dataset.getColumnMetadata().getByName(
            name) : dataset.getRowMetadata().getByName(name);
          var getter = isColumns ? function (item) {
            return vector.getValue(item.column);
          } : function (item) {
            return vector.getValue(item.row);
          };
          var isArray = morpheus.VectorUtil.getDataType(vector)[0] === '[';
          var columnIdToIndex = new morpheus.Map();
          var rowIndex = 0;
          rowIdToArray.forEach(function (array, id) {
            grid[rowIndex] = [];
            for (var i = 0, nitems = array.length; i < nitems; i++) {
              var item = array[i];
              var value = getter(item);
              if (isArray && value != null) {

                value.forEach(function (val) {
                  var columnIndex = columnIdToIndex.get(val);
                  if (columnIndex === undefined) {
                    columnIndex = columnIdToIndex.size();
                    columnIdToIndex.set(val, columnIndex);
                  }
                  if (grid[rowIndex][columnIndex] === undefined) {
                    grid[rowIndex][columnIndex] = [];
                  }

                  grid[rowIndex][columnIndex].push(item);
                });

              } else {
                var columnIndex = columnIdToIndex.get(value);
                if (columnIndex === undefined) {
                  columnIndex = columnIdToIndex.size();
                  columnIdToIndex.set(value, columnIndex);
                }
                if (grid[rowIndex][columnIndex] === undefined) {
                  grid[rowIndex][columnIndex] = [];
                }
                grid[rowIndex][columnIndex].push(item);
              }
            }
            rowIds[rowIndex] = id;
            rowIndex++;
          });
          columnIdToIndex.forEach(function (index, id) {
            columnIds[index] = id;
          });
        } else {
          var rowIndex = 0;
          rowIdToArray.forEach(function (array, id) {
            grid[rowIndex] = [array];
            rowIds[rowIndex] = id;
            rowIndex++;
          });
        }

      } else {
        grid = [[items]];
      }
      var gridRowCount = rowIds.length;
      var gridColumnCount = columnIds.length;
      // sort rows and columns by median
      if (gridRowCount > 1) {
        var summary = [];
        for (var i = 0; i < gridRowCount; i++) {
          summary[i] = [];
          var gridRow = grid[i];
          for (var j = 0; j < gridColumnCount; j++) {
            var array = gridRow[j];
            var values = [];
            if (array) {
              for (var k = 0, nitems = array.length; k < nitems; k++) {
                var item = array[k];
                var value = dataset.getValue(item.row, item.column);
                if (!isNaN(value)) {
                  values.push(value);
                }

              }
            }
            summary[i][j] = morpheus.Median(morpheus.VectorUtil.arrayAsVector(values));
          }
        }
        // sort rows
        var rowMedians = [];
        for (var i = 0; i < gridRowCount; i++) {
          var values = [];
          for (var j = 0; j < gridColumnCount; j++) {
            values.push(summary[i][j]);
          }
          rowMedians.push(morpheus.Median(morpheus.VectorUtil.arrayAsVector(values)));
        }

        var newRowOrder = morpheus.Util.indexSort(rowMedians, false);
        var newRowIds = [];
        var newGrid = [];
        for (var i = 0; i < gridRowCount; i++) {
          newGrid.push(grid[newRowOrder[i]]);
          newRowIds.push(rowIds[newRowOrder[i]]);
        }
        grid = newGrid;
        rowIds = newRowIds;
      }

      if (grid.length === 0) {
        return;
      }
      // compute max text width
      var container = d3.select('body').append('svg');

      var t = container.append('text');
      t.attr({
        x: -1000,
        y: -1000
      }).style('font-family', '"Open Sans", verdana, arial, sans-serif').style('font-size', '9px');
      var node = container.node();
      var maxYAxisWidth = 0;
      for (var i = 0; i < gridRowCount; i++) {
        var rowId = rowIds[i];
        if (rowId != null) {
          t.text(rowId);
          var bbox = node.getBBox();
          maxYAxisWidth = Math.max(maxYAxisWidth, bbox.width + 2);
        }
      }
      maxYAxisWidth = Math.min(maxYAxisWidth, 200);
      container.remove();
      var horizontal = gridColumnCount === 1;
      var dataRanges = []; //
      var _gridWidth = gridWidth;
      var _gridHeight = gridHeight;
      if (horizontal) { // each xaxis in a column has the same scale
        for (var j = 0; j < gridColumnCount; j++) {
          var yrange = [Number.MAX_VALUE, -Number.MAX_VALUE];
          for (var i = 0; i < gridRowCount; i++) {
            var array = grid[i][j];
            if (array) {
              for (var k = 0, nitems = array.length; k < nitems; k++) {
                var item = array[k];
                var value = dataset.getValue(item.row, item.column);
                if (!isNaN(value)) {
                  yrange[0] = Math.min(yrange[0], value);
                  yrange[1] = Math.max(yrange[1], value);
                }

              }
            }
          }
          // increase range by 1%
          var span = yrange[1] - yrange[0];
          var delta = (span * 0.01);
          yrange[1] += delta;
          yrange[0] -= delta;
          dataRanges.push(yrange);
        }

      } else { // each yaxis in a row has the same scale
        for (var i = 0; i < gridRowCount; i++) {
          var yrange = [Number.MAX_VALUE, -Number.MAX_VALUE];

          for (var j = 0; j < gridColumnCount; j++) {
            var array = grid[i][j];
            if (array) {
              for (var k = 0, nitems = array.length; k < nitems; k++) {
                var item = array[k];

                var value = dataset.getValue(item.row, item.column);
                if (!isNaN(value)) {
                  yrange[0] = Math.min(yrange[0], value);
                  yrange[1] = Math.max(yrange[1], value);
                }

              }
            }
          }
          // increase range by 1%
          var span = yrange[1] - yrange[0];
          var delta = (span * 0.01);
          yrange[1] += delta;
          yrange[0] -= delta;
          dataRanges.push(yrange);
        }
      }
      var toppx = 0;
      for (var i = 0; i < gridRowCount; i++) {
        var rowId = rowIds[i];
        var leftpx = 0;
        var maxChartHeight = 0;
        for (var j = 0; j < gridColumnCount; j++) {
          var array = grid[i][j];
          var columnId = columnIds[j];
          if (array) {
            var xaxis = {};
            var marginLeft;
            var marginBottom;

            if (i === gridRowCount - 1) {
              xaxis.title = columnId;
              marginBottom = 30;

            } else {
              xaxis.ticks = '';
              xaxis.showticklabels = false;
              marginBottom = 0;
            }
            // only show xaxis if on bottom of grid

            var yaxis = {};
            var annotations = undefined;
            if (j === 0 && rowId != null) {
              annotations = [{
                xref: 'paper',
                yref: 'paper',
                x: 0,
                xanchor: 'right',
                y: 0.5,
                yanchor: 'middle',
                text: rowId,
                showarrow: false,
                font: {
                  size: 9
                }
              }]; // rotate axis label
              //yaxis.title = ;
              marginLeft = maxYAxisWidth;
            } else {
              yaxis.ticks = '';
              yaxis.showticklabels = false;
              marginLeft = 6;
            }

            var $chart = $('<div style="position:absolute;left:' + leftpx
              + 'px;top:' + toppx + 'px;"></div>');
            $chart.appendTo(this.$chart);
            var myPlot = $chart[0];
            yaxis.showgrid = (gridHeight - marginBottom) > 150;
            xaxis.showgrid = (gridWidth - marginLeft) > 150;
            if (chartType === 'boxplot') {
              if (horizontal) {
                yaxis.showticklabels = false;
                yaxis.ticks = '';
                xaxis.range = dataRanges[j];
              } else {
                xaxis.ticks = '';
                xaxis.showticklabels = false;
                yaxis.range = dataRanges[i];
              }
              var margin = {
                b: marginBottom,
                l: marginLeft,
                autoexpand: false
              };
              leftpx += gridWidth + margin.l;
              maxChartHeight = Math.max(maxChartHeight, gridHeight + margin.b);
              this._createBoxPlot({
                layout: $.extend(true, {}, layout, {
                  width: gridWidth + margin.l,
                  autosize: false,
                  height: gridHeight + margin.b,
                  margin: margin,
                  xaxis: xaxis,
                  yaxis: yaxis,
                  annotations: annotations
                }),
                horizontal: horizontal,
                array: array,
                points: showPoints,
                sizeByGetter: sizeByGetter,
                sizeFunction: sizeByScale,
                colorModel: colorModel,
                colorByVector: colorByVector,
                colorByGetter: colorByGetter,
                myPlot: myPlot,
                dataset: dataset,
                config: config
              });
            } else if (chartType == 'histogram') {
              this._createHistogram({
                layout: $.extend(true, {}, layout, {
                  width: gridWidth,
                  height: gridHeight,
                  horizontal: horizontal,
                  xaxis: xaxis,
                  yaxis: yaxis,
                  margin: {
                    b: 80,
                    l: 80
                  }
                }),

                array: array,
                myPlot: myPlot,
                dataset: dataset,
                config: config
              });
            }

          }
        }
        toppx += maxChartHeight;

      }
    }

  }
};

morpheus.ChartTool.newPlot = function (myPlot, traces, layout, config) {
  Plotly.newPlot(myPlot, traces, layout, config);
  var $a = $('<a data-toggle="tooltip" title="Toggle mode bar" href="#" style="fill: rgb(68,' +
    ' 122,' +
    ' 219);position:' +
    ' absolute;top:' +
    ' -2px;right:-6px;z-index:' +
    ' 1002;"><svg height="1em" width="1em" viewBox="0 0 1542 1000"><path d="m0-10h182v-140h-182v140z m228 146h183v-286h-183v286z m225 714h182v-1000h-182v1000z m225-285h182v-715h-182v715z m225 142h183v-857h-183v857z m231-428h182v-429h-182v429z m225-291h183v-138h-183v138z" transform="matrix(1 0 0 -1 0 850)"></path></svg></a>');
  var $myPlot = $(myPlot);
  $a.appendTo($myPlot);
  var $modeBar = $(myPlot).find('.modebar');
  $modeBar.css('display', 'none');
  $a.on('click', function (e) {
    e.preventDefault();
    $modeBar.toggle();
  });
};

morpheus.CollapseDatasetTool = function () {
};
morpheus.CollapseDatasetTool.Functions = [morpheus.Mean, morpheus.Median,
  new morpheus.MaxPercentiles([25, 75]), morpheus.Min, morpheus.Max, morpheus.Sum];
morpheus.CollapseDatasetTool.Functions.fromString = function (s) {
  for (var i = 0; i < morpheus.CollapseDatasetTool.Functions.length; i++) {
    if (morpheus.CollapseDatasetTool.Functions[i].toString() === s) {
      return morpheus.CollapseDatasetTool.Functions[i];
    }
  }
  throw new Error(s + ' not found');
};
morpheus.CollapseDatasetTool.prototype = {
  toString: function () {
    return 'Collapse';
  },
  init: function (project, form) {
    var setValue = function (val) {
      var isRows = val === 'Rows';
      var names = morpheus.MetadataUtil.getMetadataNames(isRows ? project
        .getFullDataset().getRowMetadata() : project
        .getFullDataset().getColumnMetadata());
      form.setOptions('collapse_to_fields', names);
    };
    form.$form.find('[name=collapse]').on('change', function (e) {
      setValue($(this).val());
    });
    setValue('Rows');
  },
  gui: function () {
    return [{
      name: 'collapse_method',
      options: morpheus.CollapseDatasetTool.Functions,
      value: morpheus.CollapseDatasetTool.Functions[1].toString(),
      type: 'select'
    }, {
      name: 'collapse',
      options: ['Columns', 'Rows'],
      value: 'Rows',
      type: 'radio'
    }, {
      name: 'collapse_to_fields',
      options: [],
      type: 'select',
      multiple: true
    }];
  },
  execute: function (options) {
    var project = options.project;
    var heatMap = options.heatMap;
    var f = morpheus.CollapseDatasetTool.Functions
      .fromString(options.input.collapse_method);
    var collapseToFields = options.input.collapse_to_fields;
    if (collapseToFields.length === 0) {
      throw new Error('Please select one or more fields to collapse to');
    }
    var dataset = project.getFullDataset();
    var rows = options.input.collapse == 'Rows';
    if (!rows) {
      dataset = new morpheus.TransposedDatasetView(dataset);
    }
    var allFields = morpheus.MetadataUtil.getMetadataNames(dataset
      .getRowMetadata());
    dataset = morpheus.CollapseDataset(dataset, collapseToFields, f, true);
    if (!rows) {
      dataset = new morpheus.TransposedDatasetView(dataset);
    }
    var set = new morpheus.Map();
    _.each(allFields, function (field) {
      set.set(field, true);
    });
    _.each(collapseToFields, function (field) {
      set.remove(field);
    });
    // hide fields that were not part of collapse to
    console.log("Collapse ", set);
    set.forEach(function (val, name) {
      heatMap.setTrackVisible(name, false, !rows);
    });
    project.setFullDataset(dataset, true);
    morpheus.DatasetUtil.toESSessionPromise(dataset);
  }
};

morpheus.CreateAnnotation = function () {
};
morpheus.CreateAnnotation.prototype = {
  toString: function () {
    return 'Create Calculated Annotation';
  },
  gui: function () {
    return [
      {
        name: 'annotate',
        options: ['Columns', 'Rows'],
        value: 'Rows',
        type: 'radio'
      },
      {
        name: 'annotation_name',
        value: '',
        type: 'text',
        required: true
      },
      {
        name: 'formula',
        value: '',
        type: 'textarea',
        placeholder: 'e.g MAD()',
        required: true,
        help: 'JavaScript formula. Built-in functions (case-sensitive): COUNT(), MAD(), MAX(), MEAN(), MEDIAN(), MIN(), PERCENTILE(p), SUM(), VARIANCE(). Refer to a field using FIELD(name)'
      }, {
        name: 'use_selected_rows_and_columns_only',
        type: 'checkbox'
      }];
  },
  execute: function (options) {
    var __project = options.project;
    var isColumns = options.input.annotate == 'Columns';
    var __formula = options.input.formula;
    var __dataset = options.input.use_selected_rows_and_columns_only ? __project
      .getSelectedDataset()
      : __project.getSortedFilteredDataset();
    if (isColumns) {
      __dataset = morpheus.DatasetUtil.transposedView(__dataset);
    }
    var __rowView = new morpheus.DatasetRowView(__dataset);
    var __vector = __dataset.getRowMetadata().add(
      options.input.annotation_name);
    var COUNT = function () {
      return morpheus.CountNonNaN(__rowView);
    };
    var MAD = function () {
      return morpheus.MAD(__rowView);
    };
    var MAX = function () {
      return morpheus.Max(__rowView);
    };
    var MEAN = function () {
      return morpheus.Mean(__rowView);
    };
    var MEDIAN = function (p) {
      return morpheus.Percentile(__rowView, 50);
    };
    var MIN = function () {
      return morpheus.Min(__rowView);
    };
    var PERCENTILE = function (p) {
      return morpheus.Percentile(__rowView, p);
    };
    var SUM = function () {
      return morpheus.Sum(__rowView);
    };
    var VARIANCE = function () {
      return morpheus.Variance(__rowView);
    };
    var __index = 0;
    var FIELD = function (field) {
      var vector = __dataset.getRowMetadata().getByName(field);
      return vector ? vector.getValue(__index) : undefined;
    };

    for (var size = __dataset.getRowCount(); __index < size; __index++) {
      __rowView.setIndex(__index);
      var __val = eval(__formula);
      if (typeof __val === 'function') {
        __val = '';
      }
      __vector.setValue(__index, __val);
    }
    __project.trigger('trackChanged', {
      vectors: [__vector],
      render: ['text'],
      columns: isColumns
    });
  }
};

morpheus.DendrogramEnrichmentTool = function (isColumns) {
  this.isColumns = isColumns;
};

morpheus.DendrogramEnrichmentTool.prototype = {
  toString: function () {
    return 'Dendrogram Enrichment';
  },
  gui: function (project) {
    var dataset = project.getSortedFilteredDataset();
    var fields = morpheus.MetadataUtil
      .getMetadataNames(this.isColumns ? dataset.getColumnMetadata()
        : dataset.getRowMetadata());
    return [{
      name: 'field',
      options: fields,
      type: 'bootstrap-select',
      multiple: false
    }, {
      name: 'min_p-value_for_enrichment',
      type: 'text',
      value: '0.05'
    }, {
      name: 'minimum_number_of_total_members_in_group',
      type: 'text',
      value: '5'
    }, {
      name: 'minimum_number_of_members_in_group',
      type: 'text',
      value: '3'
    }];
  },
  execute: function (options) {
    var project = options.project;
    var heatMap = options.heatMap;
    var pValue = options.input['min_p-value_for_enrichment'];
    var minTotalGroupSize = options.input.minimum_number_of_total_members_in_group;
    var minGroupSize = options.input.minimum_number_of_members_in_group;
    var dataset = project.getSortedFilteredDataset();
    var dendrogram = this.isColumns ? heatMap.columnDendrogram
      : heatMap.rowDendrogram;
    var vector = this.isColumns ? dataset.getColumnMetadata().getByName(
      options.input.field) : dataset.getRowMetadata().getByName(
      options.input.field);

    var valueToIndices = morpheus.VectorUtil
      .createValueToIndicesMap(vector);
    var valueToGlobalCount = new morpheus.Map();
    var values = [];
    valueToIndices.forEach(function (indices, value) {
      valueToGlobalCount.set(value, indices.length);
      values.push(value);
    });
    var nvalues = values.length;
    var N = vector.size();

    morpheus.DendrogramUtil.dfs(dendrogram.tree.rootNode,
      function (node) {
        delete node.info;
        var valueToCount = new morpheus.Map();
        for (var i = 0; i < nvalues; i++) {
          valueToCount.set(values[i], 0);
        }
        var min = node.minIndex;
        var max = node.maxIndex;
        var n = max - min + 1;
        if (n > 1 && n >= minTotalGroupSize) {
          for (var i = min; i <= max; i++) {
            var value = vector.getValue(i);
            valueToCount
              .set(value, valueToCount.get(value) + 1);
          }
          for (var i = 0; i < nvalues; i++) {
            var K = valueToGlobalCount.get(values[i]);
            var k = valueToCount.get(values[i]);
            if (k >= minGroupSize) {
              var a = k;
              var b = K - k;
              var c = n - k;
              var d = N + k - n - K;
              var p = morpheus.FisherExact.fisherTest(a, b,
                c, d);
              if (p <= pValue) {
                if (!node.info) {
                  node.info = {};
                }
                node.info[values[i]] = p;

              }
            }
          }
        }
        return true;
      });
    dendrogram.setInvalid(true);
    dendrogram.repaint();
  }
};

morpheus.DevAPI = function () {
};
morpheus.DevAPI.prototype = {
  toString: function () {
    return 'API';
  },
  gui: function () {
    return [{
      name: 'code',
      value: '',
      type: 'textarea',
      required: true,
      help: 'Enter your code'
    }];
  },
  execute: function (options) {
    var heatMap = options.heatMap;
    var code = options.input.code;
    eval(code);
    // force a repaint of everything
    heatMap.getProject().setFullDataset(heatMap.getProject().getFullDataset(), true);
  }
};

morpheus.HClusterTool = function () {
};
morpheus.HClusterTool.PRECOMPUTED_DIST = 'Matrix values (for a precomputed distance matrix)';
morpheus.HClusterTool.PRECOMPUTED_SIM = 'Matrix values (for a precomputed similarity matrix)';
morpheus.HClusterTool.Functions = [morpheus.Euclidean, morpheus.Jaccard,
  new morpheus.OneMinusFunction(morpheus.Cosine),
  new morpheus.OneMinusFunction(morpheus.KendallsCorrelation),
  new morpheus.OneMinusFunction(morpheus.Pearson),
  new morpheus.OneMinusFunction(morpheus.Spearman),
  morpheus.HClusterTool.PRECOMPUTED_DIST,
  morpheus.HClusterTool.PRECOMPUTED_SIM];
morpheus.HClusterTool.Functions.fromString = function (s) {
  for (var i = 0; i < morpheus.HClusterTool.Functions.length; i++) {
    if (morpheus.HClusterTool.Functions[i].toString() === s) {
      return morpheus.HClusterTool.Functions[i];
    }
  }
  throw new Error(s + ' not found');
};

morpheus.HClusterTool.createLinkageMethod = function (linkageString) {
  var linkageMethod;
  if (linkageString === 'Average') {
    linkageMethod = morpheus.AverageLinkage;
  } else if (linkageString === 'Complete') {
    linkageMethod = morpheus.CompleteLinkage;
  } else if (linkageString === 'Single') {
    linkageMethod = morpheus.SingleLinkage;
  } else {
    throw new Error('Unknown linkage method ' + linkageString);
  }
  return linkageMethod;
};

morpheus.HClusterTool.execute = function (dataset, input) {
  // note: in worker here
  var linkageMethod = morpheus.HClusterTool
    .createLinkageMethod(input.linkage_method);
  var f = morpheus.HClusterTool.Functions.fromString(input.metric);
  if (f === morpheus.HClusterTool.PRECOMPUTED_DIST) {
    f = 0;
  } else if (f === morpheus.HClusterTool.PRECOMPUTED_SIM) {
    f = 1;
  }
  var rows = input.cluster == 'Rows' || input.cluster == 'Rows and columns';
  var columns = input.cluster == 'Columns'
    || input.cluster == 'Rows and columns';
  var doCluster = function (d, groupByFields) {
    return (groupByFields && groupByFields.length > 0) ? new morpheus.HClusterGroupBy(
      d, groupByFields, f, linkageMethod)
      : new morpheus.HCluster(morpheus.HCluster
      .computeDistanceMatrix(d, f), linkageMethod);
  };

  var rowsHcl;
  var columnsHcl;

  if (rows) {
    rowsHcl = doCluster(
      input.selectedColumnsToUseForClusteringRows ? new morpheus.SlicedDatasetView(dataset,
        null, input.selectedColumnsToUseForClusteringRows) : dataset,
      input.group_rows_by);
  }
  if (columns) {
    columnsHcl = doCluster(
      morpheus.DatasetUtil
        .transposedView(input.selectedRowsToUseForClusteringColumns ? new morpheus.SlicedDatasetView(
          dataset, input.selectedRowsToUseForClusteringColumns, null)
          : dataset), input.group_columns_by);

  }
  return {
    rowsHcl: rowsHcl,
    columnsHcl: columnsHcl
  };
};
morpheus.HClusterTool.prototype = {
  toString: function () {
    return 'Hierarchical Clustering';
  },
  init: function (project, form) {
    form.setOptions('group_rows_by', morpheus.MetadataUtil
      .getMetadataNames(project.getFullDataset().getRowMetadata()));
    form
      .setOptions('group_columns_by', morpheus.MetadataUtil
        .getMetadataNames(project.getFullDataset()
          .getColumnMetadata()));
    form.setVisible('group_rows_by', false);
    form
      .setVisible('cluster_rows_in_space_of_selected_columns_only',
        false);
    form.$form.find('[name=cluster]').on(
      'change',
      function (e) {
        var val = $(this).val();
        var showGroupColumns = false;
        var showGroupRows = false;
        if (val === 'Columns') {
          showGroupColumns = true;
        } else if (val === 'Rows') {
          showGroupRows = true;
        } else {
          showGroupColumns = true;
          showGroupRows = true;
        }
        form.setVisible('group_columns_by', showGroupColumns);
        form.setVisible('group_rows_by', showGroupRows);
        form.setVisible(
          'cluster_columns_in_space_of_selected_rows_only',
          showGroupColumns);
        form.setVisible(
          'cluster_rows_in_space_of_selected_columns_only',
          showGroupRows);
      });
  },
  gui: function () {
    return [{
      name: 'metric',
      options: morpheus.HClusterTool.Functions,
      value: morpheus.HClusterTool.Functions[4].toString(),
      type: 'select'
    }, {
      name: 'linkage_method',
      options: ['Average', 'Complete', 'Single'],
      value: 'Average',
      type: 'select'
    }, {
      name: 'cluster',
      options: ['Columns', 'Rows', 'Rows and columns'],
      value: 'Columns',
      type: 'select'
    }, {
      name: 'group_columns_by',
      options: [],
      type: 'bootstrap-select',
      multiple: true
    }, {
      name: 'group_rows_by',
      options: [],
      type: 'bootstrap-select',
      multiple: true
    }, {
      name: 'cluster_columns_in_space_of_selected_rows_only',
      type: 'checkbox'
    }, {
      name: 'cluster_rows_in_space_of_selected_columns_only',
      type: 'checkbox'
    }];
  },
  execute: function (options) {
    var project = options.project;
    var heatmap = options.heatMap;
    var selectedRowsToUseForClusteringColumns = options.input.cluster_columns_in_space_of_selected_rows_only ? project
      .getRowSelectionModel().getViewIndices().values()
      : null;
    if (selectedRowsToUseForClusteringColumns != null && selectedRowsToUseForClusteringColumns.length === 0) {
      selectedRowsToUseForClusteringColumns = null;
    }
    var selectedColumnsToUseForClusteringRows = options.input.cluster_rows_in_space_of_selected_columns_only ? project
      .getColumnSelectionModel().getViewIndices().values()
      : null;
    if (selectedColumnsToUseForClusteringRows != null && selectedColumnsToUseForClusteringRows.length === 0) {
      selectedColumnsToUseForClusteringRows = null;
    }
    var rows = options.input.cluster == 'Rows'
      || options.input.cluster == 'Rows and columns';
    var columns = options.input.cluster == 'Columns'
      || options.input.cluster == 'Rows and columns';
    options.input.selectedRowsToUseForClusteringColumns = selectedRowsToUseForClusteringColumns;
    options.input.selectedColumnsToUseForClusteringRows = selectedColumnsToUseForClusteringRows;
    var dataset = project.getSortedFilteredDataset();
    if (options.input.background === undefined) {
      options.input.background = true;
    }
    options.input.background = options.input.background && typeof Worker !== 'undefined';
    var rowModelOrder;
    var columnModelOrder;
    if (rows) {
      rowModelOrder = [];
      for (var i = 0; i < dataset.getRowCount(); i++) {
        rowModelOrder[i] = project.convertViewRowIndexToModel(i);
      }
    }
    if (columns) {
      columnModelOrder = [];
      for (var i = 0; i < dataset.getColumnCount(); i++) {
        columnModelOrder[i] = project.convertViewColumnIndexToModel(i);
      }
    }
    if (options.input.background === false) {
      var result = morpheus.HClusterTool.execute(dataset, options.input);
      if (result.rowsHcl) {
        var modelOrder = [];
        for (var i = 0; i < result.rowsHcl.reorderedIndices.length; i++) {
          modelOrder[i] = rowModelOrder[result.rowsHcl.reorderedIndices[i]];
        }
        heatmap.setDendrogram(result.rowsHcl.tree, false,
          modelOrder);
      }
      if (result.columnsHcl) {
        var modelOrder = [];
        for (var i = 0; i < result.columnsHcl.reorderedIndices.length; i++) {
          modelOrder[i] = columnModelOrder[result.columnsHcl.reorderedIndices[i]];
        }
        heatmap.setDendrogram(result.columnsHcl.tree, true, modelOrder);
      }
    } else {
      var subtitle = ['clustering '];
      if (rows) {
        subtitle.push(dataset.getRowCount() + ' row'
          + morpheus.Util.s(dataset.getRowCount()));
      }
      if (columns) {
        subtitle.push(rows ? ', ' : '');
        subtitle.push(dataset.getColumnCount() + ' column'
          + morpheus.Util.s(dataset.getColumnCount()));
      }

      var blob = new Blob(
        ['self.onmessage = function(e) {'
        + 'importScripts(e.data.scripts);'
        + 'self.postMessage(morpheus.HClusterTool.execute(morpheus.Dataset.fromJSON(e.data.dataset), e.data.input));'
        + '}']);

      var url = window.URL.createObjectURL(blob);
      var worker = new Worker(url);

      worker.postMessage({
        scripts: morpheus.Util.getScriptPath(),
        dataset: morpheus.Dataset.toJSON(dataset, {
          columnFields: options.input.group_columns_by || [],
          rowFields: options.input.group_rows_by || [],
          seriesIndices: [0]
        }),
        input: options.input
      });

      worker.onmessage = function (e) {
        var result = e.data;
        if (result.rowsHcl) {
          var modelOrder = [];
          for (var i = 0; i < result.rowsHcl.reorderedIndices.length; i++) {
            modelOrder[i] = rowModelOrder[result.rowsHcl.reorderedIndices[i]];
          }
          heatmap.setDendrogram(result.rowsHcl.tree, false,
            modelOrder);
        }
        if (result.columnsHcl) {
          var modelOrder = [];
          for (var i = 0; i < result.columnsHcl.reorderedIndices.length; i++) {
            modelOrder[i] = columnModelOrder[result.columnsHcl.reorderedIndices[i]];
          }
          heatmap.setDendrogram(result.columnsHcl.tree, true,
            modelOrder);
        }
        worker.terminate();
        window.URL.revokeObjectURL(url);
      };
      return worker;
    }

  }
};

/**
 * Created by dzenkova on 11/18/16.
 */
morpheus.KmeansTool = function () {
};
morpheus.KmeansTool.prototype = {
  toString: function () {
    return 'k-means';
  },
  gui: function () {
    // z-score, robust z-score, log2, inverse log2
    return [{
      name: 'number_of_clusters',
      type: 'text'
    }, {
      name: 'replace_NA_with',
      type: 'bootstrap-select',
      options: [{
        name: 'mean',
        value: 'mean'
      }, {
        name: 'median',
        value: 'median'
      }]
    }];
  },
  execute: function (options) {
    var project = options.project;
    //console.log("morpheus.KmeansTool.prototype.execute ::", "full dataset", fullDataset);
    var dataset = project.getSortedFilteredDataset();
    var trueIndices = morpheus.Util.getTrueIndices(dataset);

    var columnIndices = [];
    var rowIndices = [];
    if (options.input.use_selected_only) {
      var selectedDataset = project.getSelectedDataset();
      var selectedIndices = morpheus.Util.getTrueIndices(selectedDataset);
      columnIndices = selectedIndices.columns.length > 0 ? selectedIndices.columns : trueIndices.columns;
      rowIndices = selectedIndices.rows.length > 0 ? selectedIndices.rows : trueIndices.rows;
    }
    else {
      columnIndices = trueIndices.columns;
      rowIndices = trueIndices.rows;
    }

    var number = parseInt(options.input.number_of_clusters);
    if (isNaN(number)) {
      throw new Error("Enter the expected number of clusters");
    }
    var replacena = options.input.replace_NA_with;
    var esPromise = dataset.getESSession();
    esPromise.then(function (essession) {
      var args = {
        es: essession,
        k: number,
        replacena: replacena
      };
      if (columnIndices.length > 0) {
        args.columns = columnIndices;
      }
      if (rowIndices.length > 0) {
        args.rows = rowIndices;
      }
      var req = ocpu.call("kmeans", args, function (session) {
        session.getObject(function (success) {
          var clusters = JSON.parse(success);

          console.log(clusters);
          var v = dataset.getRowMetadata().getByName("clusters");
          if (v == null) {
            v = dataset.getRowMetadata().add("clusters");
          }
          //console.log(sortedDataset, sortedDataset.getRowCount(), v, sortedDataset);
          for (var i = 0; i < dataset.getRowCount(); i++) {
            v.setValue(i, clusters[i]);
          }
          //console.log(dataset.getRowMetadata().getByName("clusters"));
          /*while (v instanceof morpheus.VectorAdapter || v instanceof morpheus.SlicedVector) {
           v = v.v
           }*/
          //console.log(v);
          //v.setArray(clusters);
          v.getProperties().set("morpheus.dataType", "string");
          //console.log("morpheus.KmeansTool.prototype.execute ::", "updated dataset?", dataset);
          //console.log("morpheus.KmeansTool.prototype.execute ::", "clusters?", dataset.getRowMetadata().get(morpheus.MetadataUtil.indexOf(dataset.getRowMetadata(), "clusters")));
          project.trigger('trackChanged', {
            vectors: [v],
            render: ['color']
          });
        })
      }, false, "::es");

    });
  }
};
morpheus.LimmaTool = function () {
};
morpheus.LimmaTool.prototype = {
  toString: function () {
    return 'limma';
  },
  init: function (project, form) {
    var _this = this;
    var updateAB = function (fieldNames) {
      var ids = [];
      if (fieldNames != null) {
        var vectors = morpheus.MetadataUtil.getVectors(project
          .getFullDataset().getColumnMetadata(), fieldNames);
        var idToIndices = morpheus.VectorUtil
          .createValuesToIndicesMap(vectors);
        idToIndices.forEach(function (indices, id) {
          ids.push(id);
        });
      }
      ids.sort();
      form.setOptions('class_a', ids);
      //form.setValue('class_a', ids[0].array[0]);
      form.setOptions('class_b', ids);
      // form.setValue('class_b', ids[0].array[0]);
    };
    var $field = form.$form.find('[name=field]');
    $field.on('change', function (e) {
      updateAB($(this).val());
    });
    if ($field[0].options.length > 0) {
      $field.val($field[0].options[0].value);
    }
    updateAB($field.val());
  },
  gui: function (project) {
    var dataset = project.getSortedFilteredDataset();
    var fields = morpheus.MetadataUtil.getMetadataNames(dataset
      .getColumnMetadata());
    return [{
      name: 'field',
      options: fields,
      type: 'select',
      multiple: true
    }, {
      name: 'class_a',
      title: 'Class A',
      options: [],
      value: '',
      type: 'checkbox-list',
      multiple: true
    }, {
      name: 'class_b',
      title: 'Class B',
      options: [],
      value: '',
      type: 'checkbox-list',
      multiple: true
    }];
  },
  execute: function (options) {
    var project = options.project;
    var field = options.input.field;
    var classA = options.input.class_a;
    var classB = options.input.class_b;

    if (classA.length == 0 || classB.length == 0) {
      throw new Error("You must choose at least one option in each class");
    }

    console.log("field", field);
    console.log("classA", classA);
    console.log("classB", classB);

    var dataset = project.getSortedFilteredDataset();
    console.log(dataset);
    var es = dataset.getESSession();

    var v = dataset.getColumnMetadata().getByName("Comparison");
    if (v == null) {
      v = dataset.getColumnMetadata().add("Comparison");
    }
    var vs = [];
    field.forEach(function (name) {
      vs.push(dataset.getColumnMetadata().getByName(name));
    });

    var checkCortege = function (vectors, curClass, curColumn) {
      var columnInClass = false;
      for (var j = 0; j < curClass.length; j++) {
        var isEqual = true;
        for (var k = 0; k < vectors.length; k++) {
          isEqual &= vectors[k].getValue(curColumn) == curClass[j].array[k];
        }
        columnInClass |= isEqual;
      }
      return columnInClass;
    };
    for (var i = 0; i < dataset.getColumnCount(); i++) {
      var columnInA = checkCortege(vs, classA, i);
      var columnInB = checkCortege(vs, classB, i);
      if (columnInA && columnInB) {
        var warning = "Chosen classes have intersection in column " + i;
        throw new Error(warning);
      }
      v.setValue(i, columnInA ? "A" : (columnInB ? "B" : ""));
    }

    /*for (var i = 0; i < dataset.getColumnCount(); i++) {
     var a = true;
     for (var j = 0; j < vs.length; j++) {
     var oneof = false;
     for (var k = 0; k < classA.length; k++) {
     oneof |= vs[j].getValue(i) == classA[k][j];
     }
     }
     v.setValue(i, v1.getValue(i) == classA ? "A" : (v1.getValue(i) == classB ? "B" : ""));
     }*/
    project.trigger('trackChanged', {
      vectors: [v],
      render: ['color'],
      columns: true
    });

    var values = Array.apply(null, Array(project.getFullDataset().getColumnCount()))
      .map(String.prototype.valueOf, "");

    for (var j = 0; j < dataset.getColumnCount(); j++) {
      values[dataset.columnIndices[j]] = v.getValue(j);
    }

    console.log(values);

    var trueIndices = morpheus.Util.getTrueIndices(dataset);

    es.then(function (essession) {
      var args = {
        es: essession,
        fieldValues: values
      };
      if (trueIndices.rows.length > 0) {
        args.rows = trueIndices.rows;
      }
      if (trueIndices.columns.length > 0) {
        args.columns = trueIndices.columns;
      }
      console.log(args);
      var req = ocpu.call("limmaAnalysis", args, function (session) {
        session.getObject(function (success) {
          console.log(success);
          var r = new FileReader();
          var filePath = morpheus.Util.getFilePath(session, success);

          r.onload = function (e) {
            var contents = e.target.result;
            var ProtoBuf = dcodeIO.ProtoBuf;
            ProtoBuf.protoFromFile("./message.proto", function (error, success) {
              if (error) {
                alert(error);
                console.log("LimmaTool ::", "ProtoBuilder failed", error);
              }
              var builder = success,
                rexp = builder.build("rexp"),
                REXP = rexp.REXP,
                rclass = REXP.RClass;
              var res = REXP.decode(contents);
              var data = morpheus.Util.getRexpData(res, rclass);
              var names = morpheus.Util.getFieldNames(res, rclass);
              var vs = [];
              var rows = trueIndices.rows.length > 0 ? trueIndices.rows : dataset.rowIndices;
              console.log(trueIndices.rows);
              /*if (trueIndices.rows.length > 0) {
               var backRows = Array.apply(null, Array(dataset.rowIndices.length)).map(Number.prototype.valueOf,0);
               for (var i = 0; i < trueIndices.rows.length; i++) {
               backRows[rows[i]] = i;
               }
               rows = backRows;
               }*/
              console.log("rows", rows);
              names.forEach(function (name) {
                if (name !== "symbol") {
                  console.log(name, data[name]);
                  var v = dataset.getRowMetadata().add(name);
                  for (var i = 0; i < dataset.getRowCount(); i++) {
                    v.setValue(i, data[name].values[i]);
                  }
                  vs.push(v);
                }

              });
              alert("Limma finished successfully");
              project.trigger('trackChanged', {
                vectors: vs,
                render: []
              });
            })
          };
          morpheus.BlobFromPath.getFileObject(filePath, function (file) {
            r.readAsArrayBuffer(file);
          });
        })
      }, false, "::es");
      req.fail(function () {
        console.log(req.responseText);
      });
    });
  }
};
morpheus.MarkerSelection = function () {

};

/**
 * @private
 */
morpheus.MarkerSelection.Functions = [morpheus.FisherExact,
  morpheus.FoldChange, morpheus.SignalToNoise,
  morpheus.createSignalToNoiseAdjust(), morpheus.TTest];

morpheus.MarkerSelection.Functions.fromString = function (s) {
  for (var i = 0; i < morpheus.MarkerSelection.Functions.length; i++) {
    if (morpheus.MarkerSelection.Functions[i].toString() === s) {
      return morpheus.MarkerSelection.Functions[i];
    }
  }
  throw s + ' not found';
};
morpheus.MarkerSelection.execute = function (dataset, input) {
  var aIndices = [];
  var bIndices = [];
  for (var i = 0; i < input.numClassA; i++) {
    aIndices[i] = i;
  }
  for (var i = input.numClassA; i < dataset.getColumnCount(); i++) {
    bIndices[i] = i;
  }

  var f = morpheus.MarkerSelection.Functions.fromString(input.metric);
  var permutations = new morpheus.PermutationPValues(dataset, aIndices,
    bIndices, input.npermutations, f);
  return {
    rowSpecificPValues: permutations.rowSpecificPValues,
    k: permutations.k,
    fdr: permutations.fdr,
    scores: permutations.scores
  };
};
morpheus.MarkerSelection.prototype = {
  toString: function () {
    return 'Marker Selection';
  },
  init: function (project, form) {
    var _this = this;
    var updateAB = function (fieldNames) {
      var ids = [];
      if (fieldNames != null) {
        var vectors = morpheus.MetadataUtil.getVectors(project
          .getFullDataset().getColumnMetadata(), fieldNames);
        var idToIndices = morpheus.VectorUtil
          .createValuesToIndicesMap(vectors);
        idToIndices.forEach(function (indices, id) {
          ids.push(id);
        });
      }
      ids.sort();
      form.setOptions('class_a', ids);
      form.setOptions('class_b', ids);

    };
    var $field = form.$form.find('[name=field]');
    $field.on('change', function (e) {
      updateAB($(this).val());
    });

    if ($field[0].options.length > 0) {
      $field.val($field[0].options[0].value);
    }
    updateAB($field.val());
    var $metric = form.$form.find('[name=metric]');
    $metric.on('change', function (e) {
      var isFishy = $(this).val() === 'Fisher Exact Test';
      form.setVisible('grouping_value', isFishy);
      form.setVisible('permutations', !isFishy);
      form.setVisible('number_of_markers', !isFishy);

    });
    form.setVisible('grouping_value', false);

  },
  gui: function (project) {
    var dataset = project.getSortedFilteredDataset();
    var fields = morpheus.MetadataUtil.getMetadataNames(dataset
      .getColumnMetadata());
    return [
      {
        name: 'metric',
        options: morpheus.MarkerSelection.Functions,
        value: morpheus.SignalToNoise.toString(),
        type: 'select',
        help: ''
      },
      {
        name: 'grouping_value',
        value: '1',
        help: 'Class values are categorized into two groups based on whether dataset values are greater than or equal to this value',
      },
      {
        name: 'field',
        options: fields,
        type: 'select',
        multiple: true
      },
      {
        name: 'class_a',
        title: 'Class A',
        options: [],
        value: '',
        type: 'checkbox-list',
        multiple: true
      },
      {
        name: 'class_b',
        title: 'Class B',
        options: [],
        value: '',
        type: 'checkbox-list',
        multiple: true
      },
      {
        name: 'number_of_markers',
        value: '100',
        type: 'text',
        help: 'The initial number of markers to show in each direction. Click <button title="Filter (Ctrl+L)" type="button" class="btn btn-default btn-xs dropdown-toggle"><span class="fa fa-filter"></span></button> to change.'
      }, {
        name: 'permutations',
        value: '0',
        type: 'text'
      }];
  },
  execute: function (options) {

    var project = options.project;
    // classA and classB are arrays of identifiers if run via user
    // interface. If run via JSON, will be string arrays
    var classA = options.input.class_a;

    for (var i = 0; i < classA.length; i++) {
      var val = classA[i];
      if (!(val instanceof morpheus.Identifier)) {
        classA[i] = new morpheus.Identifier(
          morpheus.Util.isArray(val) ? val : [val]);
      }
    }
    var classB = options.input.class_b;
    for (var i = 0; i < classB.length; i++) {
      var val = classB[i];
      if (!(val instanceof morpheus.Identifier)) {
        classB[i] = new morpheus.Identifier(
          morpheus.Util.isArray(val) ? val : [val]);
      }
    }
    var npermutations = parseInt(options.input.permutations);
    var fieldNames = options.input.field;
    if (!morpheus.Util.isArray(fieldNames)) {
      fieldNames = [fieldNames];
    }
    var dataset = project.getSortedFilteredDataset();
    var vectors = morpheus.MetadataUtil.getVectors(dataset
      .getColumnMetadata(), fieldNames);

    var idToIndices = morpheus.VectorUtil.createValuesToIndicesMap(vectors);
    var f = morpheus.MarkerSelection.Functions
      .fromString(options.input.metric);

    var aIndices = [];
    var bIndices = [];
    classA.forEach(function (id) {
      var indices = idToIndices.get(id);
      if (indices === undefined) {
        throw new Error(id + ' not found in ' + idToIndices.keys());
      }
      aIndices = aIndices.concat(indices);
    });
    classB.forEach(function (id) {
      var indices = idToIndices.get(id);
      if (indices === undefined) {
        throw new Error(id + ' not found in ' + idToIndices.keys());
      }
      bIndices = bIndices.concat(indices);
    });

    if (aIndices.length === 0 && bIndices.length === 0) {
      throw 'No samples in class A and class B';
    }

    if (aIndices.length === 0) {
      throw 'No samples in class A';
    }
    if (bIndices.length === 0) {
      throw 'No samples in class B';
    }

    var classASet = {};
    for (var i = 0; i < aIndices.length; i++) {
      classASet[aIndices[i]] = true;
    }
    for (var i = 0; i < bIndices.length; i++) {
      if (classASet[bIndices[i]]) {
        throw 'The sample was found in class A and class B';
      }
    }
    var isFishy = f.toString() === morpheus.FisherExact.toString();
    if (aIndices.length === 1 || bIndices.length === 1
      && !(f instanceof morpheus.FisherExact)) {
      f = morpheus.FoldChange;
    }
    var list1 = new morpheus.DatasetRowView(new morpheus.SlicedDatasetView(
      dataset, null, aIndices));
    var list2 = new morpheus.DatasetRowView(new morpheus.SlicedDatasetView(
      dataset, null, bIndices));
    // remove
    // other
    // marker
    // selection
    // fields
    var markerSelectionFields = morpheus.MarkerSelection.Functions.map(
      function (f) {
        return f.toString();
      }).concat(['odds_ratio', 'FDR(BH)', 'p_value']);
    markerSelectionFields.forEach(function (name) {
      var index = morpheus.MetadataUtil.indexOf(dataset.getRowMetadata(),
        name);
      if (index !== -1) {
        dataset.getRowMetadata().remove(index);
        options.heatMap.removeTrack(name, false);
      }
    });
    var v = dataset.getRowMetadata().add(f.toString());
    var vectors = [v];
    var comparisonVector = dataset.getColumnMetadata().add('Comparison');

    for (var i = 0; i < aIndices.length; i++) {
      comparisonVector.setValue(aIndices[i], 'A');
    }
    for (var i = 0; i < bIndices.length; i++) {
      comparisonVector.setValue(bIndices[i], 'B');
    }
    function done() {

      if (project.getRowFilter().getFilters().length > 0) {
        project.getRowFilter().setAnd(true, true);
      }
      var rowFilters = project.getRowFilter().getFilters();
      // remove existing top n filters
      for (var i = 0; i < rowFilters.length; i++) {
        if (rowFilters[i] instanceof morpheus.TopNFilter) {
          project.getRowFilter().remove(i, true);
          i--;
        }
      }
      if (!isFishy) {
        project.getRowFilter().add(
          new morpheus.TopNFilter(
            parseInt(options.input.number_of_markers),
            morpheus.TopNFilter.TOP_BOTTOM, vectors[0]
              .getName()), true);
      }

      project.setRowFilter(project.getRowFilter(), true);
      project.setRowSortKeys([new morpheus.SortKey(vectors[0].getName(),
        isFishy ? morpheus.SortKey.SortOrder.ASCENDING
          : morpheus.SortKey.SortOrder.DESCENDING)], true);
      // select samples used in comparison
      var selectedColumnIndices = new morpheus.Set();
      aIndices.forEach(function (index) {
        selectedColumnIndices.add(index);
      });
      bIndices.forEach(function (index) {
        selectedColumnIndices.add(index);
      });
      project.getColumnSelectionModel().setViewIndices(selectedColumnIndices, true);

      project.setColumnSortKeys([new morpheus.SortKey(comparisonVector
        .getName(), morpheus.SortKey.SortOrder.ASCENDING)], true);

      project.trigger('trackChanged', {
        vectors: vectors,
        render: vectors.map(function () {
          return 'text';
        }),
        columns: false
      });
      project.trigger('trackChanged', {
        vectors: [comparisonVector],
        render: ['color'],
        columns: true
      });
    }

    if (isFishy) {
      var groupingValue = parseFloat(options.input.grouping_value);
      var oddsRatioVector = dataset.getRowMetadata().add('odds_ratio');
      var fdrVector = dataset.getRowMetadata().add('FDR(BH)');
      var contingencyTableVector = dataset.getRowMetadata().add(
        'contingency_table');
      var pvalues = [];
      for (var i = 0, size = dataset.getRowCount(); i < size; i++) {
        var abcd = morpheus.createContingencyTable(list1.setIndex(i),
          list2.setIndex(i), groupingValue);
        contingencyTableVector.setValue(i, '[[' + abcd[0] + ', '
          + abcd[1] + '], [' + abcd[2] + ', ' + abcd[3] + ']]');
        var ratio = (abcd[0] * abcd[3]) / (abcd[1] * abcd[2]);
        if (isNaN(ratio) || ratio === Number.POSITIVE_INFINITY) {
          ratio = 0;
        }
        oddsRatioVector.setValue(i, ratio);
        v.setValue(i, morpheus.FisherExact.fisherTest(abcd[0], abcd[1],
          abcd[2], abcd[3]));
        pvalues.push(v.getValue(i));
      }
      var fdr = morpheus.FDR_BH(pvalues);
      for (var i = 0, size = dataset.getRowCount(); i < size; i++) {
        fdrVector.setValue(i, fdr[i]);
      }
      vectors.push(oddsRatioVector);
      vectors.push(fdrVector);
      vectors.push(contingencyTableVector);
      done();
    } else {
      // background
      if (npermutations > 0) {
        options.input.numClassA = aIndices.length;
        options.input.npermutations = npermutations;
        var blob = new Blob(
          ['self.onmessage = function(e) {'
          + 'importScripts(e.data.scripts);'
          + 'self.postMessage(morpheus.MarkerSelection.execute(morpheus.Dataset.fromJSON(e.data.dataset), e.data.input));'
          + '}']);

        var url = window.URL.createObjectURL(blob);
        var worker = new Worker(url);
        var subset = new morpheus.SlicedDatasetView(dataset, null,
          aIndices.concat(bIndices));

        worker.postMessage({
          scripts: morpheus.Util.getScriptPath(),
          dataset: morpheus.Dataset.toJSON(subset, {
            columnFields: [],
            rowFields: [],
            seriesIndices: [0]
          }),
          input: options.input
        });

        worker.onmessage = function (e) {
          var result = e.data;
          var pvalueVector = dataset.getRowMetadata().add('p_value');
          var fdrVector = dataset.getRowMetadata().add('FDR(BH)');
          var kVector = dataset.getRowMetadata().add('k');

          for (var i = 0, size = pvalueVector.size(); i < size; i++) {
            pvalueVector.setValue(i, result.rowSpecificPValues[i]);
            fdrVector.setValue(i, result.fdr[i]);
            kVector.setValue(i, result.k[i]);
            v.setValue(i, result.scores[i]);
          }
          vectors.push(pvalueVector);
          vectors.push(fdrVector);
          vectors.push(kVector);
          done();
          worker.terminate();
          window.URL.revokeObjectURL(url);
        };
        return worker;
      } else {
        for (var i = 0, size = dataset.getRowCount(); i < size; i++) {
          v.setValue(i, f(list1.setIndex(i), list2.setIndex(i)));
        }
        done();
      }
    }

  }
};

morpheus.NearestNeighbors = function () {
};
morpheus.NearestNeighbors.Functions = [morpheus.Cosine, morpheus.Euclidean,
  morpheus.Jaccard, morpheus.KendallsCorrelation, morpheus.Pearson, morpheus.Spearman,
  morpheus.WeightedMean];
morpheus.NearestNeighbors.Functions.fromString = function (s) {
  for (var i = 0; i < morpheus.NearestNeighbors.Functions.length; i++) {
    if (morpheus.NearestNeighbors.Functions[i].toString() === s) {
      return morpheus.NearestNeighbors.Functions[i];
    }
  }
  throw new Error(s + ' not found');
};
morpheus.NearestNeighbors.prototype = {
  toString: function () {
    return 'Nearest Neighbors';
  },
  init: function (project, form) {
    var $selectedOnly = form.$form.find('[name=use_selected_only]')
      .parent();
    form.$form
      .find('[name=compute_nearest_neighbors_of]')
      .on(
        'change',
        function (e) {
          var val = $(this).val();
          if (val === 'selected rows' || val === 'column annotation') {
            $($selectedOnly.contents()[1])
              .replaceWith(
                document
                  .createTextNode(' Use selected columns only'));
          } else {
            $($selectedOnly.contents()[1])
              .replaceWith(
                document
                  .createTextNode(' Use selected rows only'));
          }
          form.setVisible('annotation', false);
          if (val === 'column annotation' || val === 'row annotation') {
            var metadata = val === 'column annotation' ? project.getFullDataset()
              .getColumnMetadata() : project.getFullDataset()
              .getRowMetadata();
            var names = [];
            // get numeric columns only
            for (var i = 0; i < metadata.getMetadataCount(); i++) {
              var v = metadata.get(i);
              if (morpheus.VectorUtil.getDataType(v) === 'number') {
                names.push(v.getName());
              }
            }
            names.sort(function (a, b) {
              a = a.toLowerCase();
              b = b.toLowerCase();
              return (a < b ? -1 : (a === b ? 0 : 1));
            });
            form
              .setOptions('annotation', names);
            form.setVisible('annotation', true);
          }
        });
    $($selectedOnly.contents()[1]).replaceWith(
      document.createTextNode(' Use selected columns only'));
    form.setVisible('annotation', false);
  },
  gui: function () {
    return [{
      name: 'metric',
      options: morpheus.NearestNeighbors.Functions,
      value: morpheus.Pearson.toString(),
      type: 'select'
    }, {
      name: 'compute_nearest_neighbors_of',
      options: ['selected rows', 'selected columns', 'column annotation', 'row annotation'],
      value: 'selected rows',
      type: 'radio'
    }, {
      name: 'use_selected_only',
      type: 'checkbox'
    }, {
      name: 'annotation',
      type: 'bootstrap-select'
    }];
  },
  execute: function (options) {
    var project = options.project;
    var isColumns = options.input.compute_nearest_neighbors_of == 'selected columns' || options.input.compute_nearest_neighbors_of == 'row annotation';
    var isAnnotation = options.input.compute_nearest_neighbors_of == 'column annotation' || options.input.compute_nearest_neighbors_of == 'row annotation';
    var heatMap = options.heatMap;
    var f = morpheus.NearestNeighbors.Functions
      .fromString(options.input.metric);
    var dataset = project.getSortedFilteredDataset();

    if (isColumns) {
      // compute the nearest neighbors of row, so need to transpose
      dataset = morpheus.DatasetUtil.transposedView(dataset);
    }
    var selectedIndices = (isColumns ? project.getColumnSelectionModel()
      : project.getRowSelectionModel()).getViewIndices().values();
    if (!isAnnotation && selectedIndices.length === 0) {
      throw new Error('No ' + (isColumns ? 'columns' : 'rows')
        + ' selected');
    }
    var spaceIndices = null;
    if (options.input.use_selected_only) {
      spaceIndices = (!isColumns ? project.getColumnSelectionModel()
        : project.getRowSelectionModel()).getViewIndices().values();
      dataset = morpheus.DatasetUtil.slicedView(dataset, null,
        spaceIndices);
    }
    var d1 = morpheus.DatasetUtil
      .slicedView(dataset, selectedIndices, null);
    var list1;
    if (isAnnotation) {
      list1 = dataset.getColumnMetadata().getByName(options.input.annotation);
      if (!list1) {
        throw new Error('No annotation selected.');
      }
    } else {
      if (d1.getRowCount() > 1) {
        // collapse each column in the dataset to a single value
        var columnView = new morpheus.DatasetColumnView(d1);
        var newDataset = new morpheus.Dataset({
          name: '',
          rows: 1,
          columns: d1.getColumnCount()
        });
        for (var j = 0, ncols = d1.getColumnCount(); j < ncols; j++) {
          var v = morpheus.Percentile(columnView.setIndex(j), 50);
          newDataset.setValue(0, j, v);
        }
        d1 = newDataset;
      }
      list1 = new morpheus.DatasetRowView(d1);
    }

    var list2 = new morpheus.DatasetRowView(dataset);
    var values = [];
    var v = dataset.getRowMetadata().getByName(f.toString());
    if (v == null) {
      v = dataset.getRowMetadata().add(f.toString());
    }
    for (var i = 0, size = dataset.getRowCount(); i < size; i++) {
      v.setValue(i, f(list1, list2.setIndex(i)));
    }
    if (!isColumns) {
      project.setRowSortKeys([new morpheus.SortKey(f.toString(),
        morpheus.SortKey.SortOrder.DESCENDING)], true);
    } else {
      project.setColumnSortKeys([new morpheus.SortKey(f.toString(),
        morpheus.SortKey.SortOrder.DESCENDING)], true);
    }
    project.trigger('trackChanged', {
      vectors: [v],
      render: ['text'],
      columns: isColumns
    });
  }
};

morpheus.NewHeatMapTool = function () {
};
morpheus.NewHeatMapTool.prototype = {
  toString: function () {
    return 'New Heat Map';
  },
  // gui : function() {
  // return [ {
  // name : 'name',
  // type : 'text'
  // }, {
  // name : 'include_selected_rows',
  // type : 'checkbox',
  // value : true
  // }, {
  // name : 'include_selected_columns',
  // type : 'checkbox',
  // value : true
  // } ];
  // },
  execute: function (options) {
    var project = options.project;
    var heatMap = options.heatMap;
    var dataset = project.getSelectedDataset({
      selectedRows: true,
      selectedColumns: true
    });
    morpheus.DatasetUtil.shallowCopy(dataset);
    //morpheus.DatasetUtil.toESSessionPromise(dataset);
    console.log(dataset);
    // TODO see if we can subset dendrograms
    // only handle contiguous selections for now
    // if (heatMap.columnDendrogram != null) {
    // var indices = project.getColumnSelectionModel().getViewIndices()
    // .toArray();
    // morpheus.DendrogramUtil.leastCommonAncestor();
    // }
    // if (heatMap.rowDendrogram != null) {
    //
    // }
    var heatmap = new morpheus.HeatMap({
      name: heatMap.getName(),
      dataset: dataset,
      parent: heatMap,
      symmetric: project.isSymmetric() && dataset.getColumnCount() === dataset.getRowCount()
    });

  }
};

morpheus.OpenDatasetTool = function () {
  this.customUrls = [];
};

morpheus.OpenDatasetTool.fileExtensionPrompt = function (file, callback) {
  var ext = morpheus.Util.getExtension(morpheus.Util.getFileName(file));
  var deferred;
  if (ext === 'seg' || ext === 'segtab') {
    this._promptSegtab(function (regions) {
      callback(regions);
    });

  } else {
    callback(null);
  }

};
morpheus.OpenDatasetTool._promptMaf = function (promptCallback) {
  var formBuilder = new morpheus.FormBuilder();
  formBuilder
    .append({
      name: 'MAF_gene_symbols',
      value: '',
      type: 'textarea',
      required: true,
      help: 'Enter one gene symbol per line to filter genes. Leave blank to show all genes.'
    });
  morpheus.FormBuilder
    .showInModal({
      title: 'Gene Symbols',
      html: formBuilder.$form,
      close: 'OK',
      onClose: function () {
        var text = formBuilder.getValue('MAF_gene_symbols');
        var lines = morpheus.Util.splitOnNewLine(text);
        var mafGeneFilter = new morpheus.Map();
        for (var i = 0, nlines = lines.length, counter = 0; i < nlines; i++) {
          var line = lines[i];
          if (line !== '') {
            mafGeneFilter.set(line, counter++);
          }
        }
        var readOptions = mafGeneFilter.size() > 0 ? {
          mafGeneFilter: mafGeneFilter
        } : null;
        promptCallback(readOptions);
      }
    });
};
morpheus.OpenDatasetTool._promptSegtab = function (promptCallback) {
  var formBuilder = new morpheus.FormBuilder();
  formBuilder
    .append({
      name: 'regions',
      value: '',
      type: 'textarea',
      required: true,
      help: 'Define the regions over which you want to define the CNAs. Enter one region per line. Each line should contain region_id, chromosome, start, and end separated by a tab. Leave blank to use all unique segments in the segtab file as regions.'
    });
  morpheus.FormBuilder
    .showInModal({
      title: 'Regions',
      html: formBuilder.$form,
      close: 'OK',
      onClose: function () {
        var text = formBuilder.getValue('regions');
        var lines = morpheus.Util.splitOnNewLine(text);
        var regions = [];
        var tab = /\t/;
        for (var i = 0, nlines = lines.length, counter = 0; i < nlines; i++) {
          var line = lines[i];

          if (line !== '') {
            var tokens = line.split(tab);
            if (tokens.length >= 4) {
              regions.push({
                id: tokens[0],
                chromosome: tokens[1],
                start: parseInt(tokens[2]),
                end: parseInt(tokens[3])
              });
            }
          }
        }
        var readOptions = regions.length > 0 ? {
          regions: regions
        } : null;
        promptCallback(readOptions);
      }
    });
};
morpheus.OpenDatasetTool.prototype = {
  toString: function () {
    return 'Open Dataset';
  },
  _read: function (options, deferred) {
    var _this = this;
    var project = options.project;
    var heatMap = options.heatMap;
    var file = options.input.file;
    var action = options.input.open_file_action;
    var dataset = project.getSortedFilteredDataset();
    deferred.fail(function (err) {
      var message = ['Error opening ' + morpheus.Util.getFileName(file)
      + '.'];
      if (err.message) {
        message.push('<br />Cause: ');
        message.push(err.message);
      }
      morpheus.FormBuilder.showInModal({
        title: 'Error',
        html: message.join('')
      });
    });
    deferred
      .done(function (newDataset) {

        var extension = morpheus.Util.getExtension(morpheus.Util
          .getFileName(file));
        var filename = morpheus.Util.getBaseFileName(morpheus.Util
          .getFileName(file));
        if (action === 'append' || action === 'append columns') {

          // "append": append rows to current dataset
          var appendRows = action === 'append';
          // rename fields?
          _.each(heatMap.options.rows, function (item) {
            if (item.renameTo) {
              var v = newDataset.getRowMetadata().getByName(
                item.field);
              if (v) {
                v.setName(item.renameTo);
              }
            }
          });
          _.each(heatMap.options.columns, function (item) {
            if (item.renameTo) {
              var v = newDataset.getColumnMetadata()
                .getByName(item.field);
              if (v) {
                v.setName(item.renameTo);
              }
            }
          });

          if (heatMap.options.datasetReady) {
            heatMap.options.datasetReady(newDataset);
          }
          var currentDatasetMetadataNames = morpheus.MetadataUtil
            .getMetadataNames(!appendRows ? dataset
              .getRowMetadata() : dataset
              .getColumnMetadata());
          var newDatasetMetadataNames = morpheus.MetadataUtil
            .getMetadataNames(!appendRows ? newDataset
              .getRowMetadata() : newDataset
              .getColumnMetadata());

          if (currentDatasetMetadataNames.length > 1
            || newDatasetMetadataNames.length > 1) {

            _this
              ._matchAppend(
                newDatasetMetadataNames,
                currentDatasetMetadataNames,
                heatMap,
                function (appendOptions) {
                  heatMap
                    .getProject()
                    .setFullDataset(
                      appendRows ? new morpheus.JoinedDataset(
                        dataset,
                        newDataset,
                        appendOptions.current_dataset_annotation_name,
                        appendOptions.new_dataset_annotation_name)
                        : new morpheus.TransposedDatasetView(
                        new morpheus.JoinedDataset(
                          new morpheus.TransposedDatasetView(
                            dataset),
                          new morpheus.TransposedDatasetView(
                            newDataset),
                          appendOptions.current_dataset_annotation_name,
                          appendOptions.new_dataset_annotation_name)),
                      true);

                  if (heatMap.options.renderReady) {
                    heatMap.options
                      .renderReady(heatMap);
                    heatMap.updateDataset();
                  }
                  if (appendRows) {
                    heatMap
                      .getHeatMapElementComponent()
                      .getColorScheme()
                      .setSeparateColorSchemeForRowMetadataField(
                        'Source');

                    var sourcesSet = morpheus.VectorUtil
                      .getSet(heatMap
                        .getProject()
                        .getFullDataset()
                        .getRowMetadata()
                        .getByName(
                          'Source'));
                    sourcesSet
                      .forEach(function (source) {
                        heatMap
                          .autoDisplay({
                            extension: morpheus.Util
                              .getExtension(source),
                            filename: source
                          });
                      });
                  }

                  heatMap.tabManager
                    .setTabTitle(
                      heatMap.tabId,
                      heatMap
                        .getProject()
                        .getFullDataset()
                        .getRowCount()
                      + ' row'
                      + morpheus.Util
                        .s(heatMap
                          .getProject()
                          .getFullDataset()
                          .getRowCount())
                      + ' x '
                      + heatMap
                        .getProject()
                        .getFullDataset()
                        .getColumnCount()
                      + ' column'
                      + morpheus.Util
                        .s(heatMap
                          .getProject()
                          .getFullDataset()
                          .getColumnCount()));
                  heatMap.revalidate();
                });
          } else { // no need to prompt
            heatMap
              .getProject()
              .setFullDataset(
                appendRows ? new morpheus.JoinedDataset(
                  dataset,
                  newDataset,
                  currentDatasetMetadataNames[0],
                  newDatasetMetadataNames[0])
                  : new morpheus.TransposedDatasetView(
                  new morpheus.JoinedDataset(
                    new morpheus.TransposedDatasetView(
                      dataset),
                    new morpheus.TransposedDatasetView(
                      newDataset),
                    currentDatasetMetadataNames[0],
                    newDatasetMetadataNames[0])),
                true);
            if (heatMap.options.renderReady) {
              heatMap.options.renderReady(heatMap);
              heatMap.updateDataset();
            }
            if (appendRows) {
              heatMap
                .getHeatMapElementComponent()
                .getColorScheme()
                .setSeparateColorSchemeForRowMetadataField(
                  'Source');
              var sourcesSet = morpheus.VectorUtil
                .getSet(heatMap.getProject()
                  .getFullDataset()
                  .getRowMetadata().getByName(
                    'Source'));
              sourcesSet.forEach(function (source) {
                heatMap.autoDisplay({
                  extension: morpheus.Util
                    .getExtension(source),
                  filename: source
                });
              });
            }
            heatMap.tabManager.setTabTitle(heatMap.tabId,
              heatMap.getProject().getFullDataset()
                .getRowCount()
              + ' row'
              + morpheus.Util.s(heatMap
                .getProject()
                .getFullDataset()
                .getRowCount())
              + ' x '
              + heatMap.getProject()
                .getFullDataset()
                .getColumnCount()
              + ' column'
              + morpheus.Util.s(heatMap
                .getProject()
                .getFullDataset()
                .getColumnCount()));
            heatMap.revalidate();
          }

        } else if (action === 'overlay') {
          _this
            ._matchOverlay(
              morpheus.MetadataUtil
                .getMetadataNames(newDataset
                  .getColumnMetadata()),
              morpheus.MetadataUtil
                .getMetadataNames(dataset
                  .getColumnMetadata()),
              morpheus.MetadataUtil
                .getMetadataNames(newDataset
                  .getRowMetadata()),
              morpheus.MetadataUtil
                .getMetadataNames(dataset
                  .getRowMetadata()),
              heatMap,
              function (appendOptions) {
                morpheus.DatasetUtil.overlay({
                  dataset: dataset,
                  newDataset: newDataset,
                  rowAnnotationName: appendOptions.current_dataset_row_annotation_name,
                  newRowAnnotationName: appendOptions.new_dataset_row_annotation_name,
                  columnAnnotationName: appendOptions.current_dataset_column_annotation_name,
                  newColumnAnnotationName: appendOptions.new_dataset_column_annotation_name
                });
              });
        } else if (action === 'open') { // new tab
          new morpheus.HeatMap({
            dataset: newDataset,
            parent: heatMap,
            inheritFromParent: false
          });

        } else {
          console.log('Unknown action: ' + action);
        }

        heatMap.revalidate();
      });
  },
  execute: function (options) {
    var file = options.input.file;
    var _this = this;
    morpheus.OpenDatasetTool
      .fileExtensionPrompt(file,
        function (readOptions) {
          if (!readOptions) {
            readOptions = {};
          }
          readOptions.interactive = true;
          var deferred = morpheus.DatasetUtil.read(file,
            readOptions);
          _this._read(options, deferred);
        });

  }, // prompt for metadata field name in dataset and in file
  _matchAppend: function (newDatasetMetadataNames,
                          currentDatasetMetadataNames, heatMap, callback) {
    var tool = {};
    tool.execute = function (options) {
      return options.input;
    };
    tool.toString = function () {
      return 'Select Fields';
    };
    tool.gui = function () {
      var items = [{
        name: 'current_dataset_annotation_name',
        options: currentDatasetMetadataNames,
        type: 'select',
        value: 'id',
        required: true
      }];
      items.push({
        name: 'new_dataset_annotation_name',
        type: 'select',
        value: 'id',
        options: newDatasetMetadataNames,
        required: true
      });
      return items;
    };
    morpheus.HeatMap.showTool(tool, heatMap, callback);
  },
  _matchOverlay: function (newDatasetColumnMetadataNames,
                           currentDatasetColumnMetadataNames, newDatasetRowMetadataNames,
                           currentDatasetRowMetadataNames, heatMap, callback) {
    var tool = {};
    tool.execute = function (options) {
      return options.input;
    };
    tool.toString = function () {
      return 'Select Fields';
    };
    tool.gui = function () {
      var items = [];
      items.push({
        name: 'current_dataset_column_annotation_name',
        options: currentDatasetColumnMetadataNames,
        type: 'select',
        value: 'id',
        required: true
      });
      items.push({
        name: 'new_dataset_column_annotation_name',
        type: 'select',
        value: 'id',
        options: newDatasetColumnMetadataNames,
        required: true
      });
      items.push({
        name: 'current_dataset_row_annotation_name',
        options: currentDatasetRowMetadataNames,
        type: 'select',
        value: 'id',
        required: true
      });
      items.push({
        name: 'new_dataset_row_annotation_name',
        type: 'select',
        value: 'id',
        options: newDatasetRowMetadataNames,
        required: true
      });
      return items;
    };
    morpheus.HeatMap.showTool(tool, heatMap, callback);
  }
};

morpheus.OpenDendrogramTool = function (file) {
  this._file = file;
};
morpheus.OpenDendrogramTool.prototype = {
  toString: function () {
    return 'Open Dendrogram';
  },
  init: function (project, form) {
    var setValue = function (val) {
      var isRows = val === 'Rows';
      var names = morpheus.MetadataUtil.getMetadataNames(isRows ? project
        .getFullDataset().getRowMetadata() : project
        .getFullDataset().getColumnMetadata());
      names.unshift('Newick file does not contain node ids');
      form.setOptions('match_leaf_node_ids_to', names);
    };
    form.$form.find('[name=orientation]').on('change', function (e) {
      setValue($(this).val());
    });
    setValue('Columns');
  },
  gui: function () {
    return [{
      name: 'orientation',
      options: ['Columns', 'Rows'],
      value: 'Columns',
      type: 'radio'
    }, {
      name: 'match_leaf_node_ids_to',
      options: [],
      type: 'select'
    }];
  },
  execute: function (options) {
    var fileOrUrl = this._file;
    var isColumns = options.input.orientation === 'Columns';
    var dendrogramField = options.input.match_leaf_node_ids_to;
    if (dendrogramField == '' || dendrogramField === 'Newick file does not contain node ids') {
      dendrogramField = null;
    }
    var heatMap = options.heatMap;
    var dendrogramDeferred = morpheus.Util.getText(fileOrUrl);
    dendrogramDeferred
      .done(function (text) {
        var dataset = options.project.getSortedFilteredDataset();
        if (isColumns) {
          dataset = morpheus.DatasetUtil.transposedView(dataset);
        }
        var tree = morpheus.DendrogramUtil.parseNewick(text);
        if (tree.leafNodes.length !== dataset.getRowCount()) {
          throw new Error('# leaf nodes in dendrogram '
            + tree.leafNodes.length + ' != '
            + dataset.getRowCount());
        }
        var modelIndices = [];
        if (dendrogramField != null) {
          var vector = dataset.getRowMetadata().getByName(
            dendrogramField);
          var valueToIndex = morpheus.VectorUtil.createValueToIndexMap(vector);
          for (var i = 0, length = tree.leafNodes.length; i < length; i++) {
            var newickId = tree.leafNodes[i].name;
            var index = valueToIndex.get(newickId);
            if (index === undefined) {
              throw new Error('Unable to find dendrogram id '
                + tree.leafNodes[i].name
                + ' in annotations');
            }
            modelIndices.push(index);
          }
        } else {
          // see if leaf node ids are indices
          for (var i = 0, length = tree.leafNodes.length; i < length; i++) {
            var newickId = tree.leafNodes[i].name;
            newickId = parseInt(newickId);
            if (!isNaN(newickId)) {
              modelIndices.push(newickId);
            } else {
              break;
            }
          }

          if (modelIndices.length !== tree.leafNodes.length) {
            modelIndices = [];
            for (var i = 0, length = tree.leafNodes.length; i < length; i++) {
              modelIndices.push(i);
            }
          }
        }
        heatMap.setDendrogram(tree, isColumns, modelIndices);
      });
  }
};

morpheus.OpenFileTool = function (options) {
  this.options = options || {};
};
morpheus.OpenFileTool.prototype = {
  toString: function () {
    return 'Open';
  },
  gui: function () {
    var array = [{
      name: 'open_file_action',
      value: 'open',
      type: 'bootstrap-select',
      options: [{
        name: 'Open session',
        value: 'Open session'
      }, {divider: true}, {
        name: 'Annotate columns',
        value: 'Annotate Columns'
      }, {
        name: 'Annotate rows',
        value: 'Annotate Rows'
      }, {
        divider: true
      }, {
        name: 'Append rows to current dataset',
        value: 'append'
      }, {
        name: 'Append columns to current dataset',
        value: 'append columns'
      }, {
        name: 'Overlay onto current dataset',
        value: 'overlay'
      }, {
        name: 'Open dataset in new tab',
        value: 'open'
      }, {
        divider: true
      }, {
        name: 'Open dendrogram',
        value: 'Open dendrogram'
      }]
    }];
    if (this.options.file == null) {
      array.push({
        name: 'file',
        showLabel: false,
        placeholder: 'Open your own file',
        value: '',
        type: 'file',
        required: true,
        help: morpheus.DatasetUtil.DATASET_FILE_FORMATS
      });
    }
    array.options = {
      ok: this.options.file != null,
      size: 'modal-lg'
    };
    return array;
  },
  init: function (project, form, initOptions) {
    var $preloaded = $('<div></div>');
    form.$form.find('[name=open_file_action]').on(
      'change',
      function (e) {
        var action = $(this).val();
        if (action === 'append columns' || action === 'append'
          || action === 'open' || action === 'overlay') {
          form.setHelpText('file',
            morpheus.DatasetUtil.DATASET_FILE_FORMATS);
          $preloaded.show();
        } else if (action === 'Open dendrogram') {
          form.setHelpText('file',
            morpheus.DatasetUtil.DENDROGRAM_FILE_FORMATS);
          $preloaded.hide();
        } else if (action === 'Open session') {
          form.setHelpText('file', morpheus.DatasetUtil.SESSION_FILE_FORMAT);
          $preloaded.hide();
        } else {
          form.setHelpText('file',
            morpheus.DatasetUtil.ANNOTATION_FILE_FORMATS);
          $preloaded.hide();
        }
      });
    if (this.options.file == null) {
      $('<h4>Use your own file</h4>').insertAfter(
        form.$form.find('.form-group:first'));
      var _this = this;
      var collapseId = _.uniqueId('morpheus');
      $('<h4><a role="button" data-toggle="collapse" href="#'
        + collapseId
        + '" aria-expanded="false" aria-controls="'
        + collapseId + '">Or select a preloaded dataset</a></h4>').appendTo($preloaded);
      var $sampleDatasets = $('<div data-name="sampleData" id="' + collapseId + '" class="collapse"' +
        ' id="' + collapseId + '" style="overflow:auto;"></div>');
      $preloaded.appendTo(form.$form);
      var sampleDatasets = new morpheus.SampleDatasets({
        $el: $sampleDatasets,
        callback: function (heatMapOptions) {
          _this.options.file = heatMapOptions.dataset;
          _this.ok();
        }
      });
      $sampleDatasets.appendTo($preloaded);
    }
    form.on('change', function (e) {
      var value = e.value;
      if (value !== '' && value != null) {
        form.setValue('file', value);
        _this.options.file = value;
        _this.ok();
      }
    });

  },

  execute: function (options) {
    var that = this;
    var isInteractive = this.options.file == null;
    var heatMap = options.heatMap;
    if (!isInteractive) {
      options.input.file = this.options.file;
    }

    var project = options.project;
    if (options.input.open_file_action === 'Open session') {
      morpheus.Util.getText(options.input.file).done(function (text) {
        var options = JSON.parse(text);
        options.tabManager = heatMap.getTabManager();
        options.focus = true;
        options.inheritFromParent = false;
        options.landingPage = heatMap.options.landingPage;
        new morpheus.HeatMap(options);
      }).fail(function (err) {
        morpheus.FormBuilder.showMessageModal({
          title: 'Error',
          message: 'Unable to load session'
        });
      });
    } else if (options.input.open_file_action === 'append columns'
      || options.input.open_file_action === 'append'
      || options.input.open_file_action === 'open'
      || options.input.open_file_action === 'overlay') {
      new morpheus.OpenDatasetTool().execute(options);
    } else if (options.input.open_file_action === 'Open dendrogram') {
      morpheus.HeatMap.showTool(new morpheus.OpenDendrogramTool(
        options.input.file), options.heatMap);
    } else { // annotate rows or columns

      var isAnnotateColumns = options.input.open_file_action == 'Annotate Columns';
      var fileOrUrl = options.input.file;
      var dataset = project.getFullDataset();
      var fileName = morpheus.Util.getFileName(fileOrUrl);
      if (morpheus.Util.endsWith(fileName, '.cls')) {
        var result = morpheus.Util.readLines(fileOrUrl);
        result.done(function (lines) {
          that.annotateCls(heatMap, dataset, fileName,
            isAnnotateColumns, lines);
        });
      } else if (morpheus.Util.endsWith(fileName, '.gmt')) {
        morpheus.ArrayBufferReader.getArrayBuffer(fileOrUrl, function (err,
                                                                       buf) {
          if (err) {
            throw new Error('Unable to read ' + fileOrUrl);
          }
          var sets = new morpheus.GmtReader()
            .read(new morpheus.ArrayBufferReader(new Uint8Array(
              buf)));
          that.promptSets(dataset, heatMap, isAnnotateColumns,
            sets, morpheus.Util.getBaseFileName(morpheus.Util.getFileName(fileOrUrl)));
        });

      } else {
        var result = morpheus.Util.readLines(fileOrUrl);
        result.done(function (lines) {
          that.prompt(lines, dataset, heatMap, isAnnotateColumns);
        });

      }

    }
  },
  annotateCls: function (heatMap, dataset, fileName, isColumns, lines) {
    if (isColumns) {
      dataset = morpheus.DatasetUtil.transposedView(dataset);
    }
    var assignments = new morpheus.ClsReader().read(lines);
    if (assignments.length !== dataset.getRowCount()) {
      throw new Error(
        'Number of samples in cls file does not match dataset.');
    }
    var vector = dataset.getRowMetadata().add(
      morpheus.Util.getBaseFileName(fileName));
    for (var i = 0; i < assignments.length; i++) {
      vector.setValue(i, assignments[i]);
    }
    if (heatMap) {
      heatMap.getProject().trigger('trackChanged', {
        vectors: [vector],
        render: ['color'],
        columns: isColumns
      });
    }
  },

  annotateSets: function (dataset, isColumns, sets,
                          datasetMetadataName, setSourceFileName) {
    if (isColumns) {
      dataset = morpheus.DatasetUtil.transposedView(dataset);
    }
    var vector = dataset.getRowMetadata().getByName(datasetMetadataName);
    var idToIndices = morpheus.VectorUtil.createValueToIndicesMap(vector);
    var setVector = dataset.getRowMetadata().add(setSourceFileName);
    sets.forEach(function (set) {
      var name = set.name;
      var members = set.ids;
      members.forEach(function (id) {
        var indices = idToIndices.get(id);
        if (indices !== undefined) {
          for (var i = 0, nIndices = indices.length; i < nIndices; i++) {
            var array = setVector.getValue(indices[i]);
            if (array === undefined) {
              array = [];
            }
            array.push(name);
            setVector.setValue(indices[i], array);
          }
        }
      });
    });
    return setVector;
  },
  /**
   *
   * @param lines
   *            Lines of text in annotation file or null if a gmt file
   * @param dataset
   *            Current dataset
   * @param isColumns
   *            Whether annotating columns
   * @param sets
   *            Sets if a gmt file or null
   * @param metadataName
   *            The dataset metadata name to match on
   * @param fileColumnName
   *            The metadata file name to match on
   * @param fileColumnNamesToInclude
   *            An array of column names to include from the metadata file or
   *            null to include all
   */
  annotate: function (lines, dataset, isColumns, sets, metadataName,
                      fileColumnName, fileColumnNamesToInclude) {
    if (isColumns) {
      dataset = morpheus.DatasetUtil.transposedView(dataset);
    }
    var vector = dataset.getRowMetadata().getByName(metadataName);
    if (!vector) {
      throw new Error('vector ' + metadataName + ' not found.');
    }
    var vectors = [];
    var idToIndices = morpheus.VectorUtil.createValueToIndicesMap(vector);
    if (!lines) {
      _
        .each(
          sets,
          function (set) {
            var name = set.name;
            var members = set.ids;

            var v = dataset.getRowMetadata().add(name);
            vectors.push(v);
            _
              .each(
                members,
                function (id) {
                  var indices = idToIndices
                    .get(id);
                  if (indices !== undefined) {
                    for (var i = 0, nIndices = indices.length; i < nIndices; i++) {
                      v.setValue(
                        indices[i],
                        name);
                    }
                  }
                });
          });
    } else {
      var tab = /\t/;
      var header = lines[0].split(tab);
      var fileMatchOnColumnIndex = _.indexOf(header, fileColumnName);
      if (fileMatchOnColumnIndex === -1) {
        throw new Error(fileColumnName + ' not found in header:'
          + header);
      }
      var columnIndices = [];
      var nheaders = header.length;
      for (var j = 0; j < header.length; j++) {
        var name = header[j];
        if (j === fileMatchOnColumnIndex) {
          continue;
        }
        if (fileColumnNamesToInclude
          && _.indexOf(fileColumnNamesToInclude, name) === -1) {
          continue;
        }
        var v = dataset.getRowMetadata().getByName(name);
        if (!v) {
          v = dataset.getRowMetadata().add(name);
        }
        columnIndices.push(j);
        vectors.push(v);
      }
      var nheaders = columnIndices.length;
      for (var i = 1, nrows = lines.length; i < nrows; i++) {
        var line = lines[i].split(tab);
        var id = line[fileMatchOnColumnIndex];
        var indices = idToIndices.get(id);
        if (indices !== undefined) {
          var nIndices = indices.length;
          for (var j = 0; j < nheaders; j++) {
            var token = line[columnIndices[j]];
            var v = vectors[j];
            for (var r = 0; r < nIndices; r++) {
              v.setValue(indices[r], token);
            }
          }
        }
      }
    }
    for (var i = 0; i < vectors.length; i++) {
      morpheus.VectorUtil.maybeConvertStringToNumber(vectors[i]);
    }
    return vectors;
  },
  // prompt for metadata field name in dataset
  promptSets: function (dataset, heatMap, isColumns, sets, setSourceFileName) {
    var promptTool = {};
    var _this = this;
    promptTool.execute = function (options) {
      var metadataName = options.input.dataset_field_name;
      var vector = _this.annotateSets(dataset, isColumns, sets,
        metadataName, setSourceFileName);

      heatMap.getProject().trigger('trackChanged', {
        vectors: [vector],
        render: ['text'],
        columns: isColumns
      });
    };
    promptTool.toString = function () {
      return 'Select Fields To Match On';
    };
    promptTool.gui = function () {
      return [{
        name: 'dataset_field_name',
        options: morpheus.MetadataUtil
          .getMetadataNames(isColumns ? dataset
            .getColumnMetadata() : dataset.getRowMetadata()),
        type: 'select',
        value: 'id',
        required: true
      }];

    };
    morpheus.HeatMap.showTool(promptTool, heatMap);

  },
  prompt: function (lines, dataset, heatMap, isColumns) {
    var promptTool = {};
    var _this = this;
    var header = lines != null ? lines[0].split('\t') : null;
    promptTool.execute = function (options) {
      var metadataName = options.input.dataset_field_name;
      var fileColumnName = options.input.file_field_name;
      var vectors = _this.annotate(lines, dataset, isColumns, null,
        metadataName, fileColumnName);

      var nameToIndex = new morpheus.Map();
      var render = [];
      for (var i = 0; i < vectors.length; i++) {
        render.push(isColumns ? 'color' : 'text');
        nameToIndex.set(vectors[i].getName(), i);
      }
      if (lines.colors) {
        var colorModel = isColumns ? heatMap.getProject().getColumnColorModel() : heatMap.getProject().getRowColorModel();
        lines.colors.forEach(function (item) {
          var index = nameToIndex.get(item.header);
          var vector = vectors[index];
          render[index] = 'color';
          colorModel.setMappedValue(vector, item.value, item.color);
        });
      }
      heatMap.getProject().trigger('trackChanged', {
        vectors: vectors,
        render: render,
        columns: isColumns
      });
    };
    promptTool.toString = function () {
      return 'Select Fields To Match On';
    };
    promptTool.gui = function () {
      var items = [{
        name: 'dataset_field_name',
        options: morpheus.MetadataUtil
          .getMetadataNames(isColumns ? dataset
            .getColumnMetadata() : dataset.getRowMetadata()),
        type: 'select',
        required: true
      }];
      if (lines) {
        items.push({
          name: 'file_field_name',
          type: 'select',
          options: _.map(header, function (item) {
            return {
              name: item,
              value: item
            };
          }),
          required: true
        });
      }
      return items;
    };
    morpheus.HeatMap.showTool(promptTool, heatMap);
  }
};

morpheus.PcaPlotTool = function (chartOptions) {
  var _this = this;
  this.project = chartOptions.project;
  var project = this.project;


  this.$el = $('<div class="container-fluid">'
    + '<div class="row">'
    + '<div data-name="configPane" class="col-xs-2"></div>'
    + '<div class="col-xs-10"><div style="position:relative;" data-name="chartDiv"></div></div>'
    + '<div class=""'
    + '</div></div>');

  var formBuilder = new morpheus.FormBuilder({
    vertical: true
  });
  this.formBuilder = formBuilder;
  var rowOptions = [];
  var columnOptions = [];
  var numericRowOptions = [];
  var numericColumnOptions = [];
  var options = [];
  var numericOptions = [];
  var pcaOptions = [];
  var naOptions = [{
    name: 'mean',
    value: 'mean'
  }, {
    name: 'median',
    value: 'median'
  }];
  var updateOptions = function () {
    var dataset = project.getFullDataset();
    rowOptions = [{
      name: '(None)',
      value: ""
    }];
    columnOptions = [{
      name: '(None)',
      value: ""
    }];
    numericRowOptions = [{
      name: '(None)',
      value: ""
    }];
    numericColumnOptions = [{
      name: '(None)',
      value: ""
    }];
    options = [{
      name: '(None)',
      value: ""
    }];
    numericOptions = [{
      name: '(None)',
      value: ""
    }];
    pcaOptions = [];

    for (var i = 1; i <= _this.project.getSelectedDataset().getColumnCount(); i++) {
      pcaOptions.push({
        name: "PC" + String(i),
        value: i - 1
      });
    }


    morpheus.MetadataUtil.getMetadataNames(dataset.getRowMetadata())
      .forEach(
        function (name) {
          var dataType = morpheus.VectorUtil
            .getDataType(dataset.getRowMetadata()
              .getByName(name));
          if (dataType === 'number'
            || dataType === '[number]') {
            numericRowOptions.push({
              name: name + ' (row)',
              value: name
            });
          }
          rowOptions.push({
            name: name + ' (row)',
            value: name
          });
        });

    morpheus.MetadataUtil.getMetadataNames(dataset.getColumnMetadata())
      .forEach(
        function (name) {
          var dataType = morpheus.VectorUtil
            .getDataType(dataset.getColumnMetadata()
              .getByName(name));
          if (dataType === 'number'
            || dataType === '[number]') {
            numericColumnOptions.push({
              name: name + ' (column)',
              value: name
            });
          }
          columnOptions.push({
            name: name + ' (column)',
            value: name
          });
        });
  };

  updateOptions();

  //console.log(options);
  formBuilder.append({
    name: 'size',
    type: 'bootstrap-select',
    options: numericColumnOptions
  });
  formBuilder.append({
    name: 'color',
    type: 'bootstrap-select',
    options: columnOptions
  });
  formBuilder.append({
    name: 'x-axis',
    type: 'bootstrap-select',
    options: pcaOptions,
    value: 0
  });
  formBuilder.append({
    name: 'y-axis',
    type: 'bootstrap-select',
    options: pcaOptions,
    value: 1
  });
  formBuilder.append({
    name: 'label',
    type: 'bootstrap-select',
    options: columnOptions
  });
  formBuilder.append({
    name: 'replace_NA_with',
    type: 'bootstrap-select',
    options: naOptions
  });
  formBuilder.append({
    name: 'draw',
    type: 'button'
  });


  function setVisibility() {
    formBuilder.setOptions('color', columnOptions, true);
    formBuilder.setOptions('size', numericColumnOptions, true);
    formBuilder.setOptions('label', columnOptions, true);
    formBuilder.setOptions('replace_NA_with', naOptions, true);
  }

  this.tooltip = [];
  formBuilder.$form.find('select').on('change', function (e) {
    setVisibility();

  });
  /*formBuilder.$form.find('input').on('click', function () {
   _this.draw();
   });*/
  setVisibility();

  /*var draw = function () {
   _.debounce(_this.draw(), 100);
   };*/
  var trackChanged = function () {
    //console.log("track changed");
    updateOptions();
    setVisibility();
    formBuilder.setOptions('x-axis', pcaOptions, true);
    formBuilder.setOptions('y-axis', pcaOptions, true);
  };

  project.getColumnSelectionModel().on('selectionChanged.chart', trackChanged);
  project.getRowSelectionModel().on('selectionChanged.chart', trackChanged);
  project.on('trackChanged.chart', trackChanged);
  this.$chart = this.$el.find('[data-name=chartDiv]');
  var $dialog = $('<div style="background:white;" title="Chart"></div>');
  var $configPane = this.$el.find('[data-name=configPane]');
  formBuilder.$form.appendTo($configPane);
  this.$el.appendTo($dialog);
  $dialog.dialog({
    close: function (event, ui) {
      project.off('trackChanged.chart', trackChanged);
      project.getRowSelectionModel().off('selectionChanged.chart', trackChanged);
      project.getColumnSelectionModel().off('selectionChanged.chart', trackChanged);
      _this.$el.empty();
    },

    resizable: true,
    height: 600,
    width: 950
  });
  this.$dialog = $dialog;

  this.draw();
};

morpheus.PcaPlotTool.getVectorInfo = function (value) {
  var field = value.substring(0, value.length - 2);
  var isColumns = value.substring(value.length - 2) === '_c';
  return {
    field: field,
    isColumns: isColumns
  };
};
morpheus.PcaPlotTool.prototype = {
  annotate: function (options) {
    var _this = this;
    var formBuilder = new morpheus.FormBuilder();
    formBuilder.append({
      name: 'annotation_name',
      type: 'text',
      required: true
    });
    formBuilder.append({
      name: 'annotation_value',
      type: 'text',
      required: true
    });
    morpheus.FormBuilder
      .showOkCancel({
        title: 'Annotate Selection',
        content: formBuilder.$form,
        okCallback: function () {
          var dataset = options.dataset;
          var eventData = options.eventData;
          var array = options.array;
          var value = formBuilder.getValue('annotation_value');
          var annotationName = formBuilder
            .getValue('annotation_name');
          // var annotate = formBuilder.getValue('annotate');
          var isRows = true;
          var isColumns = true;
          var existingRowVector = null;
          var rowVector = null;
          if (isRows) {
            existingRowVector = dataset.getRowMetadata()
              .getByName(annotationName);
            rowVector = dataset.getRowMetadata().add(
              annotationName);
          }
          var existingColumnVector = null;
          var columnVector = null;
          if (isColumns) {
            existingColumnVector = dataset.getColumnMetadata()
              .getByName(annotationName);
            columnVector = dataset.getColumnMetadata().add(
              annotationName);
          }

          for (var p = 0, nselected = eventData.points.length; p < nselected; p++) {
            var item = array[eventData.points[p].pointNumber];
            if (isRows) {
              if (_.isArray(item.row)) {
                item.row.forEach(function (r) {
                  rowVector.setValue(r, value);
                });

              } else {
                rowVector.setValue(item.row, value);
              }

            }
            if (isColumns) {
              columnVector.setValue(item.column, value);
            }
          }
          if (isRows) {
            morpheus.VectorUtil
              .maybeConvertStringToNumber(rowVector);
            _this.project.trigger('trackChanged', {
              vectors: [rowVector],
              render: existingRowVector != null ? []
                : [morpheus.VectorTrack.RENDER.TEXT],
              columns: false
            });
          }
          if (isColumns) {
            morpheus.VectorUtil
              .maybeConvertStringToNumber(columnVector);
            _this.project.trigger('trackChanged', {
              vectors: [columnVector],
              render: existingColumnVector != null ? []
                : [morpheus.VectorTrack.RENDER.TEXT],
              columns: true
            });
          }
        }
      });

  },
  draw: function () {
    var _this = this;
    var plotlyDefaults = morpheus.ChartTool.getPlotlyDefaults();
    var layout = plotlyDefaults.layout;
    var config = plotlyDefaults.config;
    var chartWidth = 400;
    var chartHeight = 400;


    var project = this.project;
    this.formBuilder.$form.find('[name="draw"]').on('click', function () {
      _this.$chart.empty();

      var dataset = _this.project.getSelectedDataset({
        emptyToAll: false
      });

      console.log("PCAPlot :: dataset:", dataset, "trueIndices:", morpheus.Util.getTrueIndices(dataset));
      var selectedIndices = morpheus.Util.getTrueIndices(dataset);

      var fullDataset = _this.project.getSortedFilteredDataset();
      var fullIndices = morpheus.Util.getTrueIndices(fullDataset);

      _this.dataset = dataset;

      var colorBy = _this.formBuilder.getValue('color');
      var sizeBy = _this.formBuilder.getValue('size');
      var getTrueVector = function (vector) {
        while (vector && vector.indices.length == 0) {
          vector = vector.v;
        }
        return vector;
      };

      _this.colorByVector = getTrueVector(dataset.getColumnMetadata().getByName(colorBy));
      var colorByVector = _this.colorByVector;
      var sizeByVector = getTrueVector(dataset.getColumnMetadata().getByName(sizeBy));

      var pc1 = _this.formBuilder.getValue('x-axis');
      var pc2 = _this.formBuilder.getValue('y-axis');

      var label = _this.formBuilder.getValue('label');
      var textByVector = getTrueVector(dataset.getColumnMetadata().getByName(label));

      var na = _this.formBuilder.getValue('replace_NA_with');
      var color = colorByVector ? [] : '#1f78b4';
      var size = sizeByVector ? [] : 12;
      var text = [];
      var sizeFunction = null;
      var n = selectedIndices.columns.length > 0 ? selectedIndices.columns.length : fullIndices.columns.length;


      var data = [];
      if (sizeByVector) {
        var minMax = morpheus.VectorUtil.getMinMax(sizeByVector);
        sizeFunction = d3.scale.linear().domain(
          [minMax.min, minMax.max]).range([6, 19])
          .clamp(true);
      }
      if (sizeByVector) {
        for (var j = 0; j < sizeByVector.indices.length; j++) {
          var sizeByValue = sizeByVector.getValue(j);
          size.push(sizeFunction(sizeByValue));
        }
      }
      var idVector = getTrueVector(dataset.getColumnMetadata().getByName("id"));
      for (var j = 0; j < idVector.indices.length; j++) {
        text.push(idVector.getValue(j));
      }
      if (textByVector && label !== "id") {
        for (var j = 0; j < textByVector.indices.length; j++) {
          text[j] = text[j] + "<br>" + textByVector.getValue(j);
        }
      }
      var categoriesIndices;
      var categoryNameMap;
      if (colorByVector) {
        var categories = new Map();
        categoriesIndices = new Map();
        categoryNameMap = new Map();
        var catNum = 1;
        for (var j = 0; j < colorByVector.indices.length; j++) {
          var colorByValue = colorByVector.getValue(j);
          if (!categories.get(colorByValue)) {
            categories.set(colorByValue, catNum);
            categoryNameMap.set(catNum, colorByValue);
            catNum += 1;
          }
          if (!categoriesIndices.get(categories.get(colorByValue))) {
            categoriesIndices.set(categories.get(colorByValue), []);
          }
          categoriesIndices.get(categories.get(colorByValue)).push(j);

        }

        for (var cat = 1; cat < catNum; cat++) {
          var curText = [];
          var curSize = sizeByVector ? [] : size;
          var curColor = morpheus.VectorColorModel.CATEGORY_ALL[(cat - 1) % 60];
          for (var i = 0; i < categoriesIndices.get(cat).length; i++) {
            curText.push(text[categoriesIndices.get(cat)[i]]);
            if (sizeByVector) {
              curSize.push(size[categoriesIndices.get(cat)[i]]);
            }
          }
          data.push({
            marker: {
              fillcolor: curColor,
              color: curColor,
              size: curSize
            },
            text: curText,
            type: "scatter",
            mode: "markers",
            name: categoryNameMap.get(cat)
          })
        }
      } else {
        data.push({
          marker: {
            color: color,
            size: size
          },
          name: " ",
          mode: "markers",
          text: text,
          type: "scatter"
        });
      }

      _this.categoriesIndices = categoriesIndices;
      var columnIndices = selectedIndices.columns.length > 0 ? selectedIndices.columns : fullIndices.columns;
      var rowIndices = selectedIndices.rows.length > 0 ? selectedIndices.rows : fullIndices.rows;

      if (columnIndices.length == 1) {
        alert("Choose at least two columns");
        console.log("PcaPlot :: Choose at least two columns");
        return;
      }

      var expressionSetPromise = fullDataset.getESSession();

      //console.log("morpheus.PcaPlotTool.prototype.draw ::", "selected dataset", dataset, ", columnIndices", columnIndices, ", rowIndices", rowIndices);

      //console.log("morpheus.PcaPlotTool.prototype.draw ::", "color", colorBy, ", sizeBy", sizeBy, ", pc1", pc1, ", pc2", pc2, ", label", label);

      expressionSetPromise.then(function (essession) {
        var args = {
          es: essession,
          replacena: na
        };
        if (columnIndices && columnIndices.length > 0) {
          args.columns = columnIndices;
        }
        if (rowIndices && rowIndices.length > 0) {
          args.rows = rowIndices;
        }
        var drawResult = function () {
          var x = _this.pca.pca[pc1];
          var y = _this.pca.pca[pc2];
          //console.log(_this.pca);
          //console.log(_this.colorByVector, _this.categoriesIndices);
          if (_this.colorByVector) {
            for (var cat = 1; cat <= _this.categoriesIndices.size; cat++) {
              var curX = [];
              var curY = [];
              for (var j = 0; j < _this.categoriesIndices.get(cat).length; j++) {
                curX.push(x[_this.categoriesIndices.get(cat)[j]]);
                curY.push(y[_this.categoriesIndices.get(cat)[j]]);
              }
              //console.log(curX, curY);
              //console.log(data[cat]);
              data[cat - 1].x = curX;
              data[cat - 1].y = curY;
            }
          }
          else {
            data[0].x = x;
            data[0].y = y;
          }
          layout.margin = {
            b: 40,
            l: 60,
            t: 25,
            r: 10
          };
          layout.xaxis = {
            title: _this.pca.xlabs[pc1],
            zeroline: false
          };
          layout.yaxis = {
            title: _this.pca.xlabs[pc2],
            zeroline: false
          };
          layout.showlegend = true;
          layout.config = config;
          layout.data = data;
          var $chart = $('<div></div>');
          var myPlot = $chart[0];
          $chart.appendTo(_this.$chart);
          //console.log(data, layout, config);
          Plotly.newPlot(myPlot, data, layout, config);
        };

        //console.log(arguments);

        var req = ocpu.call("pcaPlot", args, function (session) {
          //console.log("morpheus.PcaPlotTool.prototype.draw ::", "successful", session);
          session.getObject(function (success) {
            //console.log(success);
            _this.pca = JSON.parse(success);
            drawResult();
            /*
             var coolUrl = success.split("\n");
             var json = JSON.parse($.parseHTML(coolUrl[1])[0].innerText);
             var data = json.x.data;
             var layout = json.x.layout;
             Plotly.newPlot(myPlot, data, layout, {showLink: false});*/
            //console.log("morpheus.PcaPlotTool.prototype.draw ::", "plot json", json);
          });
          /*var txt = session.txt.split("\n");
           var imageLocationAr = txt[txt.length - 2].split("/"0);
           var imageLocation = session.getLoc() + "files/" + imageLocationAr[imageLocationAr.length - 1];
           console.log(imageLocation);
           var img = $('<img />', {src : imageLocation, style : "width:720px;height:540px"});
           _this.$chart.prepend(img);*/
          /*var img = $('<img />', {src : session.getLoc() + 'graphics/1/png', style : "width:720px;height:540px"});*/

        }, false, "::es");
        req.fail(function () {
          alert(req.responseText);
          console.log("PcaPlot ::", req.responseText);
        });

      });


      expressionSetPromise.catch(function (reason) {
        alert("Problems occured during transforming dataset to ExpressionSet\n" + reason);
        console.log("ExpressionSetCreation ::", "Problems occured during transforming dataset to ExpressionSet\n", reason);
      });

    });
  }

};




morpheus.SaveDatasetTool = function () {
};
morpheus.SaveDatasetTool.prototype = {
  toString: function () {
    return 'Save Dataset';
  },
  init: function (project, form) {
    form.find('file_name').prop('autofocus', true).focus();
    var seriesNames = [];
    var dataset = project.getFullDataset();
    for (var i = 0, nseries = dataset.getSeriesCount(); i < nseries; i++) {
      seriesNames.push(dataset.getName(i)); // TODO check data type
    }
    form.setOptions('series', seriesNames.length > 1 ? seriesNames : null);
    form.setVisible('series', seriesNames.length > 1);
  },
  gui: function () {
    return [
      {
        name: 'file_name',
        type: 'text',
        help: '<a target="_blank" href="http://support.lincscloud.org/hc/en-us/articles/202105453-GCT-Gene-Cluster-Text-Format-">GCT 1.3</a>'
        + ' or <a target="_blank" href="http://www.broadinstitute.org/cancer/software/genepattern/gp_guides/file-formats/sections/gct">GCT 1.2</a> file name',
        required: true
      }, {
        name: 'file_format',
        type: 'radio',
        options: [{
          name: 'GCT version 1.2',
          value: '1.2'
        }, {
          name: 'GCT version 1.3',
          value: '1.3'
        }],
        value: '1.3',
      }, {
        name: 'series',
        type: 'select',
        options: [],
        required: true
      }, {
        name: 'save_selection_only',
        type: 'checkbox',
        required: true
      }];
  },
  execute: function (options) {
    var project = options.project;
    var format = options.input.file_format;
    var fileName = options.input.file_name;
    if (fileName === '') {
      fileName = 'dataset';
    }
    var series = options.input.series;
    var heatMap = options.heatMap;
    var dataset = options.input.save_selection_only ? project.getSelectedDataset() : project.getSortedFilteredDataset();
    var writer;
    if (format === '1.2') {
      writer = new morpheus.GctWriter12();
    } else if (format === '1.3') {
      writer = new morpheus.GctWriter();
    }

    if (series != null) {
      var seriesIndex = morpheus.DatasetUtil.getSeriesIndex(dataset, series);
      if (seriesIndex === -1) {
        seriesIndex = 0;
      }
      dataset = seriesIndex === 0 ? dataset : new morpheus.DatasetSeriesView(dataset, [seriesIndex]);
    }
    var ext = writer.getExtension ? writer.getExtension() : '';
    if (ext !== '' && !morpheus.Util.endsWith(fileName.toLowerCase(), '.' + ext)) {
      fileName += '.' + ext;
    }

    var blobs = [];
    var textArray = [];
    var proxy = {
      push: function (text) {
        textArray.push(text);
        if (textArray.length === 10000) {
          var blob = new Blob([textArray.join('')], {type: 'text/plain;charset=charset=utf-8'});
          textArray = [];
          blobs.push(blob);
        }
      },
      join: function () {
        if (textArray.length > 0) {
          var blob = new Blob([textArray.join('')], {type: 'text/plain;charset=charset=utf-8'});
          blobs.push(blob);
          textArray = [];
        }

        var blob = new Blob(blobs, {type: 'text/plain;charset=charset=utf-8'});
        saveAs(blob, fileName, true);
      }
    };
    writer.write(dataset, proxy);
  }
};

morpheus.SaveImageTool = function () {

};
morpheus.SaveImageTool.prototype = {

  toString: function () {
    return 'Save Image';
  },
  init: function (project, form) {
    form.find('file_name').prop('autofocus', true).focus();
  },
  gui: function () {
    return [{
      name: 'file_name',
      type: 'text',
      required: true
    }, {
      name: 'format',
      type: 'select',
      options: ['png', 'svg'],
      value: 'png',
      required: true
    }];
  },
  execute: function (options) {
    var fileName = options.input.file_name;
    if (fileName === '') {
      fileName = 'image';
    }
    var format = options.input.format;
    if (!morpheus.Util.endsWith(fileName.toLowerCase(), '.' + format)) {
      fileName += '.' + format;
    }
    var heatMap = options.heatMap;
    heatMap.saveImage(fileName, format);
  }
};

morpheus.SaveSessionTool = function () {
};
morpheus.SaveSessionTool.prototype = {
  toString: function () {
    return 'Save Session';
  },
  init: function (project, form) {
    form.find('file_name').prop('autofocus', true).focus();
  },
  gui: function () {
    return [
      {
        name: 'file_name',
        type: 'text',
        required: true
      }];
  },
  execute: function (options) {
    var fileName = options.input.file_name;
    if (fileName === '') {
      fileName = 'session.json';
    }
    if (!morpheus.Util.endsWith(fileName.toLowerCase(), '.json')) {
      fileName += '.json';
    }
    var heatMap = options.heatMap;
    // var options = {dataset: options.input.include_dataset};
    var options = {dataset: true};
    var json = heatMap.toJSON(options);
    var nativeArrayToArray = Array.from || function (typedArray) {
        var normalArray = Array.prototype.slice.call(typedArray);
        normalArray.length === typedArray.length;
        normalArray.constructor === Array;
      };
    var blob = new Blob([JSON.stringify(json, function (key, value) {
      if (morpheus.Util.isArray(value)) {
        return value instanceof Array ? value : nativeArrayToArray(value);
      }
      return value;
    })], {type: 'application/json;charset=charset=utf-8'});
    saveAs(blob, fileName, true);
  }
};

morpheus.SimilarityMatrixTool = function () {
};

morpheus.SimilarityMatrixTool.Functions = [morpheus.Euclidean,
  morpheus.Jaccard, morpheus.Cosine, morpheus.KendallsCorrelation, morpheus.Pearson, morpheus.Spearman];
morpheus.SimilarityMatrixTool.Functions.fromString = function (s) {
  for (var i = 0; i < morpheus.SimilarityMatrixTool.Functions.length; i++) {
    if (morpheus.SimilarityMatrixTool.Functions[i].toString() === s) {
      return morpheus.SimilarityMatrixTool.Functions[i];
    }
  }
  throw new Error(s + ' not found');
};
morpheus.SimilarityMatrixTool.execute = function (dataset, input) {
  var isColumnMatrix = input.compute_matrix_for == 'Columns';
  var f = morpheus.SimilarityMatrixTool.Functions.fromString(input.metric);
  return morpheus.HCluster.computeDistanceMatrix(
    isColumnMatrix ? new morpheus.TransposedDatasetView(dataset)
      : dataset, f);
};
morpheus.SimilarityMatrixTool.prototype = {
  toString: function () {
    return 'Similarity Matrix';
  },
  init: function (project, form) {

  },
  gui: function () {
    return [{
      name: 'metric',
      options: morpheus.SimilarityMatrixTool.Functions,
      value: morpheus.SimilarityMatrixTool.Functions[4].toString(),
      type: 'select'
    }, {
      name: 'compute_matrix_for',
      options: ['Columns', 'Rows'],
      value: 'Columns',
      type: 'radio'
    }];
  },
  execute: function (options) {
    var project = options.project;
    var heatMap = options.heatMap;
    var isColumnMatrix = options.input.compute_matrix_for == 'Columns';
    var f = morpheus.SimilarityMatrixTool.Functions
      .fromString(options.input.metric);
    var dataset = project.getSortedFilteredDataset();
    var blob = new Blob(
      ['self.onmessage = function(e) {'
      + 'importScripts(e.data.scripts);'
      + 'self.postMessage(morpheus.SimilarityMatrixTool.execute(morpheus.Dataset.fromJSON(e.data.dataset), e.data.input));'
      + '}']);

    var url = window.URL.createObjectURL(blob);
    var worker = new Worker(url);

    worker.postMessage({
      scripts: morpheus.Util.getScriptPath(),
      dataset: morpheus.Dataset.toJSON(dataset, {
        columnFields: [],
        rowFields: [],
        seriesIndices: [0]
      }),
      input: options.input
    });

    worker.onmessage = function (e) {
      var name = heatMap.getName();
      var matrix = e.data;
      var n = isColumnMatrix ? dataset.getColumnCount() : dataset
        .getRowCount();
      var d = new morpheus.Dataset({
        name: name,
        rows: n,
        columns: n
      });
      // set the diagonal
      var isDistance = f.toString() === morpheus.Euclidean.toString()
        || f.toString() === morpheus.Jaccard.toString();
      for (var i = 1; i < n; i++) {
        for (var j = 0; j < i; j++) {
          var value = matrix[i][j];
          d.setValue(i, j, value);
          d.setValue(j, i, value);
        }
      }
      // no need to set diagonal if not distance as array already
      // initialized to 0
      if (!isDistance) {
        for (var i = 0; i < n; i++) {
          d.setValue(i, i, 1);
        }
      }
      var metadata = isColumnMatrix ? dataset.getColumnMetadata()
        : dataset.getRowMetadata();
      d.rowMetadataModel = morpheus.MetadataUtil.shallowCopy(metadata);
      d.columnMetadataModel = morpheus.MetadataUtil.shallowCopy(metadata);
      var colorScheme;
      if (!isDistance) {
        colorScheme = {
          type: 'fixed',
          map: [{
            value: -1,
            color: 'blue'
          }, {
            value: 0,
            color: 'white'
          }, {
            value: 1,
            color: 'red'
          }]
        };
      } else {
        colorScheme = {
          type: 'fixed',
          map: [{
            value: 0,
            color: 'white'
          }, {
            value: morpheus.DatasetUtil.max(d),
            color: 'red'
          }]
        };
      }
      new morpheus.HeatMap({
        colorScheme: colorScheme,
        name: name,
        dataset: d,
        parent: heatMap,
        inheritFromParentOptions: {
          rows: !isColumnMatrix,
          columns: isColumnMatrix
        }
      });
      worker.terminate();
      window.URL.revokeObjectURL(url);
    };
    return worker;
  }
};

morpheus.TransposeTool = function () {
};
morpheus.TransposeTool.prototype = {
  toString: function () {
    return 'Transpose';
  },
  execute: function (options) {
    var project = options.project;
    var heatMap = options.heatMap;
    var dataset = new morpheus.TransposedDatasetView(project
      .getSortedFilteredDataset());
    // make a shallow copy of the dataset, metadata is immutable via the UI
    var rowMetadataModel = morpheus.MetadataUtil.shallowCopy(dataset
      .getRowMetadata());
    var columnMetadataModel = morpheus.MetadataUtil.shallowCopy(dataset
      .getColumnMetadata());
    dataset.getRowMetadata = function () {
      return rowMetadataModel;
    };
    dataset.getColumnMetadata = function () {
      return columnMetadataModel;
    };

    // TODO see if we can subset dendrograms
    // only handle contiguous selections for now
    // if (heatMap.columnDendrogram != null) {
    // var indices = project.getColumnSelectionModel().getViewIndices()
    // .toArray();
    // morpheus.DendrogramUtil.leastCommonAncestor();
    // }
    // if (heatMap.rowDendrogram != null) {
    //
    // }
    var name = options.input.name || heatMap.getName();
    new morpheus.HeatMap({
      name: name,
      dataset: dataset,
      inheritFromParentOptions: {
        transpose: true
      },
      parent: heatMap
    });

  }
};

morpheus.TsneTool = function () {
};

morpheus.TsneTool.execute = function (dataset, input) {
  // note: in worker here
  var matrix = [];
  var rows = input.project == 'Rows';
  if (!rows) {
    dataset = new morpheus.TransposedDatasetView(dataset);
  }
  var N = dataset.getRowCount();
  var f = morpheus.HClusterTool.Functions.fromString(input.metric);
  if (f === morpheus.TsneTool.PRECOMPUTED_DIST) {
    for (var i = 0; i < N; i++) {
      matrix.push([]);
      for (var j = i + 1; j < N; j++) {
        matrix[i][j] = dataset.getValue(i, j);
      }
    }
  } else if (f === morpheus.TsneTool.PRECOMPUTED_SIM) {
    var max = morpheus.DatasetUtil.max(dataset);
    for (var i = 0; i < N; i++) {
      matrix.push([]);
      for (var j = i + 1; j < N; j++) {
        matrix[i][j] = max - dataset.getValue(i, j);
      }
    }
  } else {
    var list1 = new morpheus.DatasetRowView(dataset);
    var list2 = new morpheus.DatasetRowView(dataset);
    for (var i = 0; i < N; i++) {
      matrix.push([]);
      list1.setIndex(i);
      for (var j = i + 1; j < N; j++) {
        var d = f(list1, list2.setIndex(j));
        matrix[i][j] = d;
      }
    }
  }
  var opt = {};
  opt.epsilon = input.epsilon;
  opt.perplexity = input.perplexity;
  opt.dim = 2;
  var tsne = new tsnejs.tSNE(opt);
  tsne.initDataDist(matrix);
  for (var k = 0; k < 1000; k++) {
    tsne.step();
  }
  var Y = tsne.getSolution();
  return {solution: Y};

}
;
morpheus.TsneTool.prototype = {
  toString: function () {
    return 't-SNE';
  },
  init: function (project, form) {

  },
  gui: function () {
    return [{
      name: 'metric',
      options: morpheus.HClusterTool.Functions,
      value: morpheus.HClusterTool.Functions[3].toString(),
      type: 'select'
    }, {
      name: 'project',
      options: ['Columns', 'Rows'],
      value: 'Columns',
      type: 'select'
    }, {
      name: 'epsilon',
      value: '10',
      type: 'text',
      help: 'learning rate'
    }, {
      name: 'perplexity',
      value: '30',
      type: 'text',
      help: 'number of effective nearest neighbors'
    }];
  },
  execute: function (options) {
    var project = options.project;
    var heatMap = options.heatMap;
    var rows = options.input.project == 'Rows';
    var dataset = project.getSortedFilteredDataset();
    options.input.epsilon = parseInt(options.input.epsilon);
    options.input.perplexity = parseInt(options.input.perplexity);
    var blob = new Blob(
      ['self.onmessage = function(e) {'
      + 'e.data.scripts.forEach(function (s) { importScripts(s); });'
      + 'self.postMessage(morpheus.TsneTool.execute(morpheus.Dataset.fromJSON(e.data.dataset), e.data.input));'
      + '}']);

    var url = URL.createObjectURL(blob);
    var worker = new Worker(url);

    worker.postMessage({
      scripts: [morpheus.Util.getScriptPath()],
      dataset: morpheus.Dataset.toJSON(dataset, {
        columnFields: [],
        rowFields: [],
        seriesIndices: [0]
      }),
      input: options.input
    });

    worker.onmessage = function (e) {
      if (rows) {
        dataset = new morpheus.TransposedDatasetView(dataset);
      }
      var result = e.data.solution;

      var newDataset = new morpheus.Dataset({
        name: 't-SNE',
        rows: dataset.getColumnCount(),
        columns: 2
      });

      for (var i = 0; i < result.length; i++) {
        newDataset.setValue(i, 0, result[i][0]);
        newDataset.setValue(i, 1, result[i][1]);
      }
      var idVector = newDataset.getColumnMetadata().add('id');
      idVector.setValue(0, 'P1');
      idVector.setValue(1, 'P2');
      newDataset.setRowMetadata(morpheus.MetadataUtil.shallowCopy(dataset.getColumnMetadata()));
      var min = morpheus.DatasetUtil.min(newDataset);
      var max = morpheus.DatasetUtil.max(newDataset);
      new morpheus.HeatMap({
        inheritFromParentOptions: {transpose: !rows},
        name: 't-SNE',
        dataset: newDataset,
        parent: heatMap,
        columns: [{
          field: 'id',
          display: 'text'
        }],
        colorScheme: {
          type: 'fixed',
          map: [{
            value: min,
            color: colorbrewer.Greens[3][0]
          }, {
            value: max,
            color: colorbrewer.Greens[3][2]
          }]
        }
      });
      worker.terminate();
      window.URL.revokeObjectURL(url);
    };
    return worker;
  }
};

morpheus.WordCloudTool = function () {

};

/**
 * @param options
 * @param options.el
 *            Element to append svg to
 * @param options.width
 *            svg width
 * @param options.height
 *            svg height
 * @param options.words
 *            Array of words to draw
 * @param options.fontSizeScale
 *            scale for font size
 * @param options.fill
 *            Scale for font color
 * @param options.minSize
 *            min word size
 * @param options.maxSize
 *            max word size
 */
morpheus.WordCloudTool.draw = function (options) {
  var width = options.width;
  var height = options.height;
  var words = options.words;
  var maxSize = options.maxSize;
  var minSize = options.minSize;

  var fill = options.fill || d3.scale.category20b();

  var fontSizeScale = d3.scale.linear().range([12, 24]).domain(
    [minSize, maxSize]).clamp(true);
  var g = d3.select(options.el).append('svg').attr('width', width).attr(
    'height', height).append('g');
  g.attr('transform', 'translate(' + [width / 2, height / 2] + ')');
  g.style('font-weight', '900');
  var angle = d3.scale.linear().domain([0, 0]).range([0, 0]).clamp(true);
  d3.layout.cloud().spiral('archimedean').size([width, height])
    .words(words).rotate(function () {
    return angle(~~(Math.random() * 5));
  }).fontSize(function (d) {
    return d.size;
  }).on('end', draw).start();
  function draw(words) {
    var text = g.selectAll('text').data(words).enter().append('text')
      .style('font-family', 'Impact').on(
        'mouseover',
        function (d) {
          d3.select(this).transition().style('font-size',
            2 * fontSizeScale(d.size) + 'px');
        }).on(
        'mouseout',
        function (d) {
          d3.select(this).transition().style('font-size',
            fontSizeScale(d.size) + 'px');
        }).on(
        'click',
        function (d) {
          options.heatMap.getToolbar().setSearchText(
            {
              isColumns: options.isColumns,
              text: d.text.indexOf(' ') ? ('"'
              + d.text + '"') : d.text
            });

        }).style('fill', function (d, i) {
        return fill(i);
      }).attr('text-anchor', 'middle').attr(
        'transform',
        function (d) {
          return 'translate(' + [d.x, d.y] + ')rotate('
            + d.rotate + ')';
        }).text(function (d) {
        return d.text;
      }).style('font-size', function (d) {
        return '1px';
      }).transition().duration(1000).style('font-size', function (d) {
        return fontSizeScale(d.size) + 'px';
      });

  }
};
morpheus.WordCloudTool.drawTable = function (options) {
  var width = options.width;
  var maxSize = options.maxSize;
  var minSize = options.minSize;
  var words = options.words;
  words.sort(function (a, b) {
    return (a.size === b.size ? 0 : (a.size < b.size ? 1 : -1));
  });
  var barHeight = 20;
  var height = words.length * barHeight;
  var scale = d3.scale.linear().domain([minSize, maxSize]).range([0, 50]);
  var g = d3.select(options.el).append('svg').attr('width', width).attr(
    'height', height).append('g');
  var sub = g.selectAll('text').data(words).enter().append('g').attr(
    'transform', function (d, i) {
      return 'translate(0,' + (barHeight + i * barHeight) + ')';
    }).on('click', function (d) {
    options.heatMap.getToolbar().setSearchText({
      isColumns: options.isColumns,
      text: d.text.indexOf(' ') ? ('"' + d.text + '"') : d.text
    });
  });

  sub.append('text').text(function (d) {
    return d.text;
  });
  sub.append('rect').style('fill', '#bdbdbd').attr('width', function (d) {
    return scale(d.size) + 'px';
  }).attr('height', function (d) {
    return '18px';
  }).attr('x', function (d) {
    return '300';
  }).attr('y', function (d) {
    return '-' + barHeight / 2 + 'px';
  });
  sub.append('title').text(
    function (d) {
      return d.text + ' p value: ' + morpheus.Util.nf(d.p)
        + ', selected count: ' + d.count
        + ' selected, total count: ' + d.fullCount;
    });

};
morpheus.WordCloudTool.prototype = {
  toString: function () {
    return 'Word Cloud';
  },
  init: function (project, form) {
    form.setOptions('field', morpheus.MetadataUtil.getMetadataNames(project
      .getFullDataset().getRowMetadata()));
    form.$form.find('[name=generate_word_cloud_for]').on(
      'change',
      function (e) {
        var val = $(this).val();
        form.setOptions('field',
          val === 'selected rows' ? morpheus.MetadataUtil
            .getMetadataNames(project.getFullDataset()
              .getRowMetadata())
            : morpheus.MetadataUtil
            .getMetadataNames(project
              .getFullDataset()
              .getColumnMetadata()));
      });

  },
  gui: function () {
    return [{
      name: 'field',
      type: 'select'
    }, {
      name: 'generate_word_cloud_for',
      options: ['selected rows', 'selected columns'],
      value: 'selected rows',
      type: 'radio'
    }];
  },
  execute: function (options) {
    var project = options.project;
    var isColumns = options.input.generate_word_cloud_for == 'selected columns';
    var heatMap = options.heatMap;
    var field = options.input.field;
    var selectedDataset = project.getSortedFilteredDataset();
    var fullDataset = project.getFullDataset();
    if (isColumns) {
      selectedDataset = morpheus.DatasetUtil
        .transposedView(selectedDataset);
      fullDataset = morpheus.DatasetUtil.transposedView(fullDataset);
    }
    var selectedIndices = (isColumns ? project.getColumnSelectionModel()
      : project.getRowSelectionModel()).getViewIndices().values();
    if (selectedIndices.length === 0) {
      throw new Error('No ' + (isColumns ? 'columns' : 'rows')
        + ' selected');
    }
    selectedDataset = new morpheus.SlicedDatasetView(selectedDataset,
      selectedIndices, null);
    var vector = selectedDataset.getRowMetadata().getByName(field);
    var valueToCount = morpheus.VectorUtil.createValueToCountMap(vector);
    var totalSelected = 0;
    valueToCount.forEach(function (count, value) {
      totalSelected += count;
    });
    var fullValueToCount = morpheus.VectorUtil
      .createValueToCountMap(fullDataset.getRowMetadata().getByName(
        field));
    var fullTotal = 0;
    fullValueToCount.forEach(function (count, value) {
      fullTotal += count;
    });
    var colorModel = isColumns ? project.getColumnColorModel() : project
      .getRowColorModel();

    var words = [];
    valueToCount.forEach(function (count, value) {
      var fullCount = fullValueToCount.get(value);
      var p = morpheus.FisherExact.fisherTest(count, totalSelected,
        fullCount, fullTotal);
      words.push({
        count: count,
        fullCount: fullCount,
        p: p,
        text: value,
        size: -morpheus.Log2(p)
      });
    });
    var maxSize = -Number.MAX_VALUE;
    var minSize = Number.MAX_VALUE;
    for (var i = 0, length = words.length; i < length; i++) {
      minSize = Math.min(minSize, words[i].size);
      maxSize = Math.max(maxSize, words[i].size);
    }
    var fill = function (value) {
      return colorModel.getMappedValue(vector, words[value].text);
    };
    var $dialog = $('<div style="background-color:white;" title="Word Cloud"></div>');

    var width = 960;
    var height = 600;
    $dialog.dialog({
      resizable: true,
      height: height + 30,
      width: width + 30
    });
    morpheus.WordCloudTool.draw({
      minSize: minSize,
      maxSize: maxSize,
      isColumns: isColumns,
      heatMap: heatMap,
      el: $dialog[0],
      width: width,
      height: height,
      words: words,
      fill: fill
    });
    morpheus.WordCloudTool.drawTable({
      minSize: minSize,
      maxSize: maxSize,
      isColumns: isColumns,
      heatMap: heatMap,
      el: $dialog[0],
      width: width,
      words: words
    });

  }
};

morpheus.AbstractCanvas = function (offscreen) {
  this.canvas = morpheus.CanvasUtil.createCanvas();
  this.lastClip = null;
  if (offscreen) {
    this.offscreenCanvas = morpheus.CanvasUtil.createCanvas();
  }
  this.offset = {
    x: 0,
    y: 0
  };
};

morpheus.AbstractCanvas.prototype = {
  visible: true,
  invalid: true,
  scrollX: 0,
  scrollY: 0,
  prefWidth: undefined,
  prefHeight: undefined,
  getCanvas: function () {
    return this.canvas;
  },
  scrollTop: function (pos) {
    if (pos === undefined) {
      return this.offset.y;
    }
    this.offset.y = pos;
  },
  appendTo: function ($el) {
    // if (this.offscreenCanvas) {
    // $(this.offscreenCanvas).appendTo($el);
    // }
    $(this.canvas).appendTo($el);
  },
  scrollLeft: function (pos) {
    if (pos === undefined) {
      return this.offset.x;
    }
    this.offset.x = pos;
  },
  dispose: function () {
    $(this.canvas).remove();
    this.offscreenCanvas = undefined;
  },
  getPrefWidth: function () {
    return this.prefWidth;
  },
  /**
   * Tells this canvas to invalidate any offscreen cached images
   */
  setInvalid: function (invalid) {
    this.invalid = invalid;
  },
  setBounds: function (bounds) {
    var backingScale = morpheus.CanvasUtil.BACKING_SCALE;
    var canvases = [this.canvas];
    if (this.offscreenCanvas) {
      canvases.push(this.offscreenCanvas);
    }
    if (bounds.height != null) {
      _.each(canvases, function (canvas) {
        canvas.height = bounds.height * backingScale;
        canvas.style.height = bounds.height + 'px';
      });
    }
    if (bounds.width != null) {
      _.each(canvases, function (canvas) {
        canvas.width = bounds.width * backingScale;
        canvas.style.width = bounds.width + 'px';
      });
    }
    if (bounds.left != null) {
      _.each(canvases, function (canvas) {
        canvas.style.left = bounds.left + 'px';
      });
    }
    if (bounds.top != null) {
      _.each(canvases, function (canvas) {
        canvas.style.top = bounds.top + 'px';
      });
    }
  },
  /**
   * Paint this canvas using the specified clip.
   */
  paint: function (clip) {
    var canvas = this.canvas;
    var context = canvas.getContext('2d');
    morpheus.CanvasUtil.resetTransform(context);
    var width = this.getUnscaledWidth();
    var height = this.getUnscaledHeight();
    context.clearRect(0, 0, width, height);
    if (this.prePaint) {
      morpheus.CanvasUtil.resetTransform(context);
      context.translate(this.offset.x, this.offset.y);
      this.prePaint(clip, context);
    }
    morpheus.CanvasUtil.resetTransform(context);
    if (this.offscreenCanvas) {
      if (this.invalid) {
        var oc = this.offscreenCanvas.getContext('2d');
        morpheus.CanvasUtil.resetTransform(oc);
        context.translate(this.offset.x, this.offset.y);
        oc.clearRect(0, 0, width, height);
        this.draw(clip, oc);
      }
      context.drawImage(this.offscreenCanvas, 0, 0, width, height);
    } else {
      this.draw(clip, context);
    }
    if (this.postPaint) {
      morpheus.CanvasUtil.resetTransform(context);
      context.translate(this.offset.x, this.offset.y);
      this.postPaint(clip, context);
    }
    this.lastClip = clip;
    this.invalid = false;
  },
  repaint: function () {
    if (!this.lastClip) {
      this.lastClip = {
        x: 0,
        y: 0,
        width: this.getUnscaledWidth(),
        height: this.getUnscaledHeight()
      };
    }
    this.paint(this.lastClip);
  },
  /**
   * Draw this canvas into the specified context.
   */
  draw: function (clip, context) {
    console.log('Not implemented');
  },
  getPrefHeight: function () {
    return this.prefHeight;
  },
  setPrefWidth: function (prefWidth) {
    this.prefWidth = prefWidth;
  },
  setPrefHeight: function (prefHeight) {
    this.prefHeight = prefHeight;
  },
  isVisible: function () {
    return this.visible;
  },
  setVisible: function (visible) {
    if (this.visible !== visible) {
      this.visible = visible;
      this.canvas.style.display = visible ? '' : 'none';
    }
  },
  getUnscaledWidth: function () {
    return this.canvas.width / morpheus.CanvasUtil.BACKING_SCALE;
  },
  getUnscaledHeight: function () {
    return this.canvas.height / morpheus.CanvasUtil.BACKING_SCALE;
  },
  getWidth: function () {
    return this.canvas.width;
  },
  getHeight: function () {
    return this.canvas.height;
  }
};

morpheus.AbstractColorSupplier = function () {
  this.fractions = [0, 0.5, 1];
  this.colors = ['#0000ff', '#ffffff', '#ff0000'];
  this.names = null; // optional color stop names
  this.min = 0;
  this.max = 1;
  this.missingColor = '#c0c0c0';
  this.scalingMode = morpheus.HeatMapColorScheme.ScalingMode.RELATIVE;
  this.stepped = false;
  this.sizer = new morpheus.HeatMapSizer();
  this.conditions = new morpheus.HeatMapConditions();
  this.transformValues = 0;// z-score, robust z-score
};
morpheus.AbstractColorSupplier.Z_SCORE = 1;
morpheus.AbstractColorSupplier.ROBUST_Z_SCORE = 2;

morpheus.AbstractColorSupplier.toJSON = function (cs) {
  var json = {
    fractions: cs.fractions,
    colors: cs.colors,
    names: cs.names,
    min: cs.min,
    max: cs.max,
    missingColor: cs.missingColor,
    scalingMode: cs.scalingMode,
    stepped: cs.stepped,
    transformValues: cs.transformValues
  };
  if (cs.conditions) {
    json.conditions = cs.conditions.array;
  }
  if (cs.sizer) {
    json.size = {
      seriesName: cs.sizer.seriesName,
      min: cs.sizer.min,
      max: cs.sizer.max
    };
  }
  return json;
};
morpheus.AbstractColorSupplier.fromJSON = function (json) {
  var cs = json.stepped ? new morpheus.SteppedColorSupplier()
    : new morpheus.GradientColorSupplier();
  cs.setScalingMode(json.scalingMode);
  cs.setMin(json.min);
  cs.setMax(json.max);
  if (json.missingColor != null) {
    cs.setMissingColor(json.missingColor);
  }
  if (morpheus.HeatMapColorScheme.ScalingMode.RELATIVE !== json.scalingMode) {
    cs.setTransformValues(json.transformValues);
  }

  var fractions = json.fractions;
  if (json.values) { // map to fractions
    fractions = [];
    var values = json.values;
    var min = Number.MAX_VALUE;
    var max = -Number.MAX_VALUE;
    for (var i = 0; i < values.length; i++) {
      var value = values[i];
      min = Math.min(min, value);
      max = Math.max(max, value);
    }
    var valueToFraction = d3.scale.linear().domain(
      [min, max]).range(
      [0, 1]).clamp(true);

    for (var i = 0; i < values.length; i++) {
      fractions.push(valueToFraction(values[i]));
    }
  }
  if (json.colors != null && json.colors.length > 0) {
    cs.setFractions({
      colors: json.colors,
      fractions: fractions,
      names: json.names
    });
  }

  if (json.size) {
    cs.getSizer().setSeriesName(json.size.seriesName);
    cs.getSizer().setMin(json.size.min);
    cs.getSizer().setMax(json.size.max);
  }

  if (json.conditions && _.isArray(json.conditions)) {
    // load conditions
    json.conditions.forEach(function (condition) {
      var gtf = function () {
        return true;
      };
      var ltf = function () {
        return true;
      };
      if (condition.v1 != null && !isNaN(condition.v1)) {
        gtf = condition.v1Op === 'gt' ? function (val) {
          return val > condition.v1;
        } : function (val) {
          return val >= condition.v1;
        };
      }

      if (condition.v2 != null && !isNaN(condition.v2)) {
        ltf = condition.v2Op === 'lt' ? function (val) {
          return val < condition.v2;
        } : function (val) {
          return val <= condition.v2;
        };
      }
      condition.accept = function (val) {
        return gtf(val) && ltf(val);
      };
    });
    cs.conditions.array = json.conditions;
  }
  return cs;
};

morpheus.AbstractColorSupplier.prototype = {
  getTransformValues: function () {
    return this.transformValues;
  },
  setTransformValues: function (transformValues) {
    this.transformValues = transformValues;
  },
  getSizer: function () {
    return this.sizer;
  },
  getConditions: function () {
    return this.conditions;
  },
  createInstance: function () {
    throw 'not implemented';
  },
  copy: function () {
    var c = this.createInstance();
    c.stepped = this.stepped;
    c.setFractions({
      fractions: this.fractions.slice(0),
      colors: this.colors.slice(0)
    });
    if (this.names != null) {
      c.names = this.names.slice(0);
    }
    if (this.sizer) {
      c.sizer = this.sizer.copy();
    }
    if (this.conditions) {
      c.conditions = this.conditions.copy();
    }
    c.scalingMode = this.scalingMode;
    c.min = this.min;
    c.max = this.max;
    c.missingColor = this.missingColor;
    if (this.scalingMode !== morpheus.HeatMapColorScheme.ScalingMode.RELATIVE) {
      c.transformValues = this.transformValues;
    }

    return c;
  },
  setMissingColor: function (missingColor) {
    this.missingColor = missingColor;
  },
  getMissingColor: function () {
    return this.missingColor;
  },
  getScalingMode: function () {
    return this.scalingMode;
  },
  setScalingMode: function (scalingMode) {
    if (scalingMode !== this.scalingMode) {
      if (scalingMode === morpheus.HeatMapColorScheme.ScalingMode.RELATIVE) {
        this.min = 0;
        this.max = 1;
      }
      this.scalingMode = scalingMode;
    }
  },
  isStepped: function () {
    return false;
  },
  getColor: function (row, column, value) {
    throw 'not implemented';
  },
  getColors: function () {
    return this.colors;
  },
  getNames: function () {
    return this.names;
  },
  getFractions: function () {
    return this.fractions;
  },
  getMin: function () {
    return this.min;
  },
  getMax: function () {
    return this.max;
  },
  setMin: function (min) {
    this.min = min;
  },
  setMax: function (max) {
    // the min and max are set by heat map color scheme for each row
    this.max = max;
  },
  /**
   *
   * @param options.fractions
   *            Array of stop fractions
   * @param options.colors
   *            Array of stop colors
   * @param options.names
   *            Array of stop names
   */
  setFractions: function (options) {
    var index = morpheus.Util.indexSort(options.fractions, true);
    this.fractions = morpheus.Util.reorderArray(options.fractions, index);
    this.colors = morpheus.Util.reorderArray(options.colors, index);
    this.names = options.names ? morpheus.Util.reorderArray(options.names,
      index) : null;
  }
};

morpheus.AbstractComponent = function () {
  this.lastClip = null;
  var c = document.createElement('div');
  c.setAttribute('tabindex', '0');
  c.style.outline = 0;
  c.style.overflow = 'hidden';
  c.style.position = 'absolute';
  this.el = c;
  this.$el = $(c);
};
morpheus.AbstractComponent.prototype = {
  visible: true,
  invalid: true,
  prefWidth: undefined,
  prefHeight: undefined,
  appendTo: function ($el) {
    $(this.el).appendTo($el);
  },
  dispose: function () {
    $(this.el).remove();
  },
  getPrefWidth: function () {
    return this.prefWidth;
  },
  /**
   * Tells this component to invalidate
   */
  setInvalid: function (invalid) {
    this.invalid = invalid;
  },
  setBounds: function (bounds) {
//		if (bounds.height != null) {
//			this.el.style.height = bounds.height + 'px';
//		}
//		if (bounds.width != null) {
//			this.el.style.width = bounds.width + 'px';
//		}
    if (bounds.left != null) {
      this.$el.css('left', bounds.left + 'px');
    }
    if (bounds.top != null) {
      this.$el.css('top', bounds.top + 'px');
    }
  },
  /**
   * Paint this canvas using the specified clip.
   */
  paint: function (clip) {
    var width = this.getUnscaledWidth();
    var height = this.getUnscaledHeight();
    this.draw(clip);
    this.lastClip = clip;
    this.invalid = false;
  },
  repaint: function () {
    if (!this.lastClip) {
      this.lastClip = {
        x: 0,
        y: 0,
        width: this.getUnscaledWidth(),
        height: this.getUnscaledHeight()
      };
    }
    this.paint(this.lastClip);
  },
  /**
   * Draw this canvas into the specified context.
   */
  draw: function (clip) {
  },
  getPrefHeight: function () {
    return this.prefHeight;
  },
  setPrefWidth: function (prefWidth) {
    this.prefWidth = prefWidth;
  },
  setPrefHeight: function (prefHeight) {
    this.prefHeight = prefHeight;
  },
  isVisible: function () {
    return this.visible;
  },
  setVisible: function (visible) {
    if (this.visible !== visible) {
      this.visible = visible;
      this.el.style.display = visible ? '' : 'none';
    }
  },
  getUnscaledWidth: function () {
    return this.$el.width();
  },
  getUnscaledHeight: function () {
    return this.$el.height();
  },
  getWidth: function () {
    return this.$el.width();
  },
  getHeight: function () {
    return this.$el.height();
  }
};

/*
 * 
 * @param tree An object with maxHeight, rootNode, leafNodes, nLeafNodes. Each node has an id
 * (integer), name (string), children, depth, height, minIndex, maxIndex, parent. Leaf nodes also
 * have an index.
 The root has the largest height, leaves the smallest height.

 */
morpheus.AbstractDendrogram = function (heatMap, tree, positions, project,
                                        type) {
  morpheus.AbstractCanvas.call(this, true);

  this._overviewHighlightColor = '#d8b365';
  this._searchHighlightColor = '#e41a1c';
  this._selectedNodeColor = type === morpheus.AbstractDendrogram.Type.COLUMN ? '#377eb8'
    : '#984ea3';
  this.tree = tree;
  this.type = type;
  this.squishEnabled = false;
  this.heatMap = heatMap;
  this.positions = positions;
  this.project = project;
  var $label = $('<span></span>');
  $label.addClass('label label-info');
  $label.css('position', 'absolute');
  this.$label = $label;
  var $squishedLabel = $('<span></span>');
  $squishedLabel.addClass('label label-default');
  $squishedLabel.css('position', 'absolute').css('top', 18);
  this.$squishedLabel = $squishedLabel;
  this.$label = $label;
  this.cutHeight = this.tree.maxHeight;
  this.drawLeafNodes = true;
  this.lineWidth = 0.7;
  this.selectedNodeIds = {};
  this.selectedRootNodeIdToNode = {};
  this.nodeIdToHighlightedPathsToRoot = {};
  var _this = this;
  this.defaultStroke = 'rgb(0,0,0)';
  this.mouseMoveNodes = null;
  var mouseMove = function (event) {
    if (!morpheus.CanvasUtil.dragging) {
      var position = morpheus.CanvasUtil.getMousePosWithScroll(
        event.target, event, _this.lastClip.x, _this.lastClip.y);
      if (_this.isDragHotSpot(position)) { // dendrogram cutter
        _this.canvas.style.cursor = _this.getResizeCursor();
      } else {
        var nodes;
        if (_this.getNodes) {
          nodes = _this.getNodes(position);
        } else {
          var node = _this.getNode(position);
          if (node) {
            nodes = [node];
          }
        }
        _this.mouseMoveNodes = nodes;
        if (nodes != null) {
          nodes.sort(function (a, b) {
            return a.name < b.name;
          });
          var tipOptions = {
            event: event
          };
          tipOptions[type === morpheus.AbstractDendrogram.Type.COLUMN ? 'columnNodes'
            : 'rowNodes'] = nodes;
          _this.heatMap.setToolTip(-1, -1, tipOptions);
          _this.canvas.style.cursor = 'pointer';
        } else {
          _this.heatMap.setToolTip(-1, -1);
          _this.canvas.style.cursor = 'default';
        }
      }
    }
  };
  var mouseExit = function (e) {
    if (!morpheus.CanvasUtil.dragging) {
      _this.mouseMoveNodes = null;
      _this.canvas.style.cursor = 'default';
    }
  };
  if (type !== morpheus.AbstractDendrogram.Type.RADIAL) {

    $(this.canvas)
      .on(
        'contextmenu',
        function (e) {
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
          var position = morpheus.CanvasUtil
            .getMousePosWithScroll(e.target,
              e, _this.lastClip.x,
              _this.lastClip.y);
          var selectedNode = _this.getNode(position);
          morpheus.Popup
            .showPopup(
              [{
                name: 'Flip',
                disabled: selectedNode == null
              }, {
                name: 'Branch Color',
                disabled: selectedNode == null
              }, {
                separator: true
              },
                {
                  name: 'Annotate...'
                }, {
                name: 'Save'
              }, {
                separator: true
              }, {
                name: 'Enrichment...'
              }, {
                separator: true
              }, {
                name: 'Squish Singleton Clusters',
                checked: _this.squishEnabled
              }, {
                separator: true
              }, {
                name: 'Delete'
              }],
              {
                x: e.pageX,
                y: e.pageY
              },
              e.target,
              function (menuItem, item) {
                if (item === 'Save') {
                  var formBuilder = new morpheus.FormBuilder();
                  formBuilder.append({
                    name: 'file_name',
                    type: 'text',
                    required: true,
                  });
                  morpheus.FormBuilder.showOkCancel({
                    title: 'Save Dendrogram',
                    content: formBuilder.$form,
                    okCallback: function () {
                      var fileName = formBuilder.getValue('file_name');
                      if (fileName === '') {
                        fileName = 'dendrogram.txt';
                      }
                      var out = [];
                      morpheus.DendrogramUtil.writeNewick(tree.rootNode, out);
                      var blob = new Blob([out.join('')], {type: 'text/plain;charset=charset=utf-8'});
                      saveAs(blob, fileName, true);
                    }
                  });
                } else if (item === 'Flip') {
                  if (selectedNode != null) {
                    var isColumns = morpheus.AbstractDendrogram.Type.COLUMN === _this.type;
                    var min = selectedNode.minIndex;
                    var max = selectedNode.maxIndex;

                    // morpheus.DendrogramUtil.dfs(selectedNode, function (n) {
                    //   if (n.children) {
                    //     n.children.reverse();
                    //   }
                    //   return true;
                    // });

                    var leafNodes = tree.leafNodes;
                    for (var i = min, index = max; i <= max; i++, index--) {
                      var n = leafNodes[i];
                      n.index = index;
                      n.maxIndex = index;
                      n.minIndex = index;
                    }

                    leafNodes.sort(function (a, b) {
                      return (a.index < b.index ? -1 : 1);
                    });
                    var setIndex = function (n) {
                      if (n.children != null && n.children.length > 0) {
                        for (var i = 0; i < n.children.length; i++) {
                          setIndex(n.children[i]);
                        }
                        var sum = 0;
                        for (var i = 0; i < n.children.length; i++) {
                          sum += n.children[i].index;
                        }
                        n.index = sum / n.children.length;
                        var maxIndex = -Number.MAX_VALUE;
                        var minIndex = Number.MAX_VALUE;
                        for (var i = 0; i < n.children.length; i++) {
                          maxIndex = Math.max(maxIndex, n.children[i].maxIndex);
                          minIndex = Math.min(minIndex, n.children[i].minIndex);
                        }
                        n.minIndex = minIndex;
                        n.maxIndex = maxIndex;
                      }
                    };

                    setIndex(selectedNode);

                    var currentOrder = [];
                    var count = isColumns ? heatMap.getProject().getSortedFilteredDataset().getColumnCount() : heatMap.getProject().getSortedFilteredDataset().getRowCount();
                    for (var i = 0; i < count; i++) {
                      currentOrder.push(isColumns ? project.convertViewColumnIndexToModel(i) : project.convertViewRowIndexToModel(i));
                    }
                    for (var i = min, j = max; i < j; i++, j--) {
                      var tmp = currentOrder[j];
                      currentOrder[j] = currentOrder[i];
                      currentOrder[i] = tmp;
                    }
                    var key = new morpheus.SpecifiedModelSortOrder(currentOrder, currentOrder.length, 'dendrogram', isColumns);
                    if (isColumns) {
                      heatMap.getProject().setColumnSortKeys([key], true);
                    } else {
                      heatMap.getProject().setRowSortKeys([key], true);
                    }
                    heatMap.revalidate();
                  }

                } else if (item === 'Branch Color') {
                  if (selectedNode != null) {
                    var formBuilder = new morpheus.FormBuilder();
                    formBuilder.append({
                      name: 'color',
                      type: 'color',
                      value: selectedNode.color,
                      required: true,
                      col: 'col-xs-2'
                    });
                    formBuilder.find('color').on(
                      'change',
                      function () {
                        var color = $(this).val();
                        morpheus.DendrogramUtil.dfs(selectedNode, function (n) {
                          n.color = color;
                          return true;
                        });
                        _this.setSelectedNode(null);
                      });
                    morpheus.FormBuilder.showInModal({
                      title: 'Color',
                      close: 'Close',
                      html: formBuilder.$form,
                      focus: document.activeElement
                    });

                  }
                } else if (item === 'Annotate...') {
                  morpheus.HeatMap
                    .showTool(
                      new morpheus.AnnotateDendrogramTool(
                        type === morpheus.AbstractDendrogram.Type.COLUMN),
                      _this.heatMap);
                } else if (item === 'Enrichment...') {
                  morpheus.HeatMap
                    .showTool(
                      new morpheus.DendrogramEnrichmentTool(
                        type === morpheus.AbstractDendrogram.Type.COLUMN),
                      _this.heatMap);
                } else if (item === 'Squish Singleton Clusters') {
                  _this.squishEnabled = !_this.squishEnabled;
                  if (!_this.squishEnabled) {
                    _this.positions
                      .setSquishedIndices(null);
                  }
                } else if (item === 'Delete') {
                  _this.resetCutHeight();
                  _this.heatMap
                    .setDendrogram(
                      null,
                      type === morpheus.AbstractDendrogram.Type.COLUMN);
                }
              });
          return false;
        });

    $(this.canvas).on('mousemove', _.throttle(mouseMove, 100)).on(
      'mouseout', _.throttle(mouseExit, 100)).on('mouseenter',
      _.throttle(mouseMove, 100));
  }
  var dragStartScaledCutHeight = 0;
  this.cutTreeHotSpot = false;
  if (type !== morpheus.AbstractDendrogram.Type.RADIAL) {
    this.hammer = morpheus.Util
      .hammer(this.canvas, ['pan', 'tap'])
      .on(
        'tap',
        this.tap = function (event) {
          if (!morpheus.CanvasUtil.dragging) {
            var position = morpheus.CanvasUtil
              .getMousePosWithScroll(event.target,
                event, _this.lastClip.x,
                _this.lastClip.y);
            _this.cutTreeHotSpot = _this
              .isDragHotSpot(position);
            if (_this.cutTreeHotSpot) {
              return;
            }
            var node = _this.getNode(position);
            if (node != null && node.parent === undefined) {
              node = null; // can't select root
            }
            var commandKey = morpheus.Util.IS_MAC ? event.srcEvent.metaKey
              : event.srcEvent.ctrlKey;
            _this.setSelectedNode(node,
              event.srcEvent.shiftKey || commandKey);
          }
        })
      .on('panend', this.panend = function (event) {
        morpheus.CanvasUtil.dragging = false;
        _this.canvas.style.cursor = 'default';
        _this.cutTreeHotSpot = true;
      })
      .on(
        'panstart',
        this.panstart = function (event) {
          var position = morpheus.CanvasUtil
            .getMousePosWithScroll(event.target, event,
              _this.lastClip.x, _this.lastClip.y,
              true);
          _this.cutTreeHotSpot = _this
            .isDragHotSpot(position);
          if (_this.cutTreeHotSpot) { // make sure start event
            // was on hotspot
            morpheus.CanvasUtil.dragging = true;
            _this.canvas.style.cursor = _this
              .getResizeCursor();
            dragStartScaledCutHeight = _this
              .scale(_this.cutHeight);
          }
        })
      .on(
        'panmove',
        this.panmove = function (event) {
          if (_this.cutTreeHotSpot) {
            var cutHeight;
            if (_this.type === morpheus.AbstractDendrogram.Type.COLUMN) {
              var delta = event.deltaY;
              cutHeight = Math
                .max(
                  0,
                  Math
                    .min(
                      _this.tree.maxHeight,
                      _this.scale
                        .invert(dragStartScaledCutHeight
                          + delta)));
            } else if (_this.type === morpheus.AbstractDendrogram.Type.ROW) {
              var delta = event.deltaX;
              cutHeight = Math
                .max(
                  0,
                  Math
                    .min(
                      _this.tree.maxHeight,
                      _this.scale
                        .invert(dragStartScaledCutHeight
                          + delta)));
            } else {
              var point = morpheus.CanvasUtil
                .getMousePos(event.target, event);
              point.x = _this.radius - point.x;
              point.y = _this.radius - point.y;
              var radius = Math.sqrt(point.x * point.x
                + point.y * point.y);
              if (radius <= 4) {
                cutHeight = _this.tree.maxHeight;
              } else {
                cutHeight = Math.max(0, Math.min(
                  _this.tree.maxHeight,
                  _this.scale.invert(radius)));
              }
            }
            if (cutHeight >= _this.tree.maxHeight) {
              _this.resetCutHeight();
            } else {
              _this.setCutHeight(cutHeight);
            }
            event.preventDefault();
          }
        });
  }
};
morpheus.AbstractDendrogram.Type = {
  COLUMN: 0,
  ROW: 1,
  RADIAL: 2
};
morpheus.AbstractDendrogram.prototype = {
  setSelectedNode: function (node, add) {
    var _this = this;
    var viewIndices;
    var selectionModel = this.type === morpheus.AbstractDendrogram.Type.COLUMN ? this.project
      .getColumnSelectionModel()
      : this.project.getRowSelectionModel();
    if (node == null) {
      // clear selection
      _this.selectedNodeIds = {};
      _this.selectedRootNodeIdToNode = {};
      viewIndices = new morpheus.Set();
    } else {
      if (add) { // add to selection
        viewIndices = selectionModel.getViewIndices();
      } else {
        viewIndices = new morpheus.Set();
        _this.selectedNodeIds = {};
        _this.selectedRootNodeIdToNode = {};
      }
      if (node != null) {
        if (node.children === undefined) { // leaf node
          var contains = _this.nodeIdToHighlightedPathsToRoot[node.id];
          if (!add) {
            _this.nodeIdToHighlightedPathsToRoot = {};
          }
          if (contains) {
            delete _this.nodeIdToHighlightedPathsToRoot[node.id];
            // toggle
          } else {
            _this.nodeIdToHighlightedPathsToRoot[node.id] = node;
          }
        } else {
          _this.selectedRootNodeIdToNode[node.id] = node;
          morpheus.DendrogramUtil.dfs(node, function (d) {
            _this.selectedNodeIds[d.id] = true;
            return true;
          });
        }
        for (var i = node.minIndex; i <= node.maxIndex; i++) {
          viewIndices.add(i);
        }
      }
    }
    _this.trigger('nodeSelectionChanged', _this.selectedRootNodeIdToNode);
    selectionModel.setViewIndices(viewIndices, true);
    _this.repaint();
  },
  getPathStroke: function (node) {
    if (this.selectedNodeIds[node.id]) {
      return this._selectedNodeColor;
    }
    if (node.color !== undefined) {
      return node.color;
    }
    // if (node.search) {
    // return this._searchHighlightColor;
    // }
    return this.defaultStroke;
  },
  /**
   *
   * @param node
   * @return The color, if any, to draw a circle for a node in the dendrogram
   */
  getNodeFill: function (node) {
    if (this.selectedRootNodeIdToNode[node.id]) {
      return this._selectedNodeColor;
    }
    if (node.search) {
      return this._searchHighlightColor;
    }
    if (node.info !== undefined) {
      return this._overviewHighlightColor;
    }

  },
  resetCutHeight: function () {
    this.positions.setSquishedIndices(null);
    if (this.type === morpheus.AbstractDendrogram.Type.COLUMN) {
      this.project.setGroupColumns([], true);
    } else {
      this.project.setGroupRows([], true);
    }
    this.$label.text('');
    this.$squishedLabel.text('');
    var dataset = this.project.getSortedFilteredDataset();
    var clusterIdVector = this.type === morpheus.AbstractDendrogram.Type.COLUMN ? dataset
      .getColumnMetadata().getByName('dendrogram_cut')
      : dataset.getRowMetadata().getByName('dendrogram_cut');
    if (clusterIdVector) {
      for (var i = 0, size = clusterIdVector.size(); i < size; i++) {
        clusterIdVector.setValue(i, NaN);
      }
    }
  },
  setCutHeight: function (height) {
    this.cutHeight = height;
    var squishedIndices = {};
    var clusterNumber = 0;
    var nsquished = 0;

    var squishEnabled = this.squishEnabled;
    var roots = morpheus.DendrogramUtil.cutAtHeight(this.tree.rootNode,
      this.cutHeight);
    var dataset = this.project.getSortedFilteredDataset();
    var clusterIdVector = this.type === morpheus.AbstractDendrogram.Type.COLUMN ? dataset
      .getColumnMetadata().add('dendrogram_cut')
      : dataset.getRowMetadata().add('dendrogram_cut');
    for (var i = 0, nroots = roots.length; i < nroots; i++) {
      var root = roots[i];
      var minChild = morpheus.DendrogramUtil.getDeepestChild(root,
        true);
      var maxChild = morpheus.DendrogramUtil.getDeepestChild(root,
        false);
      var clusterId;
      if (squishEnabled && minChild.index === maxChild.index) {
        squishedIndices[minChild.index] = true;
        clusterId = -2;
        nsquished++;
      } else {
        clusterNumber++;
        clusterId = clusterNumber;
      }
      for (var j = minChild.index; j <= maxChild.index; j++) {
        clusterIdVector.setValue(j, clusterId);
      }

    }
    this.$label.text((clusterNumber) + ' cluster'
      + morpheus.Util.s(clusterNumber));
    if (nsquished > 0) {
      this.$squishedLabel.text(nsquished + ' squished');
    } else {
      this.$squishedLabel.text('');
    }
    if (squishEnabled) {
      this.positions.setSquishedIndices(squishedIndices);
    }
    if (this.heatMap.getTrackIndex(clusterIdVector.getName(),
        this.type === morpheus.AbstractDendrogram.Type.COLUMN) === -1) {
      var settings = {
        discrete: true,
        discreteAutoDetermined: true,
        render: {}
      };
      settings.render[morpheus.VectorTrack.RENDER.COLOR] = true;
      this.heatMap.addTrack(clusterIdVector.getName(),
        this.type === morpheus.AbstractDendrogram.Type.COLUMN,
        settings);
    }

    if (this.type === morpheus.AbstractDendrogram.Type.COLUMN) {
      this.project.setGroupColumns([new morpheus.SortKey(clusterIdVector
        .getName(), morpheus.SortKey.SortOrder.UNSORTED)], true);
    } else {
      this.project.setGroupRows([new morpheus.SortKey(clusterIdVector
        .getName(), morpheus.SortKey.SortOrder.UNSORTED)], true);
    }
  },
  dispose: function () {
    morpheus.AbstractCanvas.prototype.dispose.call(this);
    this.$label.remove();
    this.$squishedLabel.remove();
    this.hammer.off('panend', this.panend).off('panstart',
      this.panstart).off('panmove', this.panmove).off('tap', this.tap);
    this.hammer.destroy();
    this.$label = null;
    this.$squishedLabel = null;
  },
  isCut: function () {
    return this.cutHeight < this.tree.maxHeight;
  },
  getMinIndex: function () {
    return 0;
  },
  getMaxIndex: function () {
    return this.positions.getLength() - 1;
  },
  getNode: function (p) {
    var _this = this;
    if (this.lastNode) {
      var xy = _this.toPix(this.lastNode);
      if (Math.abs(xy[0] - p.x) < 4 && Math.abs(xy[1] - p.y) < 4) {
        return this.lastNode;
      }
    }
    this.lastNode = this._getNode(p);
    return this.lastNode;
  },
  // getNode : function(p) {
  // var x = p.x;
  // var y = p.y;
  // var leafIndex = this.positions.getIndex(x, true);
  // if (leafIndex >= 0 && leafIndex < leafNodeIds.length) {
  // leafid = leafNodeIds[leafIndex];
  // } else {
  // return null;
  // }
  // var n = leafNodes.get(leafid);
  // if (n != null) {
  // while (!n.isRoot()) {
  // var parent = n.getParent();
  // getNodePosition(parent, p);
  // if (Math.abs(p.x - x) < 4 && Math.abs(p.y - y) < 4) {
  // return parent;
  // }
  // n = parent;
  // }
  // }
  // return null;
  // },
  _getNode: function (p) {
    var _this = this;
    // brute force search
    var hit = null;
    try {
      morpheus.DendrogramUtil.dfs(this.tree.rootNode, function (node) {
        var xy = _this.toPix(node);
        if (Math.abs(xy[0] - p.x) < 4 && Math.abs(xy[1] - p.y) < 4) {
          hit = node;
          throw 'break';
        }
        return hit === null;
      });
    }
    catch (x) {
      // break of out dfs
    }
    return hit;
  },
  getResizeCursor: function () {
    if (this.type === morpheus.AbstractDendrogram.Type.COLUMN) {
      return 'ns-resize';
    } else if (this.type === morpheus.AbstractDendrogram.Type.ROW) {
      return 'ew-resize';
    }
    return 'nesw-resize';
  },
  isDragHotSpot: function (p) {
    return false;
  },
  preDraw: function (context, clip) {
  },
  postDraw: function (context, clip) {
  },
  prePaint: function (clip, context) {
    this.scale = this.createScale();
    var min = this.getMinIndex(clip);
    var max = this.getMaxIndex(clip);
    if (min !== this.lastMinIndex || max !== this.lastMinIndex) {
      this.lastMinIndex = min;
      this.lastMaxIndex = max;
    }
    this.invalid = true;
  },
  draw: function (clip, context) {
    context.translate(-clip.x, -clip.y);
    context.strokeStyle = 'black';
    context.fillStyle = 'black';
    this.scale = this.createScale();
    var min = this.lastMinIndex;
    var max = this.lastMaxIndex;
    context.lineWidth = this.lineWidth;
    this.preDraw(context, clip);
    context.strokeStyle = this.defaultStroke;
    context.fillStyle = 'rgba(166,206,227,0.5)';
    this.drawDFS(context, this.tree.rootNode, min, max, 0);
    context.strokeStyle = 'black';
    context.fillStyle = 'black';
    this.postDraw(context, clip);
  },
  /**
   * @abstract
   */
  drawCutSlider: function () {
    throw new Error();
  },
  postPaint: function (clip, context) {
    context.strokeStyle = 'black';
    this.paintMouseOver(clip, context);
    this.drawCutSlider(clip, context);
    // this.drawHighlightedPathsToRoot(context, this.lastMinIndex,
    // this.lastMaxIndex);
  },
  // drawHighlightedPathsToRoot : function(context, minIndex, maxIndex) {
  // context.lineWidth = 1;
  // context.strokeStyle = 'black';
  // context.textAlign = 'left';
  // var i = 0;
  // for ( var key in this.nodeIdToHighlightedPathsToRoot) {
  // context.fillStyle = '#99d594';
  // context.strokeStyle = context.fillStyle;
  // var node = this.nodeIdToHighlightedPathsToRoot[key];
  // if (node.collapsed) {
  // for (var node = node.parent; node.collapsedChildren != null; node =
  // node.parent) {
  // node = node.parent;
  // }
  // }
  // // var pix = this.toPix(node);
  // // context.globalAlpha = 0.5;
  // // context.beginPath();
  // // context.arc(pix[0], pix[1], 8, Math.PI * 2, false);
  // // context.fill();
  // // context.globalAlpha = 1;
  // for (var root = node; root.parent !== undefined; root = root.parent) {
  // this
  // .drawPathFromNodeToParent(context, root, minIndex,
  // maxIndex);
  // }
  // i++;
  // }
  // },
  getNodeRadius: function (node) {
    // if (this._nodeRadiusScaleField != null) {
    // var vals = node.info[this._nodeRadiusScaleField];
    // if (vals === undefined) {
    // return 4;
    // }
    // // TODO get max or min
    // return this._nodeRadiusScale(vals[0]) * 8;
    // }
    return 4;
  },

  drawNode: function (context, node) {
  },
  drawDFS: function (context, node, minIndex, maxIndex) {
    if (this.type !== morpheus.AbstractDendrogram.Type.RADIAL) {
      if ((node.maxIndex < minIndex) || (node.minIndex > maxIndex)) {
        return;
      }
    }
    var nodeFill = this.getNodeFill(node);
    if (nodeFill !== undefined) {
      context.fillStyle = nodeFill;
      this.drawNode(context, node);
    }
    context.strokeStyle = this.getPathStroke(node);
    var children = node.children;
    if (children !== undefined) {
      this.drawNodePath(context, node, minIndex, maxIndex);
      for (var i = 0, nchildren = children.length; i < nchildren; i++) {
        this.drawDFS(context, children[i], minIndex, maxIndex);
      }

    }
  }
};

morpheus.Util.extend(morpheus.AbstractDendrogram, morpheus.AbstractCanvas);
morpheus.Util.extend(morpheus.AbstractDendrogram, morpheus.Events);

/**
 * Action object contains
 * @param options.which Array of key codes
 * @param options.shift Whether shift key is required
 * @param options.commandKey Whether command key is required
 * @param options.name Shortcut name
 * @param options.cb Function callback
 * @param options.accept Additional function to test whether to accept shortcut
 * @param options.icon Optional icon to display
 */
morpheus.ActionManager = function () {
  this.actionNameToAction = new morpheus.Map();
  this.actions = [];
  // TODO copy all row/column metadata
  // pin/unpin tab,
  // header stuff-display, delete.
  this.add({
    name: 'Sort',
    cb: function (options) {
      new morpheus.SortDialog(options.heatMap.getProject());
    },
    icon: 'fa fa-sort-alpha-asc',
  });

  var $filterModal = null;
  this.add({
    name: 'Filter',
    cb: function (options) {
      if ($filterModal == null) {
        var filterModal = [];
        var filterLabelId = _.uniqueId('morpheus');
        filterModal
          .push('<div class="modal" tabindex="1" role="dialog" aria-labelledby="'
            + filterLabelId + '">');
        filterModal.push('<div class="modal-dialog" role="document">');
        filterModal.push('<div class="modal-content">');
        filterModal.push('<div class="modal-header">');
        filterModal
          .push('<button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>');
        filterModal.push('<h4 class="modal-title" id="' + filterLabelId
          + '">Filter</h4>');
        filterModal.push('</div>');
        filterModal.push('<div class="modal-body"></div>');
        filterModal.push('<div class="modal-footer"><button type="button" class="btn btn-default" data-dismiss="modal">Close</button></div>');
        filterModal.push('</div>');
        filterModal.push('</div>');
        filterModal.push('</div>');
        $filterModal = $(filterModal.join(''));
        $filterModal.on('mousewheel', function (e) {
          e.stopPropagation();
        });
        var $filter = $('<div style="padding-bottom:30px;"></div>');
        $filter.appendTo($filterModal.find('.modal-body'));
        var filterHtml = [];
        filterHtml
          .push('<div class="radio"><label><input type="radio" name="rowsOrColumns" value="rows" checked>Rows</label></div> ');
        filterHtml
          .push('<div class="radio"><label><input type="radio" name="rowsOrColumns" value="columns">Columns</label></div>');

        var $filterChooser = $(filterHtml.join(''));
        $filterChooser.appendTo($filter);
        var columnFilterUI = new morpheus.FilterUI(options.heatMap.getProject(), true);
        var rowFilterUI = new morpheus.FilterUI(options.heatMap.getProject(), false);
        // options.heatMap.getProject().getRowFilter().on('focus', function (e) {
        //   $filterChooser.find('[value=rows]').prop('checked', true);
        //   columnFilterUI.$div.hide();
        //   rowFilterUI.$div.show();
        //   $filterModal.modal('show');
        //   morpheus.Util.trackEvent({
        //     eventCategory: '',
        //     eventAction: 'rowFilter'
        //   });
        //
        // });
        // options.heatMap.getProject().getColumnFilter().on('focus', function (e) {
        //   $filterChooser.find('[value=columns]').prop('checked', true);
        //   columnFilterUI.$div.show();
        //   rowFilterUI.$div.hide();
        //   $filterModal.modal('show');
        //   morpheus.Util.trackEvent({
        //     eventCategory: '',
        //     eventAction: 'columnFilter'
        //   });
        // });
        rowFilterUI.$div.appendTo($filter);
        columnFilterUI.$div.appendTo($filter);
        columnFilterUI.$div.css('display', 'none');
        var $filterRadio = $filterChooser.find('[name=rowsOrColumns]');
        $filterRadio.on('change', function (e) {
          var val = $filterRadio.filter(':checked').val();
          if (val === 'columns') {
            columnFilterUI.$div.show();
            rowFilterUI.$div.hide();
          } else {
            columnFilterUI.$div.hide();
            rowFilterUI.$div.show();
          }
          e.preventDefault();
        });
        $filterModal.appendTo(options.heatMap.$content);
        $filterModal.on('hidden.bs.modal', function () {
          options.heatMap.focus();
        });
      }
      $filterModal.modal('show');
    },
    icon: 'fa fa-filter',
  });

  this.add({
    name: 'Options',
    cb: function (options) {
      options.heatMap.showOptions();
    },
    icon: 'fa fa-cog',
  });

  this.add({
    which: [191], // slash
    commandKey: true,
    global: true,
    name: 'Toggle Search',
    cb: function (options) {
      options.heatMap.getToolbar().toggleSearch();
    }
  });

  //
  this.add({
    name: 'Copy Image',
    icon: 'fa fa-clipboard',
    cb: function (options) {
      var bounds = options.heatMap.getTotalSize();
      var height = bounds.height;
      var width = bounds.width;
      var canvas = $('<canvas></canvas>')[0];
      var backingScale = morpheus.CanvasUtil.BACKING_SCALE;
      canvas.height = backingScale * height;
      canvas.style.height = height + 'px';
      canvas.width = backingScale * width;
      canvas.style.width = width + 'px';
      var context = canvas.getContext('2d');
      morpheus.CanvasUtil.resetTransform(context);
      options.heatMap.snapshot(context);
      var url = canvas.toDataURL();
      // canvas.toBlob(function (blob) {
      // 	url = URL.createObjectURL(blob);
      // 	event.clipboardData
      // 	.setData(
      // 		'text/html',
      // 		'<img src="' + url + '">');
      // });

      morpheus.Util.setClipboardData([{
        format: 'text/html',
        data: '<img src="' + url + '">'
      }], true);
    }
  });

  //
  this.add({
    name: 'Close Tab',
    cb: function (options) {
      options.heatMap.getTabManager().remove(options.heatMap.tabId);
    }
  });
  this.add({
    name: 'Rename Tab',
    cb: function (options) {
      options.heatMap.getTabManager().rename(options.heatMap.tabId);
    }
  });

  this.add({
    which: [88], // x
    commandKey: true,
    name: 'New Heat Map',
    accept: function (options) {
      return (!options.isInputField || window.getSelection().toString() === '');
    },

    cb: function (options) {
      morpheus.HeatMap.showTool(new morpheus.NewHeatMapTool(),
        options.heatMap);
    }
  });

  this.add({
    which: [67], // C
    commandKey: true,
    name: 'Copy'
  });

  this.add({
    which: [86], // V
    commandKey: true,
    name: 'Paste Dataset'
  });

  this.add({
    global: true,
    name: 'Open',
    cb: function (options) {
      morpheus.HeatMap.showTool(new morpheus.OpenFileTool({
        customUrls: options.heatMap._customUrls
      }), options.heatMap);
    },
    which: [79],
    commandKey: true,
    icon: 'fa fa-folder-open-o'
  });

  this.add({
    name: 'Save Image',
    gui: function () {
      return new morpheus.SaveImageTool();
    },
    cb: function (options) {
      morpheus.HeatMap.showTool(this.gui(),
        options.heatMap);
    },
    which: [83],
    commandKey: true,
    global: true,
    icon: 'fa fa-file-image-o'
  });

  this.add({
    name: 'Save Dataset',
    gui: function () {
      return new morpheus.SaveDatasetTool();
    },
    cb: function (options) {
      morpheus.HeatMap.showTool(this.gui(),
        options.heatMap);
    },
    shiftKey: true,
    which: [83],
    commandKey: true,
    global: true,
    icon: 'fa fa-floppy-o'
  });

  this.add({
    name: 'Save Session',
    gui: function () {
      return new morpheus.SaveSessionTool();
    },
    cb: function (options) {
      morpheus.HeatMap.showTool(this.gui(), options.heatMap);
    },
    icon: 'fa fa-anchor'
  });

  if (typeof Plotly !== 'undefined') {
    this.add({
      name: 'Chart',
      cb: function (options) {
        new morpheus.ChartTool({
          project: options.heatMap.getProject(),
          getVisibleTrackNames: _.bind(
            options.heatMap.getVisibleTrackNames, options.heatMap)
        });
      },
      icon: 'fa fa-line-chart'
    });
    this.add({
      name: 'PCA Plot',
      cb: function (options) {
        new morpheus.PcaPlotTool({
          project: options.heatMap.getProject()
        });
      },
      icon: 'fa fa-line-chart'
    });
  }

  this.add({
    name: 'Zoom In',
    cb: function (options) {
      options.heatMap.zoom(true);
    },
    which: [107, 61, 187],
    icon: 'fa fa-plus'
  });
  this.add({
    name: 'Zoom Out',
    cb: function (options) {
      options.heatMap.zoom(false);
    },
    which: [173, 189, 109],
    icon: 'fa fa-minus'
  });

  this.add({
    name: 'Fit To Window',
    cb: function (options) {
      options.heatMap.fitToWindow(true);
    },
    icon: 'fa fa-compress'
  });
  this.add({
    name: 'Reset Zoom',
    cb: function (options) {
      options.heatMap.resetZoom();
    },
    button: '100%'
  });

  this.add({
    which: [35],
    name: 'Go To End',
    cb: function (options) {
      options.heatMap.scrollLeft(options.heatMap.heatmap.getPreferredSize().width);
      options.heatMap.scrollTop(options.heatMap.heatmap.getPreferredSize().height);
    }
  });
  this.add({
    which: [36], // home key
    name: 'Go To Start',
    cb: function (options) {
      options.heatMap.scrollLeft(0);
      options.heatMap.scrollTop(0);
    }
  });
  this.add({
    which: [34], // page down
    commandKey: true,
    name: 'Go To Bottom',
    cb: function (options) {
      options.heatMap
        .scrollTop(options.heatMap.heatmap.getPreferredSize().height);
    }
  });
  this.add({
    which: [34], // page down
    commandKey: false,
    name: 'Scroll Page Down',
    cb: function (options) {
      var pos = options.heatMap.scrollTop();
      options.heatMap.scrollTop(pos + options.heatMap.heatmap.getUnscaledHeight()
        - 2);
    }
  });

  this.add({
    which: [33], // page up
    commandKey: true,
    name: 'Go To Top',
    cb: function (options) {
      options.heatMap
        .scrollTop(0);
    }
  });
  this.add({
    which: [33], // page up
    commandKey: false,
    name: 'Scroll Page Up',
    cb: function (options) {
      var pos = options.heatMap.scrollTop();
      options.heatMap.scrollTop(pos - options.heatMap.heatmap.getUnscaledHeight()
        + 2);
    }
  });

  this.add({
    which: [38], // up arrow
    commandKey: true,
    name: 'Zoom Out Rows',
    cb: function (options) {
      options.heatMap.zoom(false, {
        columns: false,
        rows: true
      });
    }
  });
  this.add({
    which: [38], // up arrow
    commandKey: false,
    name: 'Scroll Up',
    cb: function (options) {
      options.heatMap.scrollTop(options.heatMap.scrollTop() - 8);
    }
  });

  this.add({
    which: [40], // down arrow
    commandKey: true,
    name: 'Zoom In Rows',
    cb: function (options) {
      options.heatMap.zoom(true, {
        columns: false,
        rows: true
      });
    }
  });
  this.add({
    which: [40], // down arrow
    commandKey: false,
    name: 'Scroll Down',
    cb: function (options) {
      options.heatMap.scrollTop(options.heatMap.scrollTop() + 8);
    }
  });

  this.add({
    which: [37], // left arrow
    commandKey: true,
    name: 'Zoom Out Columns',
    cb: function (options) {
      options.heatMap.zoom(false, {
        columns: true,
        rows: false
      });
    }
  });
  this.add({
    which: [37], // left arrow
    commandKey: false,
    name: 'Scroll Left',
    cb: function (options) {
      options.heatMap.scrollLeft(options.heatMap.scrollLeft() - 8);
    }
  });

  this.add({
    which: [39], // right arrow
    commandKey: true,
    name: 'Zoom In Columns',
    cb: function (options) {
      options.heatMap.zoom(true, {
        columns: true,
        rows: false
      });
    }
  });
  this.add({
    which: [39], // right arrow
    commandKey: false,
    name: 'Scroll Right',
    cb: function (options) {
      options.heatMap.scrollLeft(options.heatMap.scrollLeft() + 8);
    }
  });
  this.add({
    name: 'Tutorial',
    cb: function () {
      window
        .open('https://clue.io/morpheus/tutorial.html');
    }
  });
  this.add({
    icon: 'fa fa-code',
    name: 'Source Code',
    cb: function () {
      window.open('https://github.com/cmap/morpheus.js');
    }
  });
  var $findModal;
  var $search;

  this.add({
    which: [65],
    shiftKey: true,
    commandKey: true,
    name: 'Find Action',
    cb: function (options) {
      if ($findModal == null) {
        var findModal = [];
        var id = _.uniqueId('morpheus');
        findModal
          .push('<div class="modal" tabindex="1" role="dialog" aria-labelledby="'
            + id + '">');
        findModal.push('<div class="modal-dialog" role="document">');
        findModal.push('<div class="modal-content">');
        findModal.push('<div class="modal-header">');
        findModal
          .push('<button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>');
        findModal.push('<h4 class="modal-title" id="' + id
          + '">Enter action</h4>');
        findModal.push('</div>');
        findModal.push('<div class="modal-body ui-front"><input class="form-control input-sm"></div>');
        findModal.push('</div>');
        findModal.push('</div>');
        findModal.push('</div>');
        $findModal = $(findModal.join(''));
        $findModal.appendTo(options.heatMap.$content);
        var allActions = options.heatMap.getActionManager().getActions();
        $search = $findModal.find('input');
        $search.on('keyup', function (e) {
          if (e.which === 13) {
            var text = $search.val().trim();
            if (text !== '') {
              var action = _this.getAction(text);
              if (action) {
                $findModal.modal('hide');
                _this.execute(text, {event: e});
              }
            }
          }
        });
        morpheus.Util.autosuggest({
          $el: $search,
          multi: false,
          suggestWhenEmpty: false,
          //  history: options.history,
          filter: function (tokens, response) {
            var token = tokens[0].trim();
            var matches = [];
            var replaceRegex = new RegExp('(' + morpheus.Util.escapeRegex(token) + ')', 'i');
            for (var i = 0; i < allActions.length; i++) {
              if (allActions[i].cb) {
                var name = allActions[i].name;
                if (replaceRegex.test(name)) {
                  matches.push({
                    clear: true,
                    value: name,
                    label: '<span style="margin-left: 10px">'
                    + name.replace(replaceRegex, '<b>$1</b>') + '</span>'
                  });
                }
              }
            }
            response(matches);

          },
          select: function () {
            setTimeout(function () {
              var text = $search.val().trim();
              if (text !== '') {
                var action = _this.getAction(text);
                if (action) {
                  $findModal.modal('hide');
                  _this.execute(text);
                }
              }
            }, 20);

          }
        });
        $findModal.on('hidden.bs.modal', function () {
          options.heatMap.focus();
        });
      }
      $findModal.modal('show');
      $search.focus();
    }
  });
  this.add({
    name: 'Keymap Reference',
    cb: function () {
      new morpheus.HeatMapKeyListener({
        $tabPanel: $()
      }).showKeyMapReference();
    }
  });

  this.add({
    name: 'Linking',
    cb: function () {
      window
        .open('https://clue.io/morpheus/linking.html');
    }
  });
  this.add({
    name: 'Contact',
    icon: 'fa fa-envelope-o',
    cb: function (options) {
      morpheus.FormBuilder.showInModal({
        title: 'Contact',
        html: 'Please email us at morpheus@broadinstitute.org',
        focus: options.heatMap.getFocusEl()
      });
    }
  });

  this.add({
    which: [65], // a
    commandKey: true,
    name: 'Select All',
    accept: function (options) {
      var active = options.heatMap.getActiveComponent();
      return (active === 'rowTrack' || active === 'columnTrack');
    },
    cb: function (options) {
      var active = options.heatMap.getActiveComponent();
      var selectionModel = active === 'rowTrack' ? options.heatMap.getProject()
        .getRowSelectionModel() : options.heatMap.getProject()
        .getColumnSelectionModel();
      var count = active === 'rowTrack' ? options.heatMap.getProject()
        .getSortedFilteredDataset().getRowCount() : options.heatMap
        .getProject().getSortedFilteredDataset()
        .getColumnCount();
      var indices = new morpheus.Set();
      for (var i = 0; i < count; i++) {
        indices.add(i);
      }
      selectionModel.setViewIndices(indices, true);
    }
  });

  var invertAction = function (options, isColumns) {
    var model = isColumns ? options.heatMap.getProject().getColumnSelectionModel() : options.heatMap.getProject().getRowSelectionModel();
    var viewIndices = model.getViewIndices();
    var inverse = new morpheus.Set();
    var n = n = isColumns ? options.heatMap.getProject().getSortedFilteredDataset().getColumnCount() : options.heatMap.getProject().getSortedFilteredDataset().getRowCount();
    for (var i = 0; i < n; i++) {
      if (!viewIndices.has(i)) {
        inverse.add(i);
      }
    }
    model.setViewIndices(inverse, true);
  };
  this.add({
    name: 'Invert Selected Rows',
    cb: function (options) {
      invertAction(options, false);
    }
  });
  this.add({
    name: 'Invert Selected Columns',
    cb: function (options) {
      invertAction(options, true);
    }
  });
  var clearAction = function (options, isColumns) {
    var model = isColumns ? options.heatMap.getProject()
      .getColumnSelectionModel() : options.heatMap.getProject()
      .getRowSelectionModel();
    model.setViewIndices(new morpheus.Set(), true);
  };
  this.add({
    name: 'Clear Selected Rows',
    cb: function (options) {
      clearAction(options, false);
    }
  });
  this.add({
    name: 'Clear Selected Columns',
    cb: function (options) {
      clearAction(options, true);
    }
  });

  var moveToTop = function (options, isColumns) {
    var project = options.heatMap.getProject();
    var selectionModel = !isColumns ? project.getRowSelectionModel()
      : project
      .getColumnSelectionModel();
    var viewIndices = selectionModel.getViewIndices().values();
    if (viewIndices.length === 0) {
      return;
    }
    viewIndices.sort(function (a, b) {
      return (a === b ? 0 : (a < b ? -1 : 1));
    });
    var converter = isColumns ? project.convertViewColumnIndexToModel
      : project.convertViewRowIndexToModel;
    converter = _.bind(converter, project);
    var modelIndices = [];
    for (var i = 0, n = viewIndices.length; i < n; i++) {
      modelIndices.push(converter(viewIndices[i]));
    }
    var sortKey = new morpheus.MatchesOnTopSortKey(project, modelIndices, 'selection on' +
      ' top', isColumns);
    if (isColumns) {
      project
        .setColumnSortKeys(
          morpheus.SortKey
            .keepExistingSortKeys(
              [sortKey],
              project
                .getColumnSortKeys()),
          true);
    } else {
      project
        .setRowSortKeys(
          morpheus.SortKey
            .keepExistingSortKeys(
              [sortKey],
              project
                .getRowSortKeys()),
          true);
    }
  };
  this.add({
    name: 'Move Selected Rows To Top',
    cb: function (options) {
      moveToTop(options, false);
    }
  });
  this.add({
    name: 'Move Selected Columns To Top',
    cb: function (options) {
      moveToTop(options, true);
    }
  });
  var selectAll = function (options, isColumns) {
    var project = options.heatMap.getProject();
    var selectionModel = !isColumns ? project.getRowSelectionModel()
      : project
      .getColumnSelectionModel();
    var count = !isColumns ? project
      .getSortedFilteredDataset()
      .getRowCount() : project
      .getSortedFilteredDataset()
      .getColumnCount();
    var indices = new morpheus.Set();
    for (var i = 0; i < count; i++) {
      indices.add(i);
    }
    selectionModel.setViewIndices(indices, true);
  };
  this.add({
    name: 'Select All Rows',
    cb: function (options) {
      selectAll(options, false);
    }
  });
  this.add({
    name: 'Select All Columns',
    cb: function (options) {
      selectAll(options, true);
    }
  });
  var copySelection = function (options, isColumns) {
    var project = options.heatMap.getProject();
    var dataset = project
      .getSortedFilteredDataset();
    var activeTrackName = options.heatMap.getSelectedTrackName(isColumns);
    var v;
    if (activeTrackName == null) {
      v = isColumns ? dataset.getColumnMetadata()
        .get(0) : dataset
        .getRowMetadata().get(0);
    } else {
      v = isColumns ? dataset.getColumnMetadata()
        .getByName(activeTrackName) : dataset
        .getRowMetadata().getByName(activeTrackName);
    }

    var selectionModel = isColumns ? project
      .getColumnSelectionModel() : project
      .getRowSelectionModel();
    var text = [];
    selectionModel.getViewIndices().forEach(
      function (index) {
        text.push(morpheus.Util.toString(v
          .getValue(index)));
      });
    morpheus.Util.setClipboardData([{
      format: 'text/plain',
      data: text.join('\n')
    }]);
  };
  this.add({
    name: 'Copy Selected Rows',
    cb: function (options) {
      copySelection(options, false);
    }
  });
  this.add({
    name: 'Copy Selected Columns',
    cb: function (options) {
      copySelection(options, true);
    }
  });

  var annotateSelection = function (options, isColumns) {

    var project = options.heatMap.getProject();
    var selectionModel = isColumns ? project
      .getColumnSelectionModel()
      : project
      .getRowSelectionModel();
    if (selectionModel.count() === 0) {
      morpheus.FormBuilder
        .showMessageModal({
          title: 'Annotate Selection',
          html: 'No ' + (isColumns ? 'columns' : 'rows') + ' selected.',
          focus: options.heatMap.getFocusEl()
        });
      return;
    }
    var formBuilder = new morpheus.FormBuilder();
    formBuilder.append({
      name: 'annotation_name',
      type: 'text',
      required: true
    });
    formBuilder.append({
      name: 'annotation_value',
      type: 'text',
      required: true
    });
    morpheus.FormBuilder
      .showOkCancel({
        title: 'Annotate',
        content: formBuilder.$form,
        focus: options.heatMap.getFocusEl(),
        okCallback: function () {
          var value = formBuilder
            .getValue('annotation_value');
          var annotationName = formBuilder
            .getValue('annotation_name');
          var dataset = project
            .getSortedFilteredDataset();
          var fullDataset = project
            .getFullDataset();
          if (isColumns) {
            dataset = morpheus.DatasetUtil
              .transposedView(dataset);
            fullDataset = morpheus.DatasetUtil
              .transposedView(fullDataset);
          }

          var existingVector = fullDataset
            .getRowMetadata()
            .getByName(
              annotationName);
          var v = dataset
            .getRowMetadata().add(
              annotationName);

          selectionModel
            .getViewIndices()
            .forEach(
              function (index) {
                v
                  .setValue(
                    index,
                    value);
              });
          morpheus.VectorUtil
            .maybeConvertStringToNumber(v);
          project
            .trigger(
              'trackChanged',
              {
                vectors: [v],
                render: existingVector != null ? []
                  : [morpheus.VectorTrack.RENDER.TEXT],
                columns: isColumns
              });
        }
      });
  };
  this.add({
    name: 'Annotate Selected Rows',
    cb: function (options) {
      annotateSelection(options, false);
    }
  });
  this.add({
    name: 'Annotate Selected Columns',
    cb: function (options) {
      annotateSelection(options, true);
    }
  });
  this.add({
    name: 'Copy Selected Dataset',
    cb: function (options) {
      var project = options.heatMap.getProject();
      var dataset = project.getSelectedDataset({
        emptyToAll: false
      });
      var columnMetadata = dataset
        .getColumnMetadata();
      var rowMetadata = dataset.getRowMetadata();
      // only copy visible tracks
      var visibleColumnFields = options.heatMap
        .getVisibleTrackNames(true);
      var columnFieldIndices = [];
      _.each(visibleColumnFields, function (name) {
        var index = morpheus.MetadataUtil.indexOf(
          columnMetadata, name);
        if (index !== -1) {
          columnFieldIndices.push(index);
        }
      });
      columnMetadata = new morpheus.MetadataModelColumnView(
        columnMetadata, columnFieldIndices);
      var rowMetadata = dataset.getRowMetadata();
      // only copy visible tracks
      var visibleRowFields = options.heatMap
        .getVisibleTrackNames(false);
      var rowFieldIndices = [];
      _.each(visibleRowFields, function (name) {
        var index = morpheus.MetadataUtil.indexOf(
          rowMetadata, name);
        if (index !== -1) {
          rowFieldIndices.push(index);
        }
      });
      rowMetadata = new morpheus.MetadataModelColumnView(
        rowMetadata, rowFieldIndices);

      var text = new morpheus.GctWriter()
        .write(dataset);
      morpheus.Util.setClipboardData([{
        format: 'text/plain',
        data: text
      }]);

    }
  });
  var _this = this;
  console.log(_this);
  [new morpheus.HClusterTool(), new morpheus.MarkerSelection(),
    new morpheus.NearestNeighbors(), new morpheus.AdjustDataTool(),
    new morpheus.CollapseDatasetTool(), new morpheus.CreateAnnotation(), new morpheus.SimilarityMatrixTool(),
    new morpheus.TransposeTool(), new morpheus.TsneTool(), new morpheus.DevAPI(),
    new morpheus.KmeansTool(), new morpheus.LimmaTool()].forEach(function (tool) {
    _this.add({

      name: tool.toString(),
      gui: function () {
        return tool;
      },
      cb: function (options) {
        morpheus.HeatMap.showTool(tool, options.heatMap);
      }
    });
  });

};
morpheus.ActionManager.prototype = {
  getActions: function () {
    return this.actions;
  },
  getAction: function (name) {
    return this.actionNameToAction.get(name);
  },
  execute: function (name, args) {
    var action = this.getAction(name);
    if (args == null) {
      args = {};
    }

    args.heatMap = this.heatMap;
    action.cb(args);
    morpheus.Util.trackEvent({
      eventCategory: '',
      eventAction: name
    });
  },
  add: function (action) {
    this.actions.push(action);
    this.actionNameToAction.set(action.name, action);
  }
};

morpheus.CanvasUtil = function () {
};
morpheus.CanvasUtil.dragging = false;

morpheus.CanvasUtil.FONT_NAME = '"Helvetica Neue",Helvetica,Arial,sans-serif';
morpheus.CanvasUtil.FONT_COLOR = 'rgb(34, 34, 34)';
morpheus.CanvasUtil.getPreferredSize = function (c) {
  var size = c.getPreferredSize();
  var prefWidth = c.getPrefWidth();
  var prefHeight = c.getPrefHeight();
  // check for override override
  if (prefWidth !== undefined) {
    size.width = prefWidth;
  }
  if (prefHeight !== undefined) {
    size.height = prefHeight;
  }
  return size;
};
morpheus.CanvasUtil.BACKING_SCALE = 1;
if (typeof window !== 'undefined' && 'devicePixelRatio' in window) {
  if (window.devicePixelRatio > 1) {
    morpheus.CanvasUtil.BACKING_SCALE = window.devicePixelRatio;
  }
}

morpheus.CanvasUtil.setBounds = function (canvas, bounds) {
  var backingScale = morpheus.CanvasUtil.BACKING_SCALE;

  if (bounds.height != null) {
    canvas.height = bounds.height * backingScale;
    canvas.style.height = bounds.height + 'px';
  }
  if (bounds.width != null) {
    canvas.width = bounds.width * backingScale;
    canvas.style.width = bounds.width + 'px';
  }
  if (bounds.left != null) {
    canvas.style.left = bounds.left + 'px';
  }
  if (bounds.top != null) {
    canvas.style.top = bounds.top + 'px';
  }
};

morpheus.CanvasUtil.drawShape = function (context, shape, x, y, size2) {
  if (size2 < 0) {
    return;
  }
  context.beginPath();
  if (shape === 'minus') {
    context.arc(x, y, size2, 0, 2 * Math.PI, false);
    context.moveTo(x - size2, y);
    context.lineTo(x + size2, y);
  } else if (shape === 'circle') {
    context.arc(x, y, size2, 0, 2 * Math.PI, false);
  } else if (shape === 'square') {
    context.rect(x - size2, y - size2, size2 * 2, size2 * 2);
  } else if (shape === 'plus') {
    // vertical line
    context.moveTo(x, y - size2);
    context.lineTo(x, y + size2);
    // horizontal line
    context.moveTo(x - size2, y);
    context.lineTo(x + size2, y);
  } else if (shape === 'x') {
    context.moveTo(x - size2, y - size2);
    context.lineTo(x + size2, y + size2);
    context.moveTo(x + size2, y - size2);
    context.lineTo(x - size2, y + size2);
  } else if (shape === 'asterisk') {
    // x with vertical line
    context.moveTo(x - size2, y - size2);
    context.lineTo(x + size2, y + size2);
    context.moveTo(x + size2, y - size2);
    context.lineTo(x - size2, y + size2);

    context.moveTo(x, y - size2);
    context.lineTo(x, y + size2);
  } else if (shape === 'diamond') {
    // start at middle top
    context.moveTo(x, y - size2);
    // right
    context.lineTo(x + size2, y);
    // bottom
    context.lineTo(x, y + size2);
    // left
    context.lineTo(x - size2, y);
    // top
    context.lineTo(x, y - size2);
  } else if (shape === 'triangle-up') {
    // top
    context.moveTo(x, y - size2);
    // right
    context.lineTo(x + size2, y + size2);
    // left
    context.lineTo(x - size2, y + size2);
    context.lineTo(x, y - size2);
  } else if (shape === 'triangle-down') {
    // bottom
    context.moveTo(x, y + size2);
    // left
    context.lineTo(x - size2, y - size2);
    // right
    context.lineTo(x + size2, y - size2);
    context.lineTo(x, y + size2);
  } else if (shape === 'triangle-left') {
    // left
    context.moveTo(x - size2, y);
    // top
    context.lineTo(x + size2, y - size2);
    // bottom
    context.lineTo(x + size2, y + size2);
    context.lineTo(x - size2, y);
  } else if (shape === 'triangle-right') {
    // right
    context.moveTo(x + size2, y);
    // lower left
    context.lineTo(x - size2, y + size2);

    // upper left
    context.lineTo(x - size2, y - size2);
    context.lineTo(x + size2, y);
  }
  context.stroke();

};
morpheus.CanvasUtil.drawLine = function (context, x1, y1, x2, y2) {
  context.beginPath();
  context.moveTo(x1, y1);
  context.lineTo(x2, y2);
  context.stroke();
};
morpheus.CanvasUtil.resetTransform = function (context) {
  context.setTransform(1, 0, 0, 1, 0, 0);
  if (morpheus.CanvasUtil.BACKING_SCALE !== 1) {
    context.scale(morpheus.CanvasUtil.BACKING_SCALE,
      morpheus.CanvasUtil.BACKING_SCALE);
  }
};
morpheus.CanvasUtil.bezierCurveTo = function (context, start, end) {
  var m1 = (start[1] + end[1]) / 2;
  context.beginPath();
  context.moveTo(start[0], start[1]);
  // context.lineTo(leftp[0], leftp[1]);
  context.bezierCurveTo(start[0], m1, end[0], m1, end[0], end[1]);
  context.stroke();
};
morpheus.CanvasUtil.createCanvas = function () {
  var $c = $('<canvas></canvas>');
  $c.attr('tabindex', '0');
  $c.css({
    cursor: 'default',
    outline: 0,
    overflow: 'hidden',
    position: 'absolute',
    'z-index': 1
  });
  return $c[0];
};
morpheus.CanvasUtil.getHeaderStringWidth = function (context, s) {
  context.font = '14px ' + morpheus.CanvasUtil.FONT_NAME;
  return context.measureText(s).width + 18;
};
morpheus.CanvasUtil.getVectorStringWidth = function (context, vector, positions,
                                                     end) {
  if (positions.getSize() < 6) {
    return 0;
  }
  var fontSize = Math.min(24, positions.getSize() - 2);
  if (fontSize <= 0) {
    return 0;
  }

  context.font = fontSize + 'px ' + morpheus.CanvasUtil.FONT_NAME;

  var toString = morpheus.VectorTrack.vectorToString(vector);
  var maxWidth = 0;
  // var maxWidth2 = 0;
  var n = end <= 0 ? vector.size() : Math.min(end, vector.size());
  for (var i = 0; i < n; i++) {
    var value = vector.getValue(i);
    if (value != null && value != '') {
      value = toString(value);
    } else {
      continue;
    }
    var width = context.measureText(value).width;
    if (width > maxWidth) {
      maxWidth = width;
    }
    // if (width > maxWidth2 && width < maxWidth) {
    // maxWidth2 = width;
    // }
  }
  return maxWidth > 0 ? (maxWidth + 2) : maxWidth;
};
morpheus.CanvasUtil.clipString = function (context, string, availTextWidth) {
  var textWidth = context.measureText(string).width;
  if (textWidth <= availTextWidth) {
    return string;
  }
  var clipString = '...';
  availTextWidth -= context.measureText(clipString).width;
  if (availTextWidth <= 0) {
    // can not fit any characters
    return clipString;
  }
  var width = 0;
  for (var nChars = 0, stringLength = string.length; nChars < stringLength; nChars++) {
    width += context.measureText(string[nChars]).width;
    if (width > availTextWidth) {
      string = string.substring(0, nChars);
      break;
    }
  }
  return string + clipString;
};
morpheus.CanvasUtil.toSVG = function (drawable, file) {
  var totalSize = {
    width: drawable.getWidth(),
    height: drawable.getHeight()
  };
  var context = new C2S(totalSize.width, totalSize.height);
  context.save();
  drawable.draw({
    x: 0,
    y: 0,
    width: totalSize.width,
    height: totalSize.height
  }, context);
  context.restore();
  var svg = context.getSerializedSvg();
  var blob = new Blob([svg], {
    type: 'text/plain;charset=utf-8'
  });
  saveAs(blob, file);
};
morpheus.CanvasUtil.getMousePos = function (element, event, useDelta) {
  return morpheus.CanvasUtil.getMousePosWithScroll(element, event, 0, 0,
    useDelta);
};

morpheus.CanvasUtil.getClientXY = function (event, useDelta) {
  var clientX;
  var clientY;
  if (event.pointers) {
    if (event.pointers.length > 0) {
      clientX = event.pointers[0].clientX - (useDelta ? event.deltaX : 0);
      clientY = event.pointers[0].clientY - (useDelta ? event.deltaY : 0);
    } else {
      clientX = event.srcEvent.clientX - (useDelta ? event.deltaX : 0);
      clientY = event.srcEvent.clientY - (useDelta ? event.deltaY : 0);
    }
  } else {
    clientX = event.clientX;
    clientY = event.clientY;
  }
  return {
    x: clientX,
    y: clientY
  };
};
morpheus.CanvasUtil.getMousePosWithScroll = function (element, event, scrollX,
                                                      scrollY, useDelta) {
  return morpheus.CanvasUtil._getMousePosWithScroll(element, scrollX,
    scrollY, morpheus.CanvasUtil.getClientXY(event, useDelta));
};

morpheus.CanvasUtil._getMousePosWithScroll = function (element, scrollX,
                                                       scrollY, clientXY) {
  var rect = element.getBoundingClientRect();
  return {
    x: clientXY.x - rect.left + scrollX,
    y: clientXY.y - rect.top + scrollY
  };
};

/**
 * @param {morpheus.Set} [] -
 *            options.set set of selected items
 * @see morpheus.Table
 */
morpheus.CheckBoxList = function (options) {
  var _this = this;
  var set = options.set || new morpheus.Set();
  options = $.extend(true, {}, {
    height: '150px',
    showHeader: false,
    select: false,
    search: true,
    checkBoxSelectionOnTop: false,
    rowHeader: function (item) {
      var header = [];
      // header
      // .push('<div style="overflow: hidden;text-overflow: ellipsis;"
      // class="morpheus-hover">');
      header.push('<span><input name="toggle" type="checkbox" '
        + (set.has(_this.getter(item)) ? ' checked' : '') + '/> ');
      header.push('</span>');
      // header
      // .push('<button
      // style="background-color:inherit;position:absolute;top:0;right:0;line-height:inherit;padding:0px;margin-top:4px;"
      // class="btn btn-link morpheus-hover-show">only</button>');
      // header.push('</div>');
      return header.join('');
      // return '<span><input name="toggle"
      // type="checkbox" '
      // + (set.has(_this.getter(item)) ? ' checked' : '')
      // + '/> </span>'
    }
  }, options);
  options = morpheus.Table.createOptions(options);
  if (options.columns.length === 1) {
    options.maxWidth = 583;
  }
  var idColumn = options.columns[0];
  for (var i = 0; i < options.columns.length; i++) {
    if (options.columns[i].idColumn) {
      idColumn = options.columns[i];
      break;
    }
  }

  this.getter = idColumn.getter;
  var html = [];

  var table = new morpheus.Table(options);
  if (options.columns.length === 1) {
    options.$el.find('.slick-table-header').find('[name=right]').remove();
  }
  this.table = table;
  var html = [];

  html.push('<div style="display:inline;">');
  html.push('<div style="display:inline;" class="dropdown">');
  html.push('<button class="btn btn-default btn-xs dropdown-toggle" type="button"' +
    ' data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">');
  html.push('<i data-name="checkbox" class="fa fa-square-o"' +
    ' aria-hidden="true"></i>');
  html.push(' <span class="fa fa-caret-down"></span>');
  html.push('</button>');
  html.push('<ul style="font-size:12px;" class="dropdown-menu">');
  html.push('<li><a name="selectAll" href="#">Select All</a></li>');
  html.push('<li><a name="selectNone" href="#">Select None</a></li>');
  html.push('<li><a name="invertSel" href="#">Invert Selection</a></li>');

  html.push('</ul>');
  html.push('</div>');
  html.push('<span data-name="available" style="font-size:12px;padding-left:6px;"></span>');
  html.push('</div>');
  var $checkBoxEl = $(html.join(''));
  table.$header.find('[name=left]').html($checkBoxEl);
  var $selection = $checkBoxEl.find('[data-name=available]');
  var $selectAll = $checkBoxEl.find('[name=selectAll]');
  var $selectNone = $checkBoxEl.find('[name=selectNone]');
  var $cb = $checkBoxEl.find('[data-name=checkbox]');

  $cb.on('click', function (e) {
    if ($cb.hasClass('fa-square-o')) {
      var items = table.getItems(); // select all
      for (var i = 0; i < items.length; i++) {
        set.add(_this.getter(items[i]));
      }
    } else { // select none
      var items = table.getItems();
      for (var i = 0; i < items.length; i++) {
        set.remove(_this.getter(items[i]));
      }
    }
    table.trigger('checkBoxSelectionChanged', {
      source: _this,
      set: set
    });
    e.preventDefault();
    e.stopPropagation();

  });
  $selectAll.on('click', function (e) {
    var items = table.getItems();
    for (var i = 0, nitems = items.length; i < nitems; i++) {
      set.add(_this.getter(items[i]));
    }
    _this.table.trigger('checkBoxSelectionChanged', {
      source: _this,
      set: set
    });
    e.preventDefault();
    _this.table.redraw();
  });
  $checkBoxEl.find('[name=invertSel]').on('click', function (e) {
    // selected become unselected, unselected become selected
    var items = table.getItems();
    for (var i = 0, nitems = items.length; i < nitems; i++) {
      var val = _this.getter(items[i]);
      if (set.has(val)) {
        set.remove(val);
      } else {
        set.add(val);
      }

    }
    _this.table.trigger('checkBoxSelectionChanged', {
      source: _this,
      set: set
    });
    e.preventDefault();
    _this.table.redraw();
  });
  $selectNone.on('click', function (e) {
    var items = table.getItems();
    for (var i = 0, nitems = items.length; i < nitems; i++) {
      set.remove(_this.getter(items[i]));
    }
    _this.table.trigger('checkBoxSelectionChanged', {
      source: _this,
      set: set
    });

    e.preventDefault();
    _this.table.redraw();
  });

  this.set = set;
  this.table = table;
  $selection.html(morpheus.Util.intFormat(set.size()) + '/' + morpheus.Util.intFormat(table.getAllItemCount()));

  var priorCount = 0;
  this.table.on('checkBoxSelectionChanged', function () {
    if (set.size() === 0) {
      $cb.attr('class', 'fa fa-square-o');
    } else {
      var items = table.getItems();
      var count = 0;
      var found = false;
      var notFound = false;
      for (var i = 0; i < items.length; i++) {
        if (set.has(_this.getter(items[i]))) {
          count++;
          found = true;
          if (notFound) {
            break;
          }
        } else {
          notFound = true;
          if (found) {
            break;
          }
        }
      }
      if (count === 0) {
        $cb.attr('class', 'fa fa-square-o');
      } else if (count === items.length) {
        $cb.attr('class', 'fa fa-check-square-o');
      } else {
        $cb.attr('class', 'fa fa-minus-square-o');
      }
    }

    $selection.html(morpheus.Util.intFormat(set.size()) + '/' + morpheus.Util.intFormat(table.getAllItemCount()));

    _this.table.redraw();
  });

  table.on('click',
    function (e) {
      var $target = $(e.target);
      var item = table.getItems()[e.row];
      var value = _this.getter(item);
      if ($target.is('.morpheus-hover-show')) { // only
        set.clear();
        set.add(value);
        _this.table.trigger('checkBoxSelectionChanged', {
          source: _this,
          set: set
        });
      } else if (!options.select
        || ($target.is('[type=checkbox]') && $target
          .attr('name') === 'toggle')) {
        if (set.has(value)) {
          set.remove(value);
        } else {
          set.add(value);
        }
        _this.table.trigger('checkBoxSelectionChanged', {
          source: _this,
          set: set
        });
      }

    });

};
morpheus.CheckBoxList.prototype = {
  searchWithPredicates: function (predicates) {
    this.table.searchWithPredicates(predicates);
  },
  autocomplete: function (tokens, cb) {
    this.table.autocomplete(tokens, cb);
  },
  setHeight: function (height) {
    this.table.setHeight(height);
  },
  resize: function () {
    this.table.resize();
  },
  setSearchVisible: function (visible) {
    this.table.setSearchVisible(visible);
  },
  getSelectedRows: function () {
    return this.table.getSelectedRows();
  },
  getSelectedItems: function () {
    return this.table.getSelectedItems();
  },
  setSelectedRows: function (rows) {
    this.table.setSelectedRows(rows);
  },
  getItems: function (items) {
    return this.table.getItems();
  },
  getAllItemCount: function () {
    return this.table.getAllItemCount();
  },
  getFilteredItemCount: function () {
    return this.table.getFilteredItemCount();
  },
  setFilter: function (f) {
    this.table.setFilter(f);
  },

  redraw: function () {
    this.table.redraw();
  },
  getSelection: function () {
    return this.set;
  },
  clearSelection: function (values) {
    this.set.clear();
    this.table.redraw();
  },
  setValue: function (values) {
    this.setSelectedValues(values);
  },
  setSelectedValues: function (values) {
    this.set.clear();

    if (morpheus.Util.isArray(values)) {
      for (var i = 0; i < values.length; i++) {
        this.set.add(values[i]);
      }
    } else {
      this.set.add(values);
    }
    this.table.redraw();
  },
  val: function () {
    return this.set.values();
  },
  on: function (evtStr, handler) {
    this.table.on(evtStr, handler);
    return this;
  },
  off: function (evtStr, handler) {
    this.table.off(evtStr, handler);
  },
  setItems: function (items) {
    // remove items in selection that are not in new items
    var newItems = new morpheus.Set();
    var getter = this.getter;
    for (var i = 0; i < items.length; i++) {
      newItems.add(getter(items[i]));

    }
    var selection = this.set;
    selection.forEach(function (val) {
      if (!newItems.has(val)) {
        selection.remove(val);
      }
    });

    this.table.setItems(items);
    this.table.trigger('checkBoxSelectionChanged', {
      source: this,
      set: selection
    });
  }
};

morpheus.ColumnDendrogram = function (heatMap, tree, positions, project) {
  morpheus.AbstractDendrogram.call(this, heatMap, tree, positions,
    project, morpheus.AbstractDendrogram.Type.COLUMN);
};
morpheus.ColumnDendrogram.prototype = {
  drawNode: function (context, node) {
    var radius = this.getNodeRadius(node);
    var pix = this.toPix(node);
    context.beginPath();
    context.arc(pix[0], pix[1], 4, Math.PI * 2, false);
    context.fill();
  },
  isDragHotSpot: function (p) {
    return Math.abs(this.scale(this.cutHeight) - p.y) <= 2;
  },
  drawCutSlider: function (clip, context) {
    if (context.setLineDash) {
      context.setLineDash([5]);
    }
    context.strokeStyle = 'black';
    var ny = this.scale(this.cutHeight);
    context.beginPath();
    context.moveTo(clip.x, ny);
    context.lineTo(this.getUnscaledWidth(), ny);
    context.stroke();
    if (context.setLineDash) {
      context.setLineDash([]);
    }
  },
  createScale: function () {
    // root has the largest height, leaves the smallest height
    return d3.scale.linear().domain([this.tree.maxHeight, 0]).range(
      [0, this.getUnscaledHeight()]);
  },
  paintMouseOver: function (clip, context) {
    if (this.project.getHoverColumnIndex() !== -1) {
      morpheus.CanvasUtil.resetTransform(context);
      context.translate(-clip.x, 0);
      this.drawColumnBorder(context, this.positions, this.project
        .getHoverColumnIndex(), this.getUnscaledWidth());
    }
  },
  drawColumnBorder: function (context, positions, index, gridSize) {
    var size = positions.getItemSize(index);
    var pix = positions.getPosition(index);
    // top and bottom lines
    context.beginPath();
    context.moveTo(pix + size, 0);
    context.lineTo(pix + size, gridSize);
    context.stroke();
    context.beginPath();
    context.moveTo(pix, 0);
    context.lineTo(pix, gridSize);
    context.stroke();
  },
  getMaxIndex: function (clip) {
    return morpheus.Positions.getRight(clip, this.positions);
  },
  getMinIndex: function (clip) {
    return morpheus.Positions.getLeft(clip, this.positions);
  },
  getPreferredSize: function (context) {
    return {
      width: Math.ceil(this.positions.getPosition(this.positions
            .getLength() - 1)
        + this.positions
          .getItemSize(this.positions.getLength() - 1)),
      height: 100
    };
  },
  toPix: function (node) {
    var min = this.positions.getPosition(node.minIndex)
      + this.positions.getItemSize(node.minIndex) / 2;
    var max = this.positions.getPosition(node.maxIndex)
      + this.positions.getItemSize(node.maxIndex) / 2;
    return [(min + max) / 2, this.scale(node.height)];
  },
  drawPathFromNodeToParent: function (context, node) {
    var pix = this.toPix(node);
    var parentPix = this.toPix(node.parent);
    context.beginPath();
    context.moveTo(pix[0], pix[1]);
    context.lineTo(pix[0], parentPix[1]);
    context.lineTo(parentPix[0], parentPix[1]);
    context.stroke();
  },
  drawNodePath: function (context, node, minIndex, maxIndex) {
    var children = node.children;
    var left = children[0];
    var right = children[1];
    // set up points for poly line
    var ny = this.scale(node.height);
    var rx = this.toPix(right)[0];
    var ry = this.scale(right.height);
    var lx = this.toPix(left)[0];
    var ly = this.scale(left.height);
    var x, y;
    if (!this.drawLeafNodes) {
      var leftIsLeaf = left.children !== undefined;
      var rightIsLeaf = right.children !== undefined;
      if (leftIsLeaf) {
        ly = ny + 4;
      }
      if (rightIsLeaf) {
        ry = ny + 4;
      }
      x = [rx, rx, lx, lx];
      y = [ry, ny, ny, ly];
    } else {
      x = [rx, rx, lx, lx];
      y = [ry, ny, ny, ly];
    }
    context.beginPath();
    context.moveTo(x[0], y[0]);
    for (var i = 1, length = x.length; i < length; i++) {
      context.lineTo(x[i], y[i]);
    }
    context.stroke();
  }
};
morpheus.Util.extend(morpheus.ColumnDendrogram, morpheus.AbstractDendrogram);

morpheus.ConditionalRenderingUI = function (heatmap) {
  var _this = this;
  this.heatmap = heatmap;
  var $div = $('<div class="container-fluid" style="min-width:180px;"></div>');
  $div.on('click', '[data-name=add]', function (e) {
    var $this = $(this);
    var $row = $this.closest('.morpheus-entry');
    // add after
    var index = $row.index();
    var condition = {
      series: null,
      color: 'rgb(0,0,0)',
      shape: null,
      inheritColor: true,
      accept: function (val) {
        return false;
      }

    };

    heatmap.heatmap.getColorScheme().getConditions().insert(index,
      condition);

    $row.after(_this.add(condition));
    e.preventDefault();
  });
  $div.on('click', '[data-name=delete]', function (e) {
    var $this = $(this);
    var $row = $this.closest('.morpheus-entry');
    var index = $row.index() - 1;
    heatmap.heatmap.getColorScheme().getConditions().remove(index);
    heatmap.revalidate();
    $row.remove();
    e.preventDefault();
  });
  var html = [];
  html
    .push('<div class="morpheus-entry">');
  html.push('<div class="row">');
  html
    .push('<div style="padding-bottom:20px;" class="col-xs-8"><a class="btn btn-default btn-xs"' +
      ' role="button"' +
      ' data-name="add" href="#">Add Condition</a></div>');

  html.push('</div>');
  html.push('</div>');

  $div.append(html.join(''));
  this.$div = $div;
  heatmap.heatmap.getColorScheme().getConditions().getConditions().forEach(
    function (c) {
      _this.add(c).appendTo($div);
    });

};

morpheus.ConditionalRenderingUI.prototype = {
  add: function (condition) {
    var _this = this;
    // shape: shapes and line
    // color: if no color cell is drawn using this shape, otherwise draw
    // shape on top of cell
    // series name
    // value >= x and <= x
    var html = [];
    html.push('<div style="border-top:1px solid LightGrey;padding-bottom:6px;padding-top:6px;"' +
      ' class="morpheus-entry">');
    html.push('<form class="form-horizontal">');
    // series
    html.push('<div class="form-group">');
    html
      .push('<label class="col-xs-2">Series</label>');
    html.push('<div class="col-xs-6">');
    html
      .push('<select class="form-control morpheus-form-control-inline" name="cond_series">');
    html.push(morpheus.Util.createOptions(morpheus.DatasetUtil
      .getSeriesNames(this.heatmap.getProject().getFullDataset())));
    html.push('</select>');
    html.push('</div>');
    html.push('</div>');

    // condition
    html.push('<div class="form-group">');
    html.push('<label class="col-xs-2">Condition</label>');
    html.push('<div class="col-xs-6">');
    html
      .push('<select class="form-control morpheus-form-control-inline" name="lower"><option value="gte">&gt;=</option><option value="gt">&gt;</option></select>');
    html
      .push('<input class="form-control morpheus-form-control-inline" name="v1" size="5" type="text">');
    html.push('<span style="margin-right:1em;">and</span>');
    html
      .push('<select class="form-control morpheus-form-control-inline" name="upper"><option value="lte">&lt;=</option><option value="lt">&lt;</option></select>');
    html
      .push('<input class="form-control morpheus-form-control-inline" name="v2" size="5" type="text">');
    html.push('</div>');
    html.push('</div>');

    // shape
    html.push('<div class="form-group">');
    html.push('<label class="col-xs-2">Shape</label>');
    var shapeField = new morpheus.ShapeField(['circle', 'square',
      'diamond', 'triangle-up', 'triangle-down', 'triangle-left',
      'triangle-right']);
    html.push('<div class="col-xs-4">');
    html.push('<div style="display:inline;" data-name="shapeHolder"></div>');
    html.push('</div>');
    html.push('</div>');

    // color
    html.push('<div class="form-group">');
    html.push('<label class="col-xs-offset-2 col-xs-4"><input name="inherit_color"' +
      ' type="checkbox" checked> Inherit' +
      ' color</label>');
    html.push('</div>');

    html.push('<div class="form-group">');
    html.push('<label class="col-xs-2">Color</label>');
    html.push('<div class="col-xs-4">');
    html
      .push('<input class="form-control" type="color" name="color" style="display:inline;' +
        ' width:6em;" disabled>');
    html.push('</div>');
    html.push('</div>');

    html.push('<div class="row"><div class="col-xs-11">');
    html
      .push('<a class="btn btn-default btn-xs" role="button" data-name="delete"' +
        ' href="#">Delete Condition</a>');
    html.push('</div></div>');
    html.push('</div>'); // morpheus-entry
    var $el = $(html.join(''));
    shapeField.$el.appendTo($el.find('[data-name=shapeHolder]'));
    var $color = $el.find('[name=color]');
    var $series = $el.find('[name=cond_series]');
    var $v1 = $el.find('[name=v1]');
    var $v2 = $el.find('[name=v2]');
    var $v1Op = $el.find('[name=lower]');
    var $v2Op = $el.find('[name=upper]');
    var $inherit_color = $el.find('[name=inherit_color]');
    $color.prop('disabled', condition.inheritColor);
    $color.val(condition.color);
    $series.val(condition.series);
    shapeField.setShapeValue(condition.shape);
    if (condition.v1 != null && !isNaN(condition.v1)) {
      $v1.val(condition.v1);
    }
    if (condition.v2 != null && !isNaN(condition.v2)) {
      $v2.val(condition.v2);
    }
    $v1Op.val(condition.v1Op);
    $v2Op.val(condition.v2Op);
    function updateAccept() {
      var v1 = parseFloat($($v1).val());
      var v2 = parseFloat($($v2).val());
      var v1Op = $v1Op.val();
      var v2Op = $v2Op.val();
      condition.v1 = v1;
      condition.v2 = v2;
      condition.v1Op = v1Op;
      condition.v2Op = v2Op;
      var gtf = function () {
        return true;
      };
      var ltf = function () {
        return true;
      };
      if (!isNaN(v1)) {
        gtf = v1Op === 'gt' ? function (val) {
          return val > v1;
        } : function (val) {
          return val >= v1;
        };
      }

      if (!isNaN(v2)) {
        ltf = v2Op === 'lt' ? function (val) {
          return val < v2;
        } : function (val) {
          return val <= v2;
        };
      }
      condition.accept = function (val) {
        return gtf(val) && ltf(val);
      };
      _this.heatmap.revalidate();
    }

    $v1Op.on('change', function (e) {
      updateAccept();

    });
    $v2Op.on('change', function (e) {
      updateAccept();
    });
    $v1.on('keyup', _.debounce(function (e) {
      updateAccept();
    }, 100));
    $v2.on('keyup', _.debounce(function (e) {
      updateAccept();
    }, 100));
    $inherit_color.on('click', function (e) {
      condition.inheritColor = $(this).prop('checked');
      $color.prop('disabled', condition.inheritColor);
      _this.heatmap.revalidate();
    });
    $color.on('change', function (e) {
      condition.color = $(this).val();
      _this.heatmap.revalidate();
    });
    shapeField.on('change', function (e) {
      condition.shape = e.shape;
      _this.heatmap.revalidate();
    });
    $series.on('change', function (e) {
      condition.series = $(this).val();
      _this.heatmap.revalidate();
    });
    condition.series = $series.val();
    return $el;

  }
};

morpheus.DendrogramUtil = {};
morpheus.DendrogramUtil.setIndices = function (root, counter) {
  counter = counter || 0;
  var setIndex = function (node) {
    var children = node.children;
    var maxIndex = children[0].maxIndex;
    var minIndex = children[0].minIndex;
    var sum = children[0].index;
    for (var i = 1, length = children.length; i < length; i++) {
      var child = children[i];
      sum += child.index;
      minIndex = Math.min(minIndex, child.minIndex);
      maxIndex = Math.max(maxIndex, child.maxIndex);
    }
    node.minIndex = minIndex;
    node.maxIndex = maxIndex;
    node.index = sum / children.length;
    node.children.sort(function (a, b) {
      return (a.index === b.index ? 0 : (a.index < b.index ? -1 : 1));
    });
  };

  var visit = function (node, callback) {
    var children = node.children;
    var n;
    if (children && (n = children.length)) {
      var i = -1;
      while (++i < n) {
        visit(children[i], callback);
      }
    }
    callback(node);
  };
  visit(root, function (n) {
    if (n.children === undefined) {
      n.minIndex = counter;
      n.maxIndex = counter;
      n.index = counter;
      counter++;
    } else {
      setIndex(n);
    }
    return true;
  });
};
morpheus.DendrogramUtil.convertEdgeLengthsToHeights = function (rootNode) {
  var maxHeight = 0;

  function setHeights(node, height) {
    var newHeight = height;
    if (node.length !== undefined) {
      newHeight += node.length;
    }
    node.height = newHeight;
    maxHeight = Math.max(maxHeight, node.height);
    if (node.children != null) {
      node.children.forEach(function (child) {
        setHeights(child, newHeight);
      });
    }
  }

  setHeights(rootNode, 0);
  var counter = 0;
  morpheus.DendrogramUtil.dfs(rootNode, function (node) {
    node.id = counter;
    counter++;
    node.height = maxHeight - node.height;
    return true;
  });
  return {
    maxHeight: maxHeight,
    n: counter
  };
};
morpheus.DendrogramUtil.writeNewick = function (node, out) {
  if (node.children != null && node.children.length > 0) {
    // indent
    out.push('(');
    for (var i = 0; i < node.children.length; i++) {
      if (i > 0) {
        out.push(',');
      }
      morpheus.DendrogramUtil.writeNewick(node.children[i], out);
    }
    out.push(')');
  }
  out.push(node.index != null ? node.index : ''); // leaf nodes have index
  out.push(':');
  var parentHeight = node.parent ? node.parent.height : node.height;
  out.push(parentHeight - node.height);

};
morpheus.DendrogramUtil.parseNewick = function (text) {
  var rootNode = Newick.parse(text);
  var counter = 0;
  var leafNodes = [];

  function visit(node) {
    var children = node.children;
    if (children !== undefined) {
      var left = children[0];
      var right = children[1];
      left.parent = node;
      right.parent = node;
      visit(left);
      visit(right);
    } else { // leaf node
      node.minIndex = counter;
      node.maxIndex = counter;
      node.index = counter;
      leafNodes.push(node);
      counter++;
    }
  }

  visit(rootNode);
  var maxHeight = morpheus.DendrogramUtil
    .convertEdgeLengthsToHeights(rootNode).maxHeight;
  morpheus.DendrogramUtil.setNodeDepths(rootNode);
  morpheus.DendrogramUtil.setIndices(rootNode);
  return {
    maxHeight: rootNode.height,
    rootNode: rootNode,
    leafNodes: leafNodes,
    nLeafNodes: leafNodes.length
  };
};
morpheus.DendrogramUtil.cutAtHeight = function (rootNode, h) {
  var roots = [];
  morpheus.DendrogramUtil.dfs(rootNode, function (node) {
    if (node.height < h) {
      roots.push(node);
      return false;
    }
    return true;
  });
  roots.sort(function (a, b) {
    return (a.index < b.index ? -1 : (a.index == b.index ? 0 : 1));
  });
  return roots;
};
morpheus.DendrogramUtil.getDeepestChild = function (node, isMin) {
  while (true) {
    if (node.children === undefined) {
      return node;
    }
    var index;
    if (isMin) {
      index = node.children[0].index < node.children[node.children.length - 1].index ? 0
        : node.children.length - 1;
    } else {
      index = node.children[0].index > node.children[node.children.length - 1].index ? 0
        : node.children.length - 1;
    }

    node = node.children[index];
  }
};
/**
 * Pre-order depth first traversal 1. Visit the root. 2. Traverse the left
 * subtree. 3. Traverse the right subtree.
 */
morpheus.DendrogramUtil.dfs = function (node, callback, childrenAccessor) {
  if (childrenAccessor === undefined) {
    childrenAccessor = function (n) {
      return n.children;
    };
  }
  if (callback(node)) {
    var children = childrenAccessor(node);
    var n;
    if (children && (n = children.length)) {
      var i = -1;
      while (++i < n) {
        morpheus.DendrogramUtil.dfs(children[i], callback,
          childrenAccessor);
      }
    }
  }
};
morpheus.DendrogramUtil.copyTree = function (tree) {
  var counter = 0;

  function recurse(node) {
    var children = node.children;
    if (children !== undefined) {
      var newChildren = [];
      for (var i = 0, n = children.length; i < n; i++) {
        var copy = $.extend({}, children[i]);
        copy.parent = node;
        newChildren.push(copy);
      }
      node.children = newChildren;
      for (var i = 0, n = newChildren.length; i < n; i++) {
        recurse(newChildren[i]);
      }
    } else {
      node.index = counter;
      node.minIndex = counter;
      node.maxIndex = counter;
      counter++;
    }
  }

  var rootNode = $.extend({}, tree.rootNode);
  rootNode.parent = undefined;
  recurse(rootNode);
  return {
    nLeafNodes: tree.nLeafNodes,
    maxDepth: tree.maxDepth,
    rootNode: rootNode
  };
};
morpheus.DendrogramUtil.collapseAtDepth = function (rootNode, maxDepth) {
  // restore collapsed children
  morpheus.DendrogramUtil.dfs(rootNode, function (d) {
    if (d.collapsedChildren) {
      d.children = d.collapsedChildren;
      d.collapsedChildren = undefined;
    }
    return true;
  });
  // collapse nodes below specified depth
  morpheus.DendrogramUtil.dfs(rootNode, function (d) {
    var depth = d.depth;
    if (depth > maxDepth) {
      d.collapsedChildren = d.children;
      d.children = undefined;
      return false;
    }
    return true;
  });
};
morpheus.DendrogramUtil.setNodeDepths = function (rootNode) {
  var max = 0;

  function recurse(node, depth) {
    var children = node.children;
    node.depth = depth;
    max = Math.max(depth, max);
    if (children !== undefined) {
      var i = -1;
      var j = depth + 1;
      var n = children.length;
      while (++i < n) {
        var d = recurse(children[i], j);
      }
    }
    return node;
  }

  recurse(rootNode, 0);
  return max;
};
morpheus.DendrogramUtil.sortDendrogram = function (root, vectorToSortBy,
                                                   project, summaryFunction) {
  summaryFunction = summaryFunction || function (array) {
      var min = Number.MAX_VALUE;
      for (var i = 0; i < array.length; i++) {
        // sum += array[i].weight;
        min = Math.min(min, array[i].weight);
      }
      return min;
    };
  var setWeights = function (node) {
    if (node.children !== undefined) {
      var children = node.children;
      for (var i = 0; i < children.length; i++) {
        setWeights(children[i]);
      }
      node.weight = summaryFunction(children);
    } else {
      node.weight = vectorToSortBy.getValue(node.index);
    }
  };
  setWeights(root);
  // sort children by weight
  var nodeIdToModelIndex = {};
  var leafNodes = morpheus.DendrogramUtil.getLeafNodes(root);
  _.each(leafNodes, function (node) {
    nodeIdToModelIndex[node.id] = project
      .convertViewColumnIndexToModel(node.index);
  });
  morpheus.DendrogramUtil.dfs(root, function (node) {
    if (node.children) {
      node.children.sort(function (a, b) {
        return (a.weight === b.weight ? 0 : (a.weight < b.weight ? -1
          : 1));
      });
    }
    return true;
  });
  morpheus.DendrogramUtil.setIndices(root);
  var sortOrder = [];
  _.each(leafNodes, function (node) {
    var oldModelIndex = nodeIdToModelIndex[node.id];
    var newIndex = node.index;
    sortOrder[newIndex] = oldModelIndex;
  });
  return sortOrder;
};
morpheus.DendrogramUtil.leastCommonAncestor = function (leafNodes) {
  function getPathToRoot(node) {
    var path = new morpheus.Map();
    while (node != null) {
      path.set(node.id, node);
      node = node.parent;
    }
    return path;
  }

  var path = getPathToRoot(leafNodes[0]);
  for (var i = 1; i < leafNodes.length; i++) {
    var path2 = getPathToRoot(leafNodes[i]);
    path.forEach(function (node, id) {
      if (!path2.has(id)) {
        path.remove(id);
      }
    });
    // keep only those in path that are also in path2
  }
  var max = -Number.MAX_VALUE;
  var maxNode;
  path.forEach(function (n, id) {
    if (n.depth > max) {
      max = n.depth;
      maxNode = n;
    }
  });
  return maxNode;
};
// morpheus.DendrogramUtil.computePositions = function(rootNode, positions)
// {
// if (rootNode == null) {
// return;
// }
// morpheus.DendrogramUtil._computePositions(rootNode, positions);
// };
// /**
// * position is (left+right)/2
// */
// morpheus.DendrogramUtil._computePositions = function(node, positions) {
// if (node.children !== undefined) {
// var children = node.children;
// var left = children[0];
// var right = children[1];
// morpheus.DendrogramUtil._computePositions(left, positions);
// morpheus.DendrogramUtil._computePositions(right, positions);
// morpheus.DendrogramUtil.setIndex(node);
// node.position = (left.position + right.position) / 2;
// } else {
// node.position = positions.getItemSize(node.index) / 2
// + positions.getPosition(node.index);
// }
// };

/**
 *
 * @param options.rootNode Dendrogram root node
 * @param options.text Search text
 * @param options.defaultMatchMode
 *            'exact' or 'contains'
 * @param options.matchAllPredicates Whether to match all predicates
 */
morpheus.DendrogramUtil.search = function (options) {
  var searchText = options.text;
  var rootNode = options.rootNode;
  var tokens = morpheus.Util.getAutocompleteTokens(searchText);
  var predicates;
  var nmatches = 0;
  var matchAllPredicates = options.matchAllPredicates === true;

  if (tokens == null || tokens.length == 0) {
    morpheus.DendrogramUtil.dfs(rootNode, function (node) {
      node.search = false;
      return true;
    });
    nmatches = -1;
  } else {
    predicates = morpheus.Util.createSearchPredicates({
      tokens: tokens,
      defaultMatchMode: options.defaultMatchMode
    });
    var npredicates = predicates.length;
    morpheus.DendrogramUtil
      .dfs(
        rootNode,
        function (node) {
          var matches = false;
          if (node.info) {
            searchLabel:
              if (!matchAllPredicates) { // at least one predicate matches
                for (var p = 0; p < npredicates; p++) {
                  var predicate = predicates[p];
                  var filterColumnName = predicate.getField();
                  if (filterColumnName != null) {
                    var vals = node.info[filterColumnName];
                    for (var i = 0, nvals = vals.length; i < nvals; i++) {
                      if (predicate.accept(vals[i])) {
                        matches = true;
                        break searchLabel;
                      }
                    }
                  } else {
                    for (var name in node.info) {
                      var vals = node.info[name];
                      for (var i = 0, nvals = vals.length; i < nvals; i++) {
                        if (predicate.accept(vals[i])) {
                          matches = true;
                          break searchLabel;
                        }
                      }
                    }

                  }
                }
              } else { // all predicates must match
                matches = true;
                for (var p = 0; p < npredicates; p++) {
                  var predicate = predicates[p];
                  var filterColumnName = predicate.getField();
                  if (filterColumnName != null) {
                    var vals = node.info[filterColumnName];
                    for (var i = 0, nvals = vals.length; i < nvals; i++) {
                      if (!predicate.accept(vals[i])) {
                        matches = false;
                        break searchLabel;
                      }
                    }
                  } else {
                    for (var name in node.info) {
                      var vals = node.info[name];
                      for (var i = 0, nvals = vals.length; i < nvals; i++) {
                        if (!predicate.accept(vals[i])) {
                          matches = false;
                          break searchLabel;
                        }
                      }
                    }

                  }
                }
              }
          }
          node.search = matches;
          if (matches) {
            nmatches++;
          }
          return true;
        }
      );

  }
  return nmatches;
}
;
morpheus.DendrogramUtil.squishNonSearchedNodes = function (heatMap,
                                                           isColumns) {
  if (isColumns) {
    heatMap.getHeatMapElementComponent().getColumnPositions().setSize(13);
  } else {
    heatMap.getHeatMapElementComponent().getRowPositions().setSize(13);
  }
  var expandedLeafNodes = {};
  var dendrogram = isColumns ? heatMap.columnDendrogram
    : heatMap.rowDendrogram;
  morpheus.DendrogramUtil.dfs(dendrogram.tree.rootNode, function (node) {
    for (var i = node.minIndex; i <= node.maxIndex; i++) {
      if (node.search) {
        expandedLeafNodes[i] = true;
      }
    }
    return true;
  });
  var clusterIds = [];
  var previous = expandedLeafNodes[0];
  var squishedIndices = {};
  if (!previous) {
    squishedIndices[0] = true;
  }
  var clusterNumber = 0;
  clusterIds.push(clusterNumber);
  for (var i = 1, nleaves = dendrogram.tree.leafNodes.length; i < nleaves; i++) {
    var expanded = expandedLeafNodes[i];
    if (expanded !== previous) {
      clusterNumber++;
      previous = expanded;
    }
    if (!expanded) {
      squishedIndices[i] = true;
    }
    clusterIds.push(clusterNumber);
  }
  if (isColumns) {
    heatMap.getHeatMapElementComponent().getColumnPositions()
      .setSquishedIndices(squishedIndices);
    heatMap.getProject().setGroupColumns(
      [new morpheus.SpecifiedGroupByKey(clusterIds)], false);
  } else {
    heatMap.getHeatMapElementComponent().getRowPositions()
      .setSquishedIndices(squishedIndices);
    heatMap.getProject().setGroupRows(
      [new morpheus.SpecifiedGroupByKey(clusterIds)], false);
  }
};
morpheus.DendrogramUtil.getLeafNodes = function (rootNode) {
  var leafNodes = [];
  morpheus.DendrogramUtil.dfs(rootNode, function (node) {
    if (node.children === undefined) {
      leafNodes.push(node);
    }
    return true;
  });
  return leafNodes;
};

morpheus.DiscreteColorSchemeChooser = function (options) {
  var formBuilder = new morpheus.FormBuilder();
  var map = options.colorScheme.scale;
  var html = ['<select name="colorPicker" class="selectpicker" data-live-search="true">'];
  map.forEach(function (val, key) {
    html.push('<option');
    html.push(' value="');
    html.push(key);
    html.push('">');
    html.push(key);
    html.push('</option>');
  });
  html.push('</select>');
  formBuilder.append({
    name: 'selected_value',
    type: 'custom',
    value: html.join('')
  });
  var $select = formBuilder.$form.find('[name=colorPicker]');
  formBuilder.append({
    col: 'col-xs-2',
    name: 'selected_color',
    type: 'color'
  });
  var selectedVal = $select.val();
  var _this = this;
  var $color = formBuilder.$form.find('[name=selected_color]');
  $color.val(map.get(selectedVal));
  $color.on('change', function (e) {
    var color = $(this).val();
    map.set(selectedVal, color);
    _this.trigger('change', {
      value: selectedVal,
      color: color
    });
  });
  $select.selectpicker().change(function () {
    // var optionIndex = sel.prop("selectedIndex");
    selectedVal = $select.val();
    var c = map.get(selectedVal);
    $color.val(c);
  });
  this.$div = formBuilder.$form;
};
morpheus.DiscreteColorSchemeChooser.prototype = {
  dispose: function () {
  }
};
morpheus.Util.extend(morpheus.DiscreteColorSchemeChooser, morpheus.Events);

morpheus.DiscreteColorSupplier = function () {
  this.colorMap = new morpheus.Map();
  this.hiddenValue = 0;
  this.hiddenValues = new morpheus.Set();
  morpheus.AbstractColorSupplier.call(this);
  this.scalingMode = morpheus.HeatMapColorScheme.ScalingMode.FIXED;
};

morpheus.DiscreteColorSupplier.prototype = {
  createInstance: function () {
    return new morpheus.DiscreteColorSupplier();
  },
  /**
   * @param.array Array of name, value, color pairs
   */
  setColorMap: function (array) {
    this.colorMap = new morpheus.Map();
    this.colors = [];
    this.fractions = [];
    this.names = [];
    this.min = Number.MAX_VALUE;
    this.max = -Number.MAX_VALUE;
    for (var i = 0; i < array.length; i++) {
      this.colorMap.set(array[i].value, array[i].color);
      this.fractions.push(array[i].value);
      this.names.push(array[i].name);
      this.colors.push(array[i].color);
      this.min = Math.min(this.min, array[i].value);
      this.max = Math.max(this.max, array[i].value);
    }
  },
  copy: function () {
    var c = this.createInstance();
    c.names = this.names.slice(0);
    c.colorMap = new morpheus.Map();
    this.colorMap.forEach(function (color, value) {
      c.colorMap.set(value, color);
    });
    c.colors = this.colors.slice(0);
    c.fractions = this.fractions.slice(0);
    this.hiddenValues.forEach(function (val) {
      c.hiddenValues.add(val);
    });

    c.missingColor = this.missingColor;
    return c;
  },

  isStepped: function () {
    return true;
  },
  getColor: function (row, column, value) {
    if (this.hiddenValues.has(value)) {
      value = this.hiddenValue;
    }

    if (isNaN(value)) {
      return this.missingColor;
    }
    return this.colorMap.get(value);
  }
};
morpheus.Util.extend(morpheus.DiscreteColorSupplier,
  morpheus.AbstractColorSupplier);

morpheus.Divider = function (vertical) {
  morpheus.AbstractCanvas.call(this, false);
  this.vertical = vertical;
  var that = this;
  var canvas = this.canvas;
  canvas.style.cursor = vertical ? 'ew-resize' : 'ns-resize';

  if (vertical) {
    this.setBounds({
      height: 15,
      width: 4
    });

  } else {
    this.setBounds({
      height: 4,
      width: 15
    });
  }
  this.hammer = morpheus.Util.hammer(canvas, ['pan']).on('panstart',
    this.panstart = function (event) {
      that.trigger('resizeStart');
      morpheus.CanvasUtil.dragging = true;
    }).on('panmove', this.panmove = function (event) {
    if (that.vertical) {
      that.trigger('resize', {
        delta: event.deltaX
      });
    } else {
      that.trigger('resize', {
        delta: event.deltaY
      });
    }
  }).on('panend', this.panend = function (event) {
    morpheus.CanvasUtil.dragging = false;
    that.trigger('resizeEnd');
  });
  this.paint();

};
morpheus.Divider.prototype = {
  dispose: function () {
    morpheus.AbstractCanvas.prototype.dispose.call(this);
    this.hammer.off('panstart', this.panstart).off('panmove', this.panmove).off('panend', this.panend);
    this.hammer.destroy();
  },
  getPreferredSize: function () {
    return {
      width: 3,
      height: this.getUnscaledHeight()
    };
  },
  draw: function (clip, context) {
    var width = this.getUnscaledWidth();
    var height = this.getUnscaledHeight();
    context.clearRect(0, 0, width, height);
    context.strokeStyle = 'black';
    if (!this.vertical) {// horizontal line at top
      context.beginPath();
      context.moveTo(0, 1.5);
      context.lineTo(width, 1.5);
      context.stroke();
    } else { // vertical line at left
      context.beginPath();
      context.moveTo(0, 0);
      context.lineTo(0, height);
      context.stroke();
    }
  }
};
morpheus.Util.extend(morpheus.Divider, morpheus.AbstractCanvas);
morpheus.Util.extend(morpheus.Divider, morpheus.Events);

morpheus.DualList = function (leftOptions, rightOptions) {
  var html = [];
  html.push('<div class="container-fluid">');
  html.push('<div class="row">');
  html.push('<div class="col-xs-4"><label>Available Fields</label></div>');
  html.push('<div class="col-xs-2"></div>');
  html.push('<div class="col-xs-4"><label>Selected Fields</label></div>');
  html.push('</div>'); // row
  html.push('<div class="row">');
  html
    .push('<div class="col-xs-4"><select class="form-control" name="left" multiple></select></div>');
  html
    .push('<div class="col-xs-2"><div class="btn-group-vertical" role="group">'
      + '<button name="add" type="button" class="btn btn-xs btn-default">Add</button>'
      + '<button name="remove" type="button" class="btn btn-xs btn-default">Remove</button>'
      + '<button name="up" type="button" class="btn btn-xs btn-default">Move Up</button>'
      + '<button name="down" type="button" class="btn btn-xs btn-default">Move Down</button>'
      + '</div></div>');
  html
    .push('<div class="col-xs-4"><select class="form-control" name="right" multiple></select></div>');
  html.push('</div>'); // row
  html.push('</div>');
  this.$el = $(html.join(''));
  var _this = this;
  this.$el.find('[name=add]').on('click', function () {
    _this.addSelected();
  });
  this.$el.find('[name=remove]').on('click', function () {
    _this.removeSelected();
  });
  this.$el.find('[name=up]').on('click', function () {
    _this.moveUp();
  });
  this.$el.find('[name=down]').on('click', function () {
    _this.moveDown();
  });
  this.left = this.$el.find('[name=left]')[0];
  this.right = this.$el.find('[name=right]')[0];
  for (var i = 0; i < leftOptions.length; i++) {
    this.left.options[i] = leftOptions[i];
  }
  for (var i = 0; i < rightOptions.length; i++) {
    this.right.options[i] = rightOptions[i];
  }
};

morpheus.DualList.prototype = {
  addSelected: function () {
    var left = this.left;
    var right = this.right;
    for (var i = 0; i < left.options.length; i++) {
      if (left.options[i].selected) {
        var opt = left.options[i];
        right.options[right.options.length] = new Option(opt.innerHTML,
          opt.value);
        left.options[i] = null;
        i--;
      }
    }
  },
  addAll: function () {
    var left = this.left;
    var right = this.right;
    for (var i = 0; i < left.options.length; i++) {
      var opt = left.options[i];
      right.options[right.options.length] = new Option(opt.innerHTML,
        opt.value);
    }
    left.options.length = 0;
  },
  removeSelected: function () {
    var left = this.left;
    var right = this.right;
    for (var i = 0; i < right.options.length; i++) {
      if (right.options[i].selected) {
        var opt = right.options[i];
        left.options[left.options.length] = new Option(opt.innerHTML,
          opt.value);
        right.options[i] = null;
        i--;
      }
    }
  },
  getOptions: function (isLeft) {
    var sel = isLeft ? this.left : this.right;
    var options = [];
    for (var i = 0; i < sel.options.length; i++) {
      options.push(sel.options[i].value);
    }
    return options;
  },
  removeAll: function () {
    var left = this.left;
    var right = this.right;
    for (var i = 0; i < right.options.length; i++) {
      var opt = right.options[i];
      left.options[left.options.length] = new Option(opt.innerHTML,
        opt.value);
    }
    right.options.length = 0;
  },
  moveUp: function () {
    var right = this.right;
    var selectedOptions = right.selectedOptions;
    var indices = [];
    for (var i = 0; i < selectedOptions.length; i++) {
      indices.push(selectedOptions[i].index);
    }
    var index = morpheus.Util.indexSort(indices, false);
    for (var i = 0; i < selectedOptions.length; i++) {
      var sel = selectedOptions[index[i]].index;
      var optHTML = right.options[sel].innerHTML;
      var optVal = right.options[sel].value;
      var opt1HTML = right.options[sel - 1].innerHTML;
      var opt1Val = right.options[sel - 1].value;
      right.options[sel] = new Option(opt1HTML, opt1Val);
      right.options[sel - 1] = new Option(optHTML, optVal);
      right.options.selectedIndex = sel - 1;
    }

  },
  moveDown: function () {
    var right = this.right;
    var selectedOptions = right.selectedOptions;
    var indices = [];
    for (var i = 0; i < selectedOptions.length; i++) {
      indices.push(selectedOptions[i].index);
    }
    var index = morpheus.Util.indexSort(indices, false);
    for (var i = 0; i < selectedOptions.length; i++) {
      var sel = selectedOptions[index[i]].index;
      var optHTML = right.options[sel].innerHTML;
      var optVal = right.options[sel].value;
      var opt1HTML = right.options[sel + 1].innerHTML;
      var opt1Val = right.options[sel + 1].value;
      right.options[sel] = new Option(opt1HTML, opt1Val);
      right.options[sel + 1] = new Option(optHTML, optVal);
      right.options.selectedIndex = sel + 1;
    }
  }
};

morpheus.FilterUI = function (project, isColumns) {
  var _this = this;
  this.project = project;
  this.isColumns = isColumns;
  var $div = $('<div style="min-width:180px;"></div>');
  this.$div = $div;
  $div.append(this.addBase());
  var $filterMode = $div.find('[name=filterMode]');
  $filterMode.on('change', function (e) {
    var isAndFilter = $filterMode.prop('checked');
    (isColumns ? project.getColumnFilter() : project.getRowFilter())
      .setAnd(isAndFilter);
    isColumns ? _this.project.setColumnFilter(_this.project
      .getColumnFilter(), true) : _this.project.setRowFilter(
      _this.project.getRowFilter(), true);
    e.preventDefault();
  });

  $div.on('click', '[data-name=add]', function (e) {
    var $this = $(this);
    var $row = $this.closest('.morpheus-entry');
    // add after
    var index = $row.index();
    var newFilter = new morpheus.AlwaysTrueFilter();
    (isColumns ? project.getColumnFilter() : project.getRowFilter())
      .insert(index, newFilter);
    $row.after(_this.add(newFilter));
    e.preventDefault();
  });
  $div.on('click', '[data-name=delete]', function (e) {
    var $this = $(this);
    var $row = $this.closest('.morpheus-entry');
    var index = $row.index() - 1;
    (isColumns ? project.getColumnFilter() : project.getRowFilter())
      .remove(index);
    $row.remove();
    isColumns ? _this.project.setColumnFilter(_this.project
      .getColumnFilter(), true) : _this.project.setRowFilter(
      _this.project.getRowFilter(), true);
    e.preventDefault();
  });
  $div.on('submit', 'form', function (e) {
    var $this = $(this);
    e.preventDefault();
  });
  $div.on('change', '[name=by]', function (e) {
    var $this = $(this);
    var fieldName = $this.val();
    var $row = $this.closest('.morpheus-entry');
    var index = $row.index() - 1;
    _this.createFilter({
      fieldName: fieldName,
      $div: $this
    });

    isColumns ? _this.project.setColumnFilter(_this.project
      .getColumnFilter(), true) : _this.project.setRowFilter(
      _this.project.getRowFilter(), true);
  });
  // show initial filters
  var combinedFilter = (isColumns ? project.getColumnFilter() : project
    .getRowFilter());
  var filters = combinedFilter.getFilters ? combinedFilter.getFilters() : [];
  for (var i = 0; i < filters.length; i++) {
    this.createFilter({
      filter: filters[i]
    });
  }
  if (combinedFilter.on) {
    combinedFilter.on('add', function (e) {
      _this.createFilter({
        filter: e.filter
      });
    });
    combinedFilter.on('remove', function (e) {
      // offset of 1 for header
      var $row = $div.find('.morpheus-entry')[1 + e.index].remove();
    });
    combinedFilter.on('and', function (e) {
      $filterMode.prop('checked', e.source.isAnd());
    });

  }
};

morpheus.FilterUI.rangeFilter = function (project, name, isColumns, $ui, filter) {
  $ui.empty();
  var html = [];
  html.push('<label>Range of values</label><br />');
  html
    .push('<label>>= </label> <input style="max-width:200px;" class="form-control input-sm" name="min" type="text" />');
  html
    .push('<label> and <= </label> <input style="max-width:200px;" class="form-control input-sm" name="max" type="text" />');
  html.push('<br /><a data-name="switch" href="#">Switch to top filter</a>');
  var $form = $(html.join(''));
  $form.appendTo($ui);
  $ui.find('[data-name=switch]')
    .on(
      'click',
      function (e) {
        e.preventDefault();
        var newFilter = morpheus.FilterUI.topFilter(project,
          name, isColumns, $ui);
        var index = -1;
        var filters = isColumns ? project.getColumnFilter()
          .getFilters() : project.getRowFilter()
          .getFilters();
        for (var i = 0; i < filters.length; i++) {
          if (filters[i] === filter) {
            index = i;
            break;
          }
        }
        if (index === -1) {
          throw new Error('Filter not found.');
        }
        (isColumns ? project.getColumnFilter() : project
          .getRowFilter()).set(index, newFilter);
        isColumns ? project.setColumnFilter(project
          .getColumnFilter(), true) : project
          .setRowFilter(project.getRowFilter(), true);
      });
  var $min = $ui.find('[name=min]');
  var $max = $ui.find('[name=max]');
  if (!filter) {
    filter = new morpheus.RangeFilter(-Number.MAX_VALUE, Number.MAX_VALUE,
      name, isColumns);
  } else {
    $min.val(filter.min);
    $max.val(filter.max);
  }

  $min.on('keyup', _.debounce(function (e) {
    filter.setMin(parseFloat($.trim($(this).val())));
    isColumns ? project.setColumnFilter(project.getColumnFilter(), true)
      : project.setRowFilter(project.getRowFilter(), true);

  }, 100));
  $max.on('keyup', _.debounce(function (e) {
    filter.setMax(parseFloat($.trim($(this).val())));
    isColumns ? project.setColumnFilter(project.getColumnFilter(), true)
      : project.setRowFilter(project.getRowFilter(), true);

  }, 100));

  return filter;

};
morpheus.FilterUI.topFilter = function (project, name, isColumns, $ui, filter) {
  $ui.empty();
  var html = [];
  html.push('<label>Top</label><br />');
  html
    .push('<select style="width:auto;" class="form-control input-sm" name="direction"><option value="Top">Top</option><option value="Bottom">Bottom</option><option value="TopBottom">Top/Bottom</option></select>');
  html
    .push(' <label>N </label> <input style="max-width:200px;" class="form-control input-sm" name="n" type="text" />');
  html.push('<br /><a data-name="switch" href="#">Switch to range filter</a>');
  var $form = $(html.join(''));
  $form.appendTo($ui);
  var $n = $ui.find('[name=n]');
  var $direction = $ui.find('[name=direction]');
  $ui.find('[data-name=switch]')
    .on(
      'click',
      function (e) {
        e.preventDefault();
        var newFilter = morpheus.FilterUI.rangeFilter(project,
          name, isColumns, $ui);
        var index = -1;
        var filters = isColumns ? project.getColumnFilter()
          .getFilters() : project.getRowFilter()
          .getFilters();
        for (var i = 0; i < filters.length; i++) {
          if (filters[i] === filter) {
            index = i;
            break;
          }
        }
        if (index === -1) {
          throw new Error('Filter not found.');
        }
        (isColumns ? project.getColumnFilter() : project
          .getRowFilter()).set(index, newFilter);
        isColumns ? project.setColumnFilter(project
          .getColumnFilter(), true) : project
          .setRowFilter(project.getRowFilter(), true);
      });
  if (!filter) {
    filter = new morpheus.TopNFilter(NaN, morpheus.TopNFilter.TOP, name, isColumns);
  } else {
    var dirVal;
    if (filter.direction === morpheus.TopNFilter.TOP) {
      dirVal = 'Top';
    } else if (filter.direction === morpheus.TopNFilter.BOTTOM) {
      dirVal = 'Bottom';
    } else {
      dirVal = 'TopBottom';
    }
    $direction.val(dirVal);
    $n.val(filter.n);
  }

  $direction.on('change', function () {
    var dir = $(this).val();
    var dirVal;
    if (dir === 'Top') {
      dirVal = morpheus.TopNFilter.TOP;
    } else if (dir === 'Bottom') {
      dirVal = morpheus.TopNFilter.BOTTOM;
    } else {
      dirVal = morpheus.TopNFilter.TOP_BOTTOM;
    }
    filter.setDirection(dirVal);

    isColumns ? project.setColumnFilter(project.getColumnFilter(), true)
      : project.setRowFilter(project.getRowFilter(), true);
  });
  $n.on('keyup', _.debounce(function (e) {
    filter.setN(parseInt($.trim($(this).val())));
    isColumns ? project.setColumnFilter(project.getColumnFilter(), true)
      : project.setRowFilter(project.getRowFilter(), true);

  }, 100));

  return filter;
};
morpheus.FilterUI.prototype = {
  /**
   *
   * @param options
   *            options.$div div to add filter to or null to add to end
   *            options.filter Pre-existing filter or null to create filter
   *            options.fieldName Field name to filter on
   */
  createFilter: function (options) {
    var index = -1;
    var $div = options.$div;
    var isColumns = this.isColumns;
    var filter = options.filter;
    var project = this.project;
    var fieldName = filter ? filter.name : options.fieldName;
    var $ui;
    if (!$div) {
      // add filter to end
      var $add = $(this.add(filter));
      $add.appendTo(this.$div);
      $ui = $add.find('[data-name=ui]');
    } else { // existing $div
      var $row = $div.closest('.morpheus-entry');
      index = $row.index() - 1;
      $ui = $row.find('[data-name=ui]');
    }

    $ui.empty();
    var vector = (isColumns ? this.project.getFullDataset()
      .getColumnMetadata() : this.project.getFullDataset()
      .getRowMetadata()).getByName(fieldName);

    if (filter instanceof morpheus.RangeFilter) {
      morpheus.FilterUI.rangeFilter(project, fieldName, isColumns, $ui,
        filter);
    } else if (filter instanceof morpheus.TopNFilter) {
      morpheus.FilterUI.topFilter(project, fieldName, isColumns, $ui,
        filter);
    } else if (filter == null && morpheus.VectorUtil.isNumber(vector)
      && morpheus.VectorUtil.containsMoreThanNValues(vector, 9)) {
      filter = morpheus.FilterUI.rangeFilter(project, fieldName,
        isColumns, $ui, filter);
    } else {
      var set = morpheus.VectorUtil.getSet(vector);
      var array = set.values();
      array.sort(morpheus.SortKey.ASCENDING_COMPARATOR);
      if (!filter) {
        filter = new morpheus.VectorFilter(new morpheus.Set(), set
          .size(), fieldName, isColumns);
      } else {
        filter.maxSetSize = array.length;
      }

      var checkBoxList = new morpheus.CheckBoxList({
        responsive: false,
        $el: $ui,
        items: array,
        set: filter.set
      });
      checkBoxList.on('checkBoxSelectionChanged', function () {
        isColumns ? project.setColumnFilter(project.getColumnFilter(),
          true) : project.setRowFilter(project.getRowFilter(),
          true);

      });
    }
    if (index !== -1) {
      // set the filter index
      if (fieldName !== '') {
        (isColumns ? project.getColumnFilter() : project.getRowFilter())
          .set(index, filter);
      } else {
        (isColumns ? project.getColumnFilter() : project.getRowFilter())
          .set(index, new morpheus.AlwaysTrueFilter());
      }
    }
    return filter;
  },

  addBase: function () {
    var html = [];
    html
      .push('<div style="padding-bottom:2px;border-bottom:1px solid #eee" class="morpheus-entry">');
    html.push('<div class="row">');
    html
      .push('<div class="col-xs-12">'
        + '<div class="checkbox"><label><input type="checkbox" name="filterMode">Pass all filters</label></div> '

        + '</div>');
    html.push('</div>');
    html.push('<div class="row">');
    html
      .push('<div class="col-xs-8"><a class="btn btn-default btn-xs" role="button"' +
        ' data-name="add" href="#">Add</a></div>');

    html.push('</div>');
    html.push('</div>');
    return html.join('');
  },
  add: function (filter) {
    var project = this.project;
    var isColumns = this.isColumns;
    var fields = morpheus.MetadataUtil.getMetadataNames(isColumns ? project
      .getFullDataset().getColumnMetadata() : project
      .getFullDataset().getRowMetadata());
    var html = [];
    html.push('<div class="morpheus-entry">');

    html.push('<div class="form-group">');
    html.push('<label>Field</label>');
    // field

    html
      .push('<select style="max-width:160px;overflow-x:hidden;" name="by" class="form-control input-sm">');
    html.push('<option value=""></option>');
    var filterField = filter ? filter.toString() : null;

    _.each(fields, function (field) {
      html.push('<option value="' + field + '"');
      if (field === filterField) {
        html.push(' selected');
      }
      html.push('>');
      html.push(field);
      html.push('</option>');
    });
    html.push('</select>');
    html.push('</div>');
    html.push('<div class="row">');
    // filter ui
    html.push('<div data-name="ui" class="col-xs-12"></div>');
    html.push('</div>');

    // end filter ui

    // add/delete
    html
      .push('<div style="padding-bottom:6px; border-bottom:1px solid #eee" class="row">');

    html.push('<div class="col-xs-11">');

    html
      .push('<a class="btn btn-default btn-xs" role="button" data-name="delete"' +
        ' href="#">Remove</a>');
    html.push('</div>');

    html.push('</div>'); // row
    html.push('</div>'); // morpheus-entry
    return html.join('');
  }
};

morpheus.FormBuilder = function (options) {
  var that = this;
  this.prefix = _.uniqueId('form');
  this.$form = $('<form></form>');
  this.$form.attr('role', 'form').attr('id', this.prefix);
  this.vertical = options && options.vertical;
  if (!this.vertical) {
    this.titleClass = 'col-xs-12 control-label';
    this.labelClass = 'col-xs-4 control-label';
    this.$form.addClass('form-horizontal');
  } else {
    this.labelClass = 'control-label';
    this.titleClass = 'control-label';
  }
  this.$form.on('submit', function (e) {
    e.preventDefault();
  });
  this.$form.on(
    'dragover',
    function (e) {
      var node = $(e.originalEvent.srcElement).parent().parent()
        .prev();
      if (node.is('select') && node.hasClass('file-input')) {
        $(e.originalEvent.srcElement).parent().css('border',
          '1px solid black');
        e.preventDefault();
        e.stopPropagation();
      }
    }).on(
    'dragenter',
    function (e) {
      var node = $(e.originalEvent.srcElement).parent().parent()
        .prev();
      if (node.is('select') && node.hasClass('file-input')) {
        $(e.originalEvent.srcElement).parent().css('border',
          '1px solid black');
        e.preventDefault();
        e.stopPropagation();
      }
    }).on('dragleave', function (e) {
    var node = $(e.originalEvent.srcElement).parent().parent().prev();
    if (node.is('select') && node.hasClass('file-input')) {
      $(e.originalEvent.srcElement).parent().css('border', '');
      e.preventDefault();
      e.stopPropagation();
    }
  }).on('drop', function (e) {
    var node = $(e.originalEvent.srcElement).parent().parent().prev();
    if (node.is('select') && node.hasClass('file-input')) {
      var isMultiple = node.data('multiple'); // multiple files?
      $(e.originalEvent.srcElement).parent().css('border', '');
      var name = node.attr('name');
      name = name.substring(0, name.length - '_picker'.length);
      if (e.originalEvent.dataTransfer) {
        if (e.originalEvent.dataTransfer.files.length) {
          e.preventDefault();
          e.stopPropagation();
          var files = e.originalEvent.dataTransfer.files;
          that.setValue(name, isMultiple ? files : files[0]);
          that.trigger('change', {
            name: name,
            value: files[0]
          });
        } else {
          var url = e.originalEvent.dataTransfer.getData('URL');
          e.preventDefault();
          e.stopPropagation();
          that.setValue(name, isMultiple ? [url] : url);
          that.trigger('change', {
            name: name,
            value: url
          });
        }
      }
    }
  });
  // this.labelColumnDef = '4';
  // this.fieldColumnDef = '8';
};

morpheus.FormBuilder.showProgressBar = function (options) {
  var content = [];
  content.push('<div class="container-fluid">');
  content.push('<div class="row">');
  content.push('<div class="col-xs-8">');
  content
    .push('<div class="progress progress-striped active"><div class="progress-bar" role="progressbar" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100" style="width: 100%"></div></div>');
  content.push('</div>'); // col
  content.push('<div class="col-xs-2">');
  content
    .push('<input class="btn btn-default" type="button" name="stop" value="Cancel">');
  content.push('</div>'); // col
  content.push('</div>'); // row
  if (options.subtitle) {
    content.push('<div class="row"><div class="col-xs-8">');
    content.push('<p class="text-muted">');
    content.push(options.subtitle);
    content.push('</p>');
    content.push('</div></div>');
  }
  content.push('</div>');
  var $content = $(content.join(''));
  $content.find('[name=stop]').on('click', function (e) {
    options.stop();
    e.preventDefault();
  });
  return morpheus.FormBuilder.showInDraggableDiv({
    title: options.title,
    $content: $content
  });
};
morpheus.FormBuilder.showInDraggableDiv = function (options) {
  var width = options.width || '300px';
  var html = [];
  html
    .push('<div style="top: 100px; position:absolute; padding-left:10px; padding-right:10px; width:'
      + width
      + ' ; background:white; box-shadow: 0 5px 15px rgba(0,0,0,0.5); border: 1px solid rgba(0,0,0,0.2); border-radius: 6px;">');

  html
    .push('<h4 style="cursor:move; border-bottom: 1px solid #e5e5e5;" name="header">'
      + options.title + '</h4>');
  html.push('<div name="content"></div>');
  html.push('</div>');

  var $div = $(html.join(''));
  var $content = $div.find('[name=content]');
  $div.find('[name=header]').on('dblclick', function () {
    if ($content.css('display') === 'none') {
      $content.css('display', '');
    } else {
      $content.css('display', 'none');
    }
  });

  options.$content.appendTo($content);
  $div.css('left', ($(window).width() / 2) - $content.outerWidth() / 2);
  $div.draggable({
    handle: '[name=header]',
    containment: 'document'
  });
  // $div.resizable();
  $div.appendTo(options.appendTo != null ? options.appendTo : $(document.body));
  return $div;
};

morpheus.FormBuilder.showMessageModal = function (options) {
  var $div = morpheus.FormBuilder
    ._showInModal({
      modalClass: options.modalClass,
      title: options.title,
      html: options.html,
      footer: ('<button type="button" class="btn btn-default"' +
      ' data-dismiss="modal">OK</button>'),
      backdrop: options.backdrop,
      size: options.size,
      focus: options.focus,
      appendTo: options.appendTo
    });
  $div.find('button').focus();
  return $div;

  // if (options.draggable) {
  // $div.draggable({
  // handle : $div.find(".modal-header")
  // });
  // }
};

morpheus.FormBuilder._showInModal = function (options) {
  var html = [];
  options = $.extend({}, {
    size: '',
    close: true,
    modalClass: ''
  }, options);
  html.push('<div tabindex="-1" class="modal' + (options.modalClass ? (' ' + options.modalClass) : '') + '" role="dialog"' +
    ' aria-hidden="false"');
  if (options.z) {
    html.push(' style="z-index: ' + options.z + ' !important;"');
  }
  html.push('>');
  html.push('<div class="modal-dialog ' + options.size + '">');
  html.push('<div class="modal-content">');
  html.push(' <div class="modal-header">');
  if (options.close) {
    html
      .push('  <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>');
  }
  if (options.title != null) {
    html.push('<h4 class="modal-title">' + options.title + '</h4>');
  }
  html.push('</div>');
  html.push('<div class="modal-body">');
  html.push('</div>');
  if (options.footer) {
    html.push('<div class="modal-footer">');
    html.push(options.footer);
  }
  html.push('</div>');
  html.push('</div>');
  html.push('</div>');
  html.push('</div>');
  var $div = $(html.join(''));
  $div.on('mousewheel', function (e) {
    e.stopPropagation();
  });
  $div.find('.modal-body').html(options.html);
  $div.prependTo(options.appendTo != null ? options.appendTo : $(document.body));
  $div.modal({
    keyboard: true,
    backdrop: options.backdrop === true ? true : false,
  }).on('hidden.bs.modal', function (e) {
    $div.remove();
    if (options.onClose) {
      options.onClose();
    }
    if (options.focus) {
      $(options.focus).focus();
    }
  });

  return $div;
};
/**
 *
 * @param options.z Modal z-index
 * @param options.title Modal title
 * @param options.html Model content
 * @param options.close Whether to show a close button in the footer
 * @param options.onClose {Function} Funtion to invoke when modal is hidden
 * @param options.backdrop Whether to show backdrop
 * @param.options Modal size
 * @param options.focus Element to return focus to when modal is hidden
 * @param options.modalClass
 */
morpheus.FormBuilder.showInModal = function (options) {
  return morpheus.FormBuilder
    ._showInModal({
      modalClass: options.modalClass,
      title: options.title,
      html: options.html,
      footer: options.close ? ('<button type="button" class="btn btn-default" data-dismiss="modal">'
      + options.close + '</button>')
        : null,
      onClose: options.onClose,
      appendTo: options.appendTo,
      backdrop: options.backdrop,
      size: options.size,
      focus: options.focus
    });
  // if (options.draggable) {
  // $div.draggable({
  // handle : $div.find(".modal-header")
  // });
  // }
};

/**
 *
 * @param options.ok
 * @param options.cancel
 * @param options.apply
 * @param options.title
 * @param options.content
 * @param options.okCallback
 * @param options.cancelCallba
 * @param options.okFocus
 *
 */
morpheus.FormBuilder.showOkCancel = function (options) {
  options = $.extend({}, {
    ok: true,
    cancel: true
  }, options);
  var footer = [];
  if (options.ok) {
    footer
      .push('<button name="ok" type="button" class="btn btn-default">OK</button>');
  }
  if (options.apply) {
    footer
      .push('<button name="apply" type="button" class="btn btn-default">Apply</button>');
  }
  if (options.cancel) {
    footer
      .push('<button name="cancel" type="button" data-dismiss="modal" class="btn btn-default">Cancel</button>');
  }
  var $div = morpheus.FormBuilder._showInModal({
    title: options.title,
    html: options.content,
    footer: footer.join(''),
    size: options.size,
    close: options.close,
    onClose: options.onClose,
    focus: options.focus,
    appendTo: options.appendTo
  });
  // if (options.align === 'right') {
  // $div.css('left', $(window).width()
  // - $div.find('.modal-content').width() - 60);
  // }
  var $ok = $div.find('[name=ok]');
  $ok.on('click', function (e) {
    options.okCallback();
    $div.modal('hide');
  });
  $div.find('[name=cancel]').on('click', function (e) {
    if (options.cancelCallback) {
      options.cancelCallback();
    }
    $div.modal('hide');
  });
  if (options.okFocus) {
    $ok.focus();
  }

  if (options.draggable) {
    $div.draggable({
      handle: '.modal-header',
      containment: 'document'
    });
  }
  return $div;
};

morpheus.FormBuilder.hasChanged = function (object, keyToUIElement) {
  var keys = _.keys(keyToUIElement);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var value = object[key];
    var $element = keyToUIElement[key];
    if (value !== morpheus.FormBuilder.getValue($element)) {
      return true;
    }
  }
  return false;
};
morpheus.FormBuilder.getValue = function ($element) {
  var list = $element.data('morpheus.checkbox-list');
  if (list != null) {
    return list.val();
  }
  if ($element.attr('type') === 'radio') {
    return $element.filter(':checked').val();
  }
  if ($element.data('type') === 'file') {
    return $element.data('files');
  }
  return $element.attr('type') === 'checkbox' ? $element.prop('checked') : $element.val();
};

morpheus.FormBuilder.prototype = {
  appendContent: function ($content) {
    this.$form.append($content);
  },
  addSeparator: function () {
    var html = [];
    html.push('<div class="form-group">');
    if (!this.vertical) {
      html.push('<div class="col-xs-12">');
    }
    html.push('<hr />');
    if (!this.vertical) {
      html.push('</div>');
    }
    html.push('</div>');
    this.$form.append(html.join(''));
  },
  _append: function (html, field, isFieldStart) {
    var that = this;
    var required = field.required;
    var name = field.name;
    var type = field.type;
    if (type == 'separator') {
      html.push(this.vertical ? '<div class="form-group"></div>'
        : '<div class="col-xs-12">');
      html.push('<hr />');
      html.push('</div>');
      return;
    }
    var title = field.title;
    var disabled = field.disabled;
    var help = field.help;
    var value = field.value;
    var showLabel = field.showLabel;
    var col = '';
    var labelColumn = '';
    if (!this.vertical) {
      col = field.col || 'col-xs-8';
    }
    if (showLabel === undefined) {
      showLabel = 'checkbox' !== type && 'button' !== type
        && 'radio' !== type;
      showLabel = showLabel || field.options !== undefined;
    }
    var id = that.prefix + '_' + name;
    if (title === undefined) {
      title = name.replace(/_/g, ' ');
      title = title[0].toUpperCase() + title.substring(1);
    }
    if (showLabel) {
      html.push('<label for="' + id + '" class="' + this.labelClass
        + '">');
      html.push(title);
      html.push('</label>');
      if (isFieldStart) {
        html.push('<div class="' + col + '">');
      }
    } else if (isFieldStart && !this.vertical) {
      html.push('<div class="col-xs-offset-4 ' + col + '">');
    }
    if ('radio' === type) {
      if (field.options) {
        _.each(field.options,
          function (choice) {
            var isChoiceObject = _.isObject(choice)
              && choice.value !== undefined;
            var optionValue = isChoiceObject ? choice.value
              : choice;
            var optionText = isChoiceObject ? choice.name
              : choice;
            var selected = value === optionValue;
            html.push('<div class="radio"><label>');
            html.push('<input value="' + optionValue
              + '" name="' + field.name
              + '" type="radio"');
            if (selected) {
              html.push(' checked');
            }
            html.push('> ');
            if (choice.icon) {
              html.push('<span class="' + choice.icon
                + '"></span> ');
            }
            optionText = optionText[0].toUpperCase()
              + optionText.substring(1);
            html.push(optionText);
            html.push('</label></div>');
          });
      } else {
        html.push('<div class="radio"><label>');
        html.push('<input value="' + value + '" name="' + name
          + '" id="' + id + '" type="radio"');
        if (field.checked) {
          html.push(' checked');
        }
        html.push('> ');
        html.push(value[0].toUpperCase() + value.substring(1));
        html.push('</label></div>');
      }
    } else if ('checkbox' === type) {
      html.push('<div class="checkbox"><label>');
      html.push('<input name="' + name + '" id="' + id
        + '" type="checkbox"');
      if (value) {
        html.push(' checked');
      }
      if (disabled) {
        html.push(' disabled');
      }
      html.push('> ');
      html.push(title);
      html.push('</label></div>');
    } else if ('checkbox-list' === type) {
      html.push('<div name="' + name + '" class="checkbox-list"><div>');
    } else if ('select' == type || type == 'bootstrap-select') {
      // if (field.multiple) {
      // field.type = 'bootstrap-select';
      // type = 'bootstrap-select';
      // }
      if (type == 'bootstrap-select') {
        html.push('<select data-live-search="' + (field.search ? true : false) + '" data-selected-text-format="count" name="'
          + name + '" id="' + id
          + '" class="selectpicker form-control"');
      } else {
        html.push('<select name="' + name + '" id="' + id
          + '" class="form-control"');
      }
      if (disabled) {
        html.push(' disabled');
      }
      if (field.multiple) {
        html.push(' multiple');
      }
      html.push('>');
      _.each(field.options, function (choice) {
        if (choice && choice.divider) {
          html.push('<option data-divider="true"></option>');
        } else {
          html.push('<option value="');
          var isChoiceObject = _.isObject(choice)
            && choice.value !== undefined;
          var optionValue = isChoiceObject ? choice.value : choice;
          var optionText = isChoiceObject ? choice.name : choice;
          html.push(optionValue);
          html.push('"');
          var selected = false;
          if (_.isObject(value)) {
            selected = value[optionValue];
          } else {
            selected = value == optionValue;
          }
          if (selected) {
            html.push(' selected');
          }
          html.push('>');
          html.push(optionText);
          html.push('</option>');
        }
      });
      html.push('</select>');
      if (field.type == 'bootstrap-select' && field.toggle) {
        html.push('<p class="help-block"><a data-name="' + name
          + '_all" href="#">All</a>&nbsp;|&nbsp;<a data-name="' + name
          + '_none" href="#">None</a></p>');
        that.$form.on('click', '[data-name=' + name + '_all]',
          function (evt) {
            evt.preventDefault();
            var $select = that.$form
              .find('[name=' + name + ']');
            $select.selectpicker('val', $.map($select
              .find('option'), function (o) {
              return $(o).val();
            }));
            $select.trigger('change');
          });
        that.$form.on('click', '[data-name=' + name + '_none]',
          function (evt) {
            evt.preventDefault();
            var $select = that.$form
              .find('[name=' + name + ']');
            $select.selectpicker('val', []);
            $select.trigger('change');
          });
      }
    } else if ('textarea' == type) {
      html.push('<textarea id="' + id + '" class="form-control" name="'
        + name + '"');
      if (required) {
        html.push(' required');
      }
      if (field.placeholder) {
        html.push(' placeholder="' + field.placeholder + '"');
      }
      if (disabled) {
        html.push(' disabled');
      }
      html.push('>');
      if (value != null) {
        html.push(value);
      }
      html.push('</textarea>');
    } else if ('button' == type) {
      html.push('<button id="' + id + '" name="' + name
        + '" type="button" class="btn btn-default btn-sm">');
      if (field.icon) {
        html.push('<span class="' + field.icon + '"></span> ');
      }
      html.push(value ? value : title);
      html.push('</button>');
    } else if ('custom' === type) {
      html.push(value);
    } else if ('file' === type) {
      var isMultiple = field.multiple == null ? false : field.multiple;
      html
        .push('<select data-multiple="'
          + isMultiple
          + '" data-type="file" title="'
          + (field.placeholder || (isMultiple ? 'Choose one or more files...'
            : 'Choose a file...'))
          + '" name="'
          + name
          + '_picker" data-width="35%" class="file-input selectpicker form-control">');
      var options = [];

      if (field.options) {
        options = options.concat(field.options);

      }
      // data types are file, dropbox, url, GSE, and predefined
      options.push('My Computer');
      options.push('URL');
      options.push('GEO Datasets');
      if (typeof Dropbox !== 'undefined') {
        options.push('Dropbox');
      }
      if (field.text != null) {
        options.push(field.text);
      }
      _.each(options, function (choice, index) {
        var isChoiceObject = _.isObject(choice)
          && choice.value !== undefined;
        var optionValue = isChoiceObject ? choice.value : choice;
        var optionText = isChoiceObject ? choice.name : choice;
        html.push('<option value="');
        html.push(optionValue);
        html.push('"');
        if (isChoiceObject && choice.disabled) {
          html.push(' disabled');
        }
        if (optionValue === 'Dropbox') {
          html.push(' data-icon="fa fa-dropbox"');
        } else if (optionValue === 'My Computer') {
          html.push(' data-icon="fa fa-desktop"');
        } else if (optionValue === 'URL') {
          html.push(' data-icon="fa fa-external-link"');
        } else if (optionValue === 'GEO Datasets') {
          html.push(' data-icon="fa fa-external-link"');
        }
        html.push('>');
        html.push(optionText);
        html.push('</option>');
      });
      html.push('</select>');

      html.push('<div>');

      html
        .push('<input placeholder="'
          + (isMultiple ? 'Enter one or more URLs'
            : 'Enter a URL')
          + '" class="form-control" style="width:50%; display:none;" type="text" name="'
          + name + '_url">');

      if (field.gse !== false) {
        html.push('<div>');
        html
          .push('<input placeholder="'
            + "Enter a GSE or GDS identifier"
            + '" class="form-control" style="width:50%; display:none;" type="text" name="'
            + name + '_geo">');
        html.push('</div>');
      }
      if (field.text) {
        html
          .push('<input class="form-control" style="width:50%; display:none;" type="text" name="'
            + name + '_text">');
      }
      html.push('</div>');

      html.push('<input style="display:none;" type="file" name="' + name
        + '_file"' + (isMultiple ? ' multiple' : '') + '>');
      // browse button clicked
      // select change
      that.$form
        .on(
          'change',
          '[name=' + name + '_picker]',
          function (evt) {
            var $this = $(this);
            var val = $this.val();
            var showUrlInput = val === 'URL';
            var showGSEInput = val === 'GEO Datasets';
            var showTextInput = val === field.text;
            if ('Dropbox' === val) {
              var options = {
                success: function (results) {
                  var val = !isMultiple ? results[0].link
                    : results.map(function (result) {
                    return result.link;
                  });
                  that.setValue(name, val);
                  that.trigger('change', {
                    name: name,
                    value: val
                  });
                },
                linkType: 'direct',
                multiselect: isMultiple
              };
              Dropbox.choose(options);
              that.$form.find('[name=' + name + '_picker]').selectpicker('val', '');
            } else if ('My Computer' === val) {
              that.$form.find('[name=' + name + '_file]')
                .click();
              that.$form.find('[name=' + name + '_picker]').selectpicker('val', '');
            }

            that.$form.find('[name=' + name + '_url]')
              .css('display',
                showUrlInput ? '' : 'none');
            that.$form.find('[name=' + name + '_geo]')
              .css('display',
                showGSEInput ? '' : 'none');
          });
      // URL
      that.$form.on('keyup', '[name=' + name + '_url]', function (evt) {
        var text = $.trim($(this).val());
        if (isMultiple) {
          text = text.split(',').filter(function (t) {
            t = $.trim(t);
            return t !== '';
          });
        }
        that.setValue(name, text);
        if (evt.which === 13) {
          that.trigger('change', {
            name: name,
            value: text
          });
        }
      });
      that.$form.on('keyup', '[name=' + name + '_text]', function (evt) {
        var text = $.trim($(this).val());
        that.setValue(name, text);
        if (evt.which === 13) {
          that.trigger('change', {
            name: name,
            value: text
          });
        }
      });
      // GEO
      that.$form.on('keyup', '[name=' + name + '_geo]', function (evt) {
        var text = $.trim($(this).val());
        that.setValue(name, text);
        if (evt.which === 13) {
          that.trigger('change', {
            name: name,
            value: text.toUpperCase()
          })
        }
      });
      // browse file selected
      that.$form.on('change', '[name=' + name + '_file]', function (evt) {

        var files = evt.target.files; // FileList object
        that.setValue(name, isMultiple ? files : files[0]);
        that.trigger('change', {
          name: name,
          value: isMultiple ? files : files[0]
        });
      });
    } else {
      type = type == null ? 'text' : type;
      if (type === 'div') {
        html.push('<div name="' + name + '" id="' + id + '"');
      } else {
        html.push('<input type="' + type
          + '" class="form-control" name="' + name + '" id="'
          + id + '"');
      }
      if (value != null) {
        html.push(' value="' + value + '"');
      }
      if (field.placeholder) {
        html.push(' placeholder="' + field.placeholder + '"');
      }
      if (field.min != null) {
        html.push(' min="' + field.min + '"');
      }
      if (field.max != null) {
        html.push(' max="' + field.max + '"');
      }
      if (field.step) {
        html.push(' step="' + field.step + '"');
      }
      if (required) {
        html.push(' required');
      }
      if (disabled) {
        html.push(' disabled');
      }
      html.push('>');
      if (type === 'div') {
        html.push('</div>');
      }
    }
    if (help !== undefined) {
      html.push('<span data-name="' + name + '_help" class="help-block">');
      html.push(help);
      html.push('</span>');
    }
  },
  append: function (fields) {
    var html = [];
    var that = this;
    var isArray = morpheus.Util.isArray(fields);
    if (!isArray) {
      fields = [fields];
    }
    html.push('<div class="form-group">');
    _.each(fields, function (field, index) {
      that._append(html, field, index === 0);
    });
    html.push('</div>');
    html.push('</div>');
    var $div = $(html.join(''));
    this.$form.append($div);
    var checkBoxLists = $div.find('.checkbox-list');
    if (checkBoxLists.length > 0) {
      var checkBoxIndex = 0;
      _.each(fields, function (field) {
        // needs to already be in dom
        if (field.type === 'checkbox-list') {
          var list = new morpheus.CheckBoxList({
            responsive: false,
            $el: $(checkBoxLists[checkBoxIndex]),
            items: field.options
          });

          $(checkBoxLists[checkBoxIndex]).data(
            'morpheus.checkbox-list', list);
          checkBoxIndex++;
        }
      });
    }
    $div.find('.selectpicker').selectpicker({
      iconBase: 'fa',
      tickIcon: 'fa-check',
      style: 'btn-default btn-sm'
    });
  },
  clear: function () {
    this.$form.empty();
  },
  getValue: function (name) {
    var $v = this.$form.find('[name=' + name + ']');
    if ($v.length === 0) {
      $v = this.$form.find('[name=' + name + '_picker]');
    }
    return morpheus.FormBuilder.getValue($v);
  },
  setOptions: function (name, options, selectFirst) {
    var $select = this.$form.find('[name=' + name + ']');
    var checkBoxList = $select.data('morpheus.checkbox-list');
    if (checkBoxList) {
      checkBoxList.setItems(options);
    } else {
      var html = [];
      var selection = $select.val();
      _.each(options, function (choice) {
        html.push('<option value="');
        var isChoiceObject = _.isObject(choice)
          && choice.value !== undefined;
        var optionValue = isChoiceObject ? choice.value : choice;
        var optionText = isChoiceObject ? choice.name : choice;
        html.push(optionValue);
        html.push('"');

        html.push('>');
        html.push(optionText);
        html.push('</option>');
      });
      $select.html(html.join(''));
      $select.val(selection);
      if (selectFirst && $select.val() == null) {
        if ($select[0].options.length > 0) {
          $select.val($select[0].options[0].value);
        }

      }
      if ($select.hasClass('selectpicker')) {
        $select.selectpicker('refresh');
        $select.selectpicker('render');
      }
    }
  },
  find: function (name) {
    return this.$form.find('[name=' + name + ']');
  },
  setHelpText: function (name, value) {
    var v = this.$form.find('[data-name=' + name + '_help]');
    v.html(value);
  },
  setValue: function (name, value) {
    var v = this.$form.find('[name=' + name + ']');
    if (v.length === 0) {
      v = this.$form.find('[name=' + name + '_picker]');
      if (v.data('type') === 'file') {
        v.val(value);
        v.selectpicker('render');
        v.data('files', value);
        return;
      }
    }
    var type = v.attr('type');
    var list = v.data('morpheus.checkbox-list');
    if (list) {
      list.setValue(value);
    } else {
      if (type === 'radio') {
        v.filter('[value=' + value + ']').prop('checked', true);
      } else if (type === 'checkbox') {
        v.prop('checked', value);
      } else {
        v.val(value);
      }
      if (v.hasClass('selectpicker')) {
        v.selectpicker('render');
      }
    }

  },
  setVisible: function (name, visible) {
    var $div = this.$form.find('[name=' + name + ']')
      .parents('.form-group');
    if (visible) {
      $div.show();
    } else {
      $div.hide();
    }
  },
  remove: function (name) {
    var $div = this.$form.find('[name=' + name + ']')
      .parents('.form-group');
    $div.remove();
  },
  setEnabled: function (name, enabled) {
    var $div = this.$form.find('[name=' + name + ']');
    $div.attr('disabled', !enabled);
    if (!enabled) {
      $div.parents('.form-group').find('label').addClass('text-muted');
    } else {
      $div.parents('.form-group').find('label').removeClass('text-muted');
    }
  }
};
morpheus.Util.extend(morpheus.FormBuilder, morpheus.Events);

morpheus.GradientColorSupplier = function () {
  morpheus.AbstractColorSupplier.call(this);
  this._updateScale();
};
morpheus.GradientColorSupplier.prototype = {
  createInstance: function () {
    return new morpheus.GradientColorSupplier();
  },
  getColor: function (row, column, value) {
    if (isNaN(value)) {
      return this.missingColor;
    }
    var min = this.min;
    var max = this.max;
    var colors = this.colors;
    if (value <= min) {
      return colors[0];
    } else if (value >= max) {
      return colors[colors.length - 1];
    }
    var fraction = morpheus.SteppedColorSupplier.linearScale(value, min,
        max, 0, 100) / 100;
    return this.colorScale(fraction);
  },
  setFractions: function (options) {
    morpheus.AbstractColorSupplier.prototype.setFractions.call(this,
      options);
    this._updateScale();
  },
  _updateScale: function () {
    this.colorScale = d3.scale.linear().domain(this.fractions).range(
      this.colors).clamp(true);
  }
};
morpheus.Util.extend(morpheus.GradientColorSupplier,
  morpheus.AbstractColorSupplier);

morpheus.Grid = function (options) {
  this.options = options;
  var _this = this;
  var grid;
  this.items = options.items;
  /**
   * Maps from model index to view index. Note that not all model indices are
   * contained in the map because they might have been filtered from the view.
   */
  this.modelToView = null;
  /** view order in model space */
  this.viewOrder = null;
  function getItemColumnValue(item, column) {
    return column.getter(item);
  }

  this.filter = new morpheus.CombinedGridFilter();
  var model = {
    getLength: function () {
      return _this.viewOrder != null ? _this.viewOrder.length
        : _this.items.length;
    },
    getItem: function (index) {
      return _this.items[_this.viewOrder != null ? _this.viewOrder[index]
        : index];
    }
  };
  this.$el = options.$el;

  var gridOptions = $.extend({}, {
    select: true,
    headerRowHeight: 0,
    showHeaderRow: false,
    multiColumnSort: true,
    multiSelect: false,
    topPanelHeight: 0,
    enableColumnReorder: false,
    enableTextSelectionOnCells: true,
    forceFitColumns: true,
    dataItemColumnValueExtractor: getItemColumnValue,
    defaultFormatter: function (row, cell, value, columnDef, dataContext) {
      if (_.isNumber(value)) {
        return morpheus.Util.nf(value);
      } else if (morpheus.Util.isArray(value)) {
        var s = [];
        for (var i = 0, length = value.length; i < length; i++) {
          if (i > 0) {
            s.push(', ');
          }
          var val = value[i];
          s.push(value[i]);
        }
        return s.join('');
      } else {
        return value;
      }
    }
  }, options.gridOptions || {});

  grid = new Slick.Grid(options.$el, model, options.columns, gridOptions);
  this.grid = grid;
  grid.registerPlugin(new morpheus.AutoTooltips2());

  grid.onCellChange.subscribe(function (e, args) {
    _this.trigger('edit', args);
  });

  if (gridOptions.select) {
    grid.setSelectionModel(new Slick.RowSelectionModel({
      selectActiveRow: true,
      multiSelect: gridOptions.multiSelect
    }));
    grid.getSelectionModel().onSelectedRangesChanged.subscribe(function (e) {
      var nitems = grid.getDataLength();
      _this.trigger('selectionChanged', {
        selectedRows: grid.getSelectedRows().filter(function (row) {
          return row >= 0 && row <= nitems;
        })
      });
    });
  }

  grid.onSort.subscribe(function (e, args) {
    _this.sortCols = args.sortCols;
    _this._updateMappings();
    grid.invalidate();
  });

  options.$el.on('click', function (e) {
    var cell = grid.getCellFromEvent(e);
    if (cell) {
      _this.trigger('click', {
        row: cell.row,
        target: e.target
      });
    }
  });
  options.$el.on('dblclick', function (e) {
    var cell = grid.getCellFromEvent(e);
    if (cell) {
      _this.trigger('dblclick', {
        row: cell.row,
        target: e.target
      });
    }
  });
  if (options.sort) {
    var gridSortColumns = [];
    var gridColumns = grid.getColumns();
    var sortCols = [];
    options.sort.forEach(function (c) {
      var column = null;
      for (var i = 0; i < gridColumns.length; i++) {
        if (gridColumns[i].name === c.name) {
          column = gridColumns[i];
          break;
        }
      }
      if (column != null) {

        gridSortColumns.push({
          columnId: column.id,
          sortAsc: c.sortAsc
        });
      } else {
        console.log(c.name + ' not found.');
      }
    });
    this.setSortColumns(gridSortColumns);
  }

  this.grid.invalidate();

};
morpheus.Grid.prototype = {
  columnsAutosized: false,
  setSortColumns: function (gridSortColumns) {
    this.grid.setSortColumns(gridSortColumns);
    this.sortCols = [];
    for (var i = 0; i < gridSortColumns.length; i++) {
      var column = this.grid.getColumns()[this.grid.getColumnIndex(gridSortColumns[i].columnId)];
      if (column == null) {
        throw 'Unable to find column ' + gridSortColumns[i];
      }
      this.sortCols.push({
        sortCol: column,
        sortAsc: gridSortColumns[i].sortAsc
      });
    }

    this._updateMappings();
    this.grid.invalidate();
  },
  setColumns: function (columns) {
    this.grid.setColumns(columns);
    this.grid.resizeCanvas();
    this.grid.invalidate();
  },
  getColumns: function () {
    return this.grid.getColumns();
  },
  getSelectedRows: function () {
    var nitems = this.grid.getDataLength();
    return this.grid.getSelectedRows().filter(function (row) {
      return row >= 0 && row <= nitems;
    });
  },
  getSelectedItems: function () {
    var rows = this.grid.getSelectedRows();
    var selection = [];
    for (var i = 0, nrows = rows.length; i < nrows; i++) {
      selection.push(this.items[this.convertViewIndexToModel(rows[i])]);
    }
    return selection;
  },
  getSelectedItem: function () {
    var rows = this.grid.getSelectedRows();
    if (rows.length === 1) {
      return this.items[this.convertViewIndexToModel(rows[0])];
    }
    return null;
  },
  /**
   * Gets the sorted, visible items
   */
  getItems: function () {
    var items = [];
    for (var i = 0, length = this.getFilteredItemCount(); i < length; i++) {
      items.push(this.items[this.convertViewIndexToModel(i)]);
    }
    return items;
  },
  getAllItemCount: function () {
    return this.items.length;
  },
  getAllItems: function () {
    return this.items;
  },
  getFilteredItemCount: function () {
    return this.viewOrder ? this.viewOrder.length : this.items.length;
  },
  redraw: function () {
    this.grid.invalidate();
  },
  redrawRows: function (rows) {
    this.grid.invalidateRows(rows);
    this.grid.render();
  },
  setItems: function (items) {
    // clear the selection
    this.items = items;
    if (this.grid.getSelectionModel()) {
      this.grid.setSelectedRows([]);
    }
    this.setFilter(this.filter);
    this.maybeAutoResizeColumns();
  },
  maybeAutoResizeColumns: function () {
    if (!this.columnsAutosized) {
      this.autosizeColumns();
    }
  },
  convertModelIndexToView: function (modelIndex) {
    if (this.modelToView !== null) {
      var index = this.modelToView.get(modelIndex);
      return index !== undefined ? index : -1;
    }
    return modelIndex;
  },
  convertViewIndexToModel: function (viewIndex) {
    return this.viewOrder != null ? (viewIndex < this.viewOrder.length
    && viewIndex >= 0 ? this.viewOrder[viewIndex] : -1) : viewIndex;
  },
  _updateMappings: function () {
    var selectedViewIndices = this.grid.getSelectionModel() != null ? this.grid
      .getSelectedRows()
      : null;
    var selectedModelIndices = [];
    if (selectedViewIndices) {
      for (var i = 0, length = selectedViewIndices.length; i < length; i++) {
        selectedModelIndices.push(this
          .convertViewIndexToModel(selectedViewIndices[i]));
      }
    }
    this.viewOrder = null;
    if (this.filter != null) {
      this.filter.init();
      if (!this.filter.isEmpty()) {
        this.viewOrder = [];
        for (var i = 0, length = this.items.length; i < length; i++) {
          if (this.filter.accept(this.items[i])) {
            this.viewOrder.push(i);
          }
        }
      }
    }
    var cols = this.sortCols;
    if (cols && cols.length > 0) {
      if (this.viewOrder == null) {
        this.viewOrder = [];
        for (var i = 0, length = this.items.length; i < length; i++) {
          this.viewOrder.push(i);
        }
      }
      var ncols = cols.length;
      var items = this.items;
      // nulls always go at end

      this.viewOrder.sort(function (index1, index2) {
        for (var i = 0; i < ncols; i++) {
          var getter = cols[i].sortCol.getter;
          var comparator = cols[i].sortAsc ? morpheus.SortKey.ASCENDING_COMPARATOR : morpheus.SortKey.DESCENDING_COMPARATOR;
          var value1 = getter(items[index1]);
          var value2 = getter(items[index2]);
          var result = comparator(value1, value2);
          if (result !== 0) {
            return result;
          }
        }
        return 0;
      });
    }
    if (this.viewOrder != null) {
      this.modelToView = new morpheus.Map();
      for (var i = 0, length = this.viewOrder.length; i < length; i++) {
        this.modelToView.set(this.viewOrder[i], i);
      }
    } else {
      this.modelToView = null;
    }
    if (this.grid.getSelectionModel() != null) {
      var newSelectedViewIndices = [];
      for (var i = 0, length = selectedModelIndices.length; i < length; i++) {
        var index = this
          .convertModelIndexToView(selectedModelIndices[i]);
        if (index !== undefined) {
          newSelectedViewIndices.push(index);
        }
      }
      this.grid.setSelectedRows(newSelectedViewIndices);
    }
  },
  setSelectedRows: function (rows) {
    this.grid.setSelectedRows(rows);
  },
  setFilter: function (filter) {
    this.filter = filter;
    this._updateMappings();
    this.grid.invalidate();
    this.trigger('filter');
  },
  getFilter: function () {
    return this.filter;
  },
  autosizeColumns: function () {
    var columns = this.grid.getColumns();
    var items = this.getItems();

    if (!items || items.length === 0 || !columns || columns.length === 0) {
      return;
    }
    var gridWidth = this.options.$el.width() - 30;
    if (gridWidth <= 0) {
      return;
    }
    this.columnsAutosized = true;
    if (columns.length > -1) {
      var div = document.createElement('div');
      document.body.appendChild(div);
      var $d = $(div);
      $d.css({
        position: 'absolute',
        left: -1000,
        top: -1000
      });

      var $row = $('<div class="slick-table">'
        + '<div class="ui-state-default slick-header-column slick-header-sortable ui-sortable-handle"></div>'
        + '<div class="ui-widget-content slick-row"><div class="slick-cell selected"></div></div>'
        + '</div>');
      var $cell = $row.find('.slick-cell');
      var $header = $row.find('.slick-header-column');
      $row.appendTo($d);

      var maxWidth = Math.min(parseInt(gridWidth / 2), 400);
      var getColumnWidth = function (column) {
        var w = $header.html(column.name).outerWidth() + 13; // leave space for sort indicator

        if (column.prototypeValue) {
          $cell.html(column.prototypeValue);
          w = Math.max($cell.outerWidth(), w);
        } else {
          for (var i = 0, nrows = Math.min(items.length, 10); i < nrows; i++) {
            var html = column.formatter(i, null, column
              .getter(items[i]), column, items[i]);
            var $html = $(html);
            $html.find('.slick-cell-wrapper').attr('class', '');
            $cell.html($html);
            w = Math.max($cell.outerWidth(), w);
          }
        }
        column.width = parseInt(Math.min(maxWidth, w));

      };
      var totalWidth = 0;
      for (var i = 0; i < columns.length; i++) {
        getColumnWidth(columns[i]);
        totalWidth += columns[i].width;
      }

      if (totalWidth < gridWidth) {
        // grow columns
        // var delta = parseInt((gridWidth - totalWidth) / columns.length);
        // for (var i = 0; i < columns.length; i++) {
        // //columns[i].width += delta;
        // }

      } else if (totalWidth > gridWidth) {
        // shrink
        //columns[columns.length - 1].width -= (totalWidth - gridWidth);
        // shrink last column
      }

      $d.remove();
      this.grid.resizeCanvas();
    }

  }
};

morpheus.Util.extend(morpheus.Grid, morpheus.Events);

/**
 * AutoTooltips2 plugin to show/hide tooltips when columns are too narrow to fit
 * content.
 *
 * @constructor
 */
morpheus.AutoTooltips2 = function (options) {
  var _grid;
  var _self = this;
  var tip;

  /**
   * Initialize plugin.
   */
  function init(grid) {
    _grid = grid;

    $(_grid.getCanvasNode()).on('mouseover', '.slick-row', showToolTip);
    $(_grid.getCanvasNode()).on('mouseout', '.slick-row', hideToolTip);
    $(_grid.getCanvasNode()).on('mouseup', hideAll);

    // $(_grid.getContainerNode()).on('mouseover', '.slick-header-column',
    // showHeaderToolTip);
    // $(_grid.getContainerNode()).on('mouseout', '.slick-header-column',
    // hideHeaderToolTip);

  }

  /**
   * Destroy plugin.
   */
  function destroy() {
    $(_grid.getCanvasNode()).off('mouseover', showToolTip);
    $(_grid.getCanvasNode()).off('mouseout', hideToolTip);
    $(_grid.getCanvasNode()).off('mouseup', hideAll);
    // $(_grid.getContainerNode()).off('mouseover', '.slick-header-column',
    // showHeaderToolTip);
    // $(_grid.getContainerNode()).off('mouseout', '.slick-header-column',
    // hideHeaderToolTip);

  }

  /**
   * Handle mouse entering grid cell to add/remove tooltip.
   *
   * @param {jQuery.Event}
   *            e - The event
   */
  function hideToolTip(e) {
    var cell = _grid.getCellFromEvent(e);
    if (cell) {
      var $node = $(_grid.getCellNode(cell.row, cell.cell));
      if ($node.data('bs.tooltip')) {
        $node.tooltip('hide');
      }
    }
  }

  function hideAll() {
    $(_grid.getCanvasNode()).find('[data-original-title]').attr(
      'data-original-title', '').tooltip('hide');

  }

  function hideHeaderToolTip(e) {
    var $node = $(e.target);
    if ($node.data('bs.tooltip')) {
      $node.tooltip('hide');
    }
  }

  function showHeaderToolTip(e) {
    var show = false;
    var $node = $(e.target);

    if (($node[0].scrollWidth > $node[0].offsetWidth)) {
      show = true;
      var $name = $node.find('.slick-column-name');
      if (!$node.data('bs.tooltip')) {
        $node.tooltip({
          placement: 'auto',
          html: true,
          container: 'body',
          trigger: 'manual'
        });
      }
      $node.attr('data-original-title', $name.text());
      if (show) {
        $node.tooltip('show');
      } else {
        $node.tooltip('hide');
      }
    }
  }

  function showToolTip(e) {
    var cell = _grid.getCellFromEvent(e);
    if (cell) {
      var $node = $(_grid.getCellNode(cell.row, cell.cell));
      var text = '';
      var c = _grid.getColumns()[cell.cell];
      var show = false;
      var $checkNode = $node.find('.slick-cell-wrapper');
      if (c.alwaysShowTooltip
        || ($checkNode[0].scrollWidth > $checkNode[0].offsetWidth)) {
        var item = _grid.getDataItem(cell.row);
        text = c.tooltip(item, c.getter(item));
        show = true;
      }
      $node.attr('data-original-title', text);
      var hasTip = $node.data('bs.tooltip');
      if (!hasTip) {
        $node.tooltip({
          placement: 'auto',
          html: true,
          container: 'body',
          trigger: 'manual'
        });
      }
      if (show) {
        $node.tooltip('show');
      } else if (hasTip) {
        $node.tooltip('hide');
      }
    }
  }

  /**
   * Handle mouse entering header cell to add/remove tooltip.
   *
   * @param {jQuery.Event}
   *            e - The event
   * @param {object}
   *            args.column - The column definition
   */
  function handleHeaderMouseEnter(e, args) {
    var column = args.column, $node = $(e.target).closest(
      '.slick-header-column');
    if (!column.toolTip) {
      $node.attr('title',
        ($node.innerWidth() < $node[0].scrollWidth) ? column.name
          : '');
    }
  }

  // Public API
  $.extend(this, {
    'init': init,
    'destroy': destroy
  });

};

morpheus.CombinedGridFilter = function () {
  this.filters = [];
};
morpheus.CombinedGridFilter.prototype = {
  add: function (filter) {
    this.filters.push(filter);
  },
  getFilters: function () {
    return this.filters;
  },
  get: function (index) {
    return this.filters[index];
  },
  set: function (index, f) {
    this.filters[index] = f;
  },
  init: function () {
    for (var i = 0; i < this.filters.length; i++) {
      this.filters[i].init();
    }

    this.activeFilters = this.filters.filter(function (f) {
      return !f.isEmpty();
    });
    this.nActiveFilters = this.activeFilters.length;
  },
  accept: function (item) {
    for (var i = 0; i < this.nActiveFilters; i++) {
      if (!this.activeFilters[i].accept(item)) {
        return false;
      }
    }
    return true;
  },
  isEmpty: function () {
    return this.activeFilters.length === 0;
  }
};

morpheus.HeatMapColorSchemeChooser = function (options) {
  var _this = this;
  this.$div = $('<div></div>');
  this.currentValue = null;
  this.legend = new morpheus.LegendWithStops();
  this.colorScheme = options.colorScheme || new morpheus.HeatMapColorScheme(new morpheus.Project(new morpheus.Dataset({
      rows: 0,
      columns: 0
    })));
  this.legend.on('added', function (e) {
    var fractions = _this.colorScheme.getFractions();
    fractions.push(e.fraction);
    var colors = _this.colorScheme.getColors();
    colors.push('black');
    _this.colorScheme.setFractions({
      fractions: fractions,
      colors: colors
    });
    var newIndex = _this.getFractionIndex(e.fraction, 'black');
    _this.setSelectedIndex(newIndex);
    _this.fireChanged();
  }).on('selectedIndex', function (e) {
    _this.setSelectedIndex(e.selectedIndex);
  }).on('delete', function (index) {
    _this.deleteSelectedStop();
  }).on(
    'moved',
    function (e) {
      var fraction = e.fraction;
      var fractions = _this.colorScheme.getFractions();
      fractions[_this.legend.selectedIndex] = fraction;
      var color = _this.colorScheme.getColors()[_this.legend.selectedIndex];
      _this.colorScheme.setFractions({
        fractions: fractions,
        colors: _this.colorScheme.getColors()
      });
      _this.legend.selectedIndex = _this.getFractionIndex(e.fraction, color);
      var fractionToValue = d3.scale.linear().domain([0, 1])
        .range(
          [_this.colorScheme.getMin(),
            _this.colorScheme.getMax()])
        .clamp(true);
      _this.formBuilder.setValue('selected_value',
        fractionToValue(fractions[_this.legend.selectedIndex]));
      _this.fireChanged();
    });
  var $row = $('<div></div>');
  $row.css('height', '50px').css('width', '300px').css('margin-left', 'auto')
    .css('margin-right', 'auto');
  $row.appendTo(this.$div);

  $(this.legend.canvas).appendTo($row);
  var formBuilder = new morpheus.FormBuilder();
  var items = [];
  items = items.concat({
    name: 'selected_color',
    type: 'color',
    col: 'col-xs-2'
  }, {
    name: 'selected_value',
    type: 'text',
    col: 'col-xs-4'
  }, [{
    name: 'delete',
    type: 'button',
    value: 'Delete Selected Color Stop',
  }, {
    name: 'add',
    type: 'button',
    value: 'Add Color Stop'
  }], {
    name: 'minimum',
    type: 'text',
    col: 'col-xs-4'
  }, {
    name: 'maximum',
    type: 'text',
    col: 'col-xs-4'
  });
  if (options.showRelative) {
    items = items.concat({
      name: 'relative_color_scheme',
      type: 'checkbox',
      help: 'A relative color scheme uses the minimum and maximum values in each row' +
      ' to convert values to colors'
    });
    items = items.concat({
      name: 'transform_values',
      type: 'select',
      value: 0,
      options: [{
        name: 'None',
        value: 0
      }, {
        name: 'Subtract row mean, divide by row standard deviation',
        value: morpheus.AbstractColorSupplier.Z_SCORE
      }, {
        name: 'Subtract row median, divide by row median absolute deviation',
        value: morpheus.AbstractColorSupplier.ROBUST_Z_SCORE
      }]
    });
  }

  items = items.concat({
    name: 'missing_color',
    type: 'color',
    col: 'col-xs-2'
  });
  items
    .push({
      name: 'stepped_colors',
      type: 'checkbox',
      value: false,
      help: 'Intervals include left end point and exclude right end point, except for the highest interval'
    });
  _.each(items, function (item) {
    formBuilder.append(item);
  });
  this.getFractionIndex = function (fraction, color) {
    var fractions = _this.colorScheme.getFractions();
    var colors = _this.colorScheme.getColors();
    for (var i = 0, len = fractions.length; i < len; i++) {
      if (fractions[i] === fraction && colors[i] === color) {
        return i;
      }
    }
    return -1;
  };
  this.$div.append(formBuilder.$form);
  formBuilder.$form.find('[name^=selected],[name=delete]').prop('disabled',
    true);
  formBuilder.$form.find('[name=add]').on('click', function (e) {
    var fractions = _this.colorScheme.getFractions();
    var val = 0.5;
    while (val >= 0 && _.indexOf(fractions, val) !== -1) {
      val -= 0.1;
    }
    val = Math.max(0, val);
    fractions.push(val);
    var colors = _this.colorScheme.getColors();
    colors.push('black');
    _this.colorScheme.setFractions({
      fractions: fractions,
      colors: colors
    });
    var newIndex = _this.getFractionIndex(e.fraction, 'black');
    _this.setSelectedIndex(newIndex);
    _this.fireChanged();
  });
  formBuilder.$form.find('[name=delete]').on('click', function (e) {
    _this.deleteSelectedStop();
  });
  formBuilder.$form.find('[name=transform_values]').on('change', function (e) {
    _this.colorScheme.setTransformValues(parseInt(formBuilder.getValue('transform_values')));
    _this.fireChanged();
  });
  formBuilder.$form.on('keyup', '[name=selected_value]', _.debounce(function (e) {
    var val = parseFloat($(this).val());
    if (!isNaN(val)) {
      _this.setSelectedValue(val);
      _this.fireChanged();
    }
  }, 100));
  formBuilder.$form.on('change', '[name=selected_color]', function (e) {
    var colors = _this.colorScheme.getColors();
    colors[_this.legend.selectedIndex] = $(this).val();
    _this.colorScheme.setFractions({
      fractions: _this.colorScheme.getFractions(),
      colors: colors
    });
    _this.fireChanged();
  });
  formBuilder.$form.on('change', '[name=missing_color]', function (e) {
    var color = $(this).val();
    _this.colorScheme.setMissingColor(color);
    _this.fireChanged(false);
  });
  formBuilder.$form.on('change', '[name=stepped_colors]', function (e) {
    _this.colorScheme.setStepped($(this).prop('checked'));
    _this.fireChanged();
  });
  formBuilder.$form.on('keyup', '[name=minimum]', _.debounce(function (e) {
    var val = parseFloat($(this).val());
    if (!isNaN(val)) {
      _this.colorScheme.setMin(val);
      _this.setSelectedIndex(_this.legend.selectedIndex);
      _this.fireChanged(false);
    }
  }, 100));
  formBuilder.$form.on('keyup', '[name=maximum]', _.debounce(function (e) {
    var val = parseFloat($(this).val());
    if (!isNaN(val)) {
      _this.colorScheme.setMax(val);
      _this.setSelectedIndex(_this.legend.selectedIndex);
      _this.fireChanged(false);
    }

  }, 100));
  formBuilder.$form
    .on(
      'change',
      '[name=relative_color_scheme]',
      _
        .throttle(
          function (e) {
            _this.legend.selectedIndex = -1;
            // FIXME set fixed min and max
            var scalingMode = $(this).prop('checked') ? morpheus.HeatMapColorScheme.ScalingMode.RELATIVE
              : morpheus.HeatMapColorScheme.ScalingMode.FIXED;
            _this.colorScheme
              .setScalingMode(scalingMode);
            _this.setColorScheme(_this.colorScheme);
            _this.fireChanged();
          }, 100));
  this.formBuilder = formBuilder;
  // selection: delete, color, value
  // general: add, min, max, relative or global
};
morpheus.HeatMapColorSchemeChooser.prototype = {
  deleteSelectedStop: function () {
    var fractions = this.colorScheme.getFractions();
    fractions.splice(this.legend.selectedIndex, 1);
    var colors = this.colorScheme.getColors();
    colors.splice(this.legend.selectedIndex, 1);
    this.colorScheme.setFractions({
      fractions: fractions,
      colors: colors
    });
    this.formBuilder.$form.find('[name^=selected],[name=delete]').prop(
      'disabled', true);
    this.legend.setSelectedIndex(-1);
    this.fireChanged();
  },
  setSelectedValue: function (val) {
    var valueToFraction = d3.scale.linear().domain(
      [this.colorScheme.getMin(), this.colorScheme.getMax()])
      .range([0, 1]).clamp(true);
    var fractions = this.colorScheme.getFractions();
    var fraction = valueToFraction(val);
    fractions[this.legend.selectedIndex] = fraction;
    var color = this.colorScheme.getColors()[this.legend.selectedIndex];
    this.colorScheme.setFractions({
      fractions: fractions,
      colors: this.colorScheme.getColors()
    });
    this.legend.selectedIndex = this.getFractionIndex(fraction, color);
  },
  setSelectedIndex: function (index) {
    var fractions = this.colorScheme.getFractions();
    if (index >= fractions.length) {
      index = -1;
    }
    this.legend.setSelectedIndex(index);
    var formBuilder = this.formBuilder;
    formBuilder.$form.find('[name^=selected],[name=delete]').prop(
      'disabled', this.legend.selectedIndex === -1);
    if (this.legend.selectedIndex !== -1) {
      var fractionToValue = d3.scale.linear().domain([0, 1]).range(
        [this.colorScheme.getMin(), this.colorScheme.getMax()])
        .clamp(true);
      formBuilder.setValue('selected_value',
        fractionToValue(fractions[this.legend.selectedIndex]));
      var context = this.legend.canvas.getContext('2d');
      var colors = this.colorScheme.getColors();
      context.fillStyle = colors[this.legend.selectedIndex];
      formBuilder.setValue('selected_color', context.fillStyle);
    } else {
      formBuilder.setValue('selected_value', '');
    }
    this.draw();
  },
  setMinMax: function () {
    if (this.colorScheme.getScalingMode() === morpheus.HeatMapColorScheme.ScalingMode.RELATIVE) {
      this.colorScheme.setMin(0);
      this.colorScheme.setMax(1);
    }
  },
  dispose: function () {
    this.off('change');
    this.legend.destroy();
    this.formBuilder.$form.off('keyup', 'input');
    this.formBuilder.$form.off('change', '[name=relative_color_scheme]');
  },
  restoreCurrentValue: function () {
    if (this.colorScheme.setCurrentValue) {
      this.colorScheme.setCurrentValue(this.currentValue);
    }
  },
  setCurrentValue: function (value) {
    this.currentValue = value;
    if (this.colorScheme && this.colorScheme.setCurrentValue) {
      this.colorScheme.setCurrentValue(this.currentValue);
    }
    this.setColorScheme(this.colorScheme);
  },
  setColorScheme: function (colorScheme) {
    this.colorScheme = colorScheme;
    this.setMinMax();
    if (colorScheme.setCurrentValue) {
      colorScheme.setCurrentValue(this.currentValue);
    }
    this.formBuilder
      .setValue(
        'relative_color_scheme',
        colorScheme.getScalingMode() === morpheus.HeatMapColorScheme.ScalingMode.RELATIVE ? true
          : false);
    this.formBuilder.setValue('transform_values', colorScheme.getTransformValues());
    this.formBuilder.setEnabled('transform_values', colorScheme.getScalingMode() !== morpheus.HeatMapColorScheme.ScalingMode.RELATIVE);

    this.formBuilder.$form
      .find('[name=minimum],[name=maximum]')
      .prop(
        'disabled',
        colorScheme.getScalingMode() === morpheus.HeatMapColorScheme.ScalingMode.RELATIVE);
    this.formBuilder.setValue('minimum', this.colorScheme.getMin());
    this.formBuilder.setValue('maximum', this.colorScheme.getMax());
    this.formBuilder.setValue('stepped_colors', this.colorScheme
      .isStepped());
    this.formBuilder.setValue('missing_color', this.colorScheme
      .getMissingColor());
    this.draw();
  },
  getFractionToStopPix: function () {
    return d3.scale.linear().clamp(true).domain([0, 1]).range(
      [this.legend.border,
        this.legend.getUnscaledWidth() - this.legend.border]);
  },
  fireChanged: function (noreset) {
    this.trigger('change');
    if (noreset !== false) {
      this.setColorScheme(this.colorScheme);
    }
  },
  draw: function () {
    var colorScheme = this.colorScheme;
    if (colorScheme.getScalingMode() === morpheus.HeatMapColorScheme.ScalingMode.RELATIVE) {
      colorScheme.setMin(0);
      colorScheme.setMax(1);
    }
    var fractions = colorScheme.getFractions();
    var colors = colorScheme.getColors();
    var fractionToStopPix = this.getFractionToStopPix();
    this.legend.draw(fractions, colors, colorScheme.isStepped(),
      fractionToStopPix);
  }
};
morpheus.Util.extend(morpheus.HeatMapColorSchemeChooser, morpheus.Events);

morpheus.HeatMapColorSchemeLegend = function (heatMap, $keyContent) {
  var colorScheme = heatMap.heatmap.getColorScheme();
  var colorByValues = colorScheme.getColorByValues();
  var totalHeight;
  $keyContent.empty();
  var ntracks = colorByValues.length;
  colorByValues
    .forEach(function (value) {
      if (value != null || ntracks === 1) {
        if (value != 'null') { // values are stored as string
          var $label = $('<div style="overflow:hidden;text-overflow:' +
            ' ellipsis;width:250px;max-width:250px;">'
            + value + '</div>');
          $keyContent.append($label);
          totalHeight += $label.height();
        }
        var trackLegend = new morpheus.ColorSupplierLegend(
          colorScheme, value);
        $(trackLegend.canvas).css('position', '');
        trackLegend.repaint();
        trackLegend.on('selectionChanged', function () {
          heatMap.heatmap.setInvalid(true);
          heatMap.heatmap.repaint();
        });
        $keyContent.append($(trackLegend.canvas));
        totalHeight += trackLegend.getUnscaledHeight();
      }
    });
  if (heatMap.options.$key) {
    $keyContent.append(heatMap.options.$key);
    totalHeight += heatMap.options.$key.height();

  }
  var $edit = $('<div style="padding-left:4px; display:inline;"><a data-name="options"' +
    ' href="#">Edit</a></div>');

  $edit.find('[data-name=options]').on('click', function (e) {
    e.preventDefault();
    heatMap.showOptions();
    morpheus.Util.trackEvent({
      eventCategory: 'ToolBar',
      eventAction: 'options'
    });
  });
  totalHeight += $edit.height();
  $keyContent.append($edit);
  $keyContent.css({
    'text-overflow': 'ellipsis',
    overflow: 'hidden',
    width: 250 + 'px',
    height: totalHeight + 'px'
  });
};

morpheus.HeatMapColorSchemeLegend.drawColorScheme = function (context,
                                                              colorScheme, width, printing, hideText, legendHeight) {
  if (!legendHeight) {
    legendHeight = 12;
  }
  context.font = '11px ' + morpheus.CanvasUtil.FONT_NAME;
  var names = colorScheme.getNames();
  var hasNames = names != null;
  // if hasNames that we draw vertically to ensure space for names
  if (hasNames) {
    morpheus.HeatMapColorSchemeLegend.drawColorSchemeVertically(context,
      colorScheme, colorScheme.getHiddenValues(), printing);
  } else {
    morpheus.HeatMapColorSchemeLegend.draw(context, colorScheme
        .getFractions(), colorScheme.getColors(), width, legendHeight,
      colorScheme.isStepped());
    context.strokeStyle = 'LightGrey';
    context.strokeRect(0, 0, width, legendHeight);
    if (hideText) {
      return;
    }
    var map = d3.scale.linear().domain([0, 1]).range([0, width]).clamp(
      true);
    var fractionToValue = d3.scale.linear().domain([0, 1]).range(
      [colorScheme.getMin(), colorScheme.getMax()]).clamp(true);
    context.textAlign = 'center';
    context.textBaseline = 'top';
    context.fillStyle = 'black';

    if (colorScheme.getScalingMode() === morpheus.HeatMapColorScheme.ScalingMode.RELATIVE) {
      context.fillText('row min', 0, 14);
      context.fillText('row max', width, legendHeight + 2);
    } else {
      var fractions = colorScheme.getFractions();
      var lastTextPixEnd = -1;
      // draw from left to middle and then from right to middle to avoid
      // text overlap
      var halfway = parseInt(fractions.length / 2);

      for (var i = 0; i < halfway; i++) {
        var pix = map(fractions[i]);
        var text = '';
        if (hasNames) {
          text = names[i] != '' ? (names[i] + ' ('
          + fractionToValue(fractions[i]) + ')') : names[i];
        } else {
          text = morpheus.Util.nf(fractionToValue(fractions[i]));
        }
        var textWidth = context.measureText(text).width;
        if (pix > lastTextPixEnd) {
          context.fillText(text, pix, legendHeight + 2);
        }
        lastTextPixEnd = pix + textWidth / 2;
      }
      var lastTextPixStart = 10000;
      for (var i = fractions.length - 1; i >= halfway; i--) {
        var pix = map(fractions[i]);
        var text = '';
        if (hasNames) {
          text = names[i] != '' ? (names[i] + ' ('
          + fractionToValue(fractions[i]) + ')') : names[i];
        } else {
          text = morpheus.Util.nf(fractionToValue(fractions[i]));
        }

        var textWidth = context.measureText(text).width;
        var textPixEnd = pix + textWidth / 2;
        if (textPixEnd < lastTextPixStart) {
          context.fillText(text, pix, legendHeight + 2);
          lastTextPixStart = pix - textWidth / 2;
        }
      }
    }
  }
};
morpheus.HeatMapColorSchemeLegend.drawColorSchemeVertically = function (context,
                                                                        colorScheme, hiddenValues, printing) {
  var fractionToValue = d3.scale.linear().domain([0, 1]).range(
    [colorScheme.getMin(), colorScheme.getMax()]).clamp(true);
  context.textAlign = 'left';
  context.textBaseline = 'top';
  context.fillStyle = 'black';
  var fractions = colorScheme.getFractions();
  var colors = colorScheme.getColors();
  var names = colorScheme.getNames();
  context.strokeStyle = 'LightGrey';
  var xpix = 0;
  var ypix = 0;

  context.font = '12px ' + morpheus.CanvasUtil.FONT_NAME;
  for (var i = 0; i < colors.length; i++) {
    var name = names[i];
    if (name != null) {
      context.fillStyle = colors[i];
      context.fillRect(xpix, ypix, 12, 12);
      context.strokeRect(xpix, ypix, 12, 12);
      context.fillStyle = morpheus.CanvasUtil.FONT_COLOR;
      if (hiddenValues && !printing) {
        var value = fractionToValue(fractions[i]);
        context.font = '12px FontAwesome';
        if (!hiddenValues.has(value)) {
          context.fillText('\uf00c', -14, ypix); // checked
        }
        // else {
        // context.fillText("\uf096", -14, ypix); // unchecked
        // }
        context.font = '12px ' + morpheus.CanvasUtil.FONT_NAME;
      }
      context.fillText(name, xpix + 16, ypix);
    }
    ypix += 14;
  }
};
morpheus.HeatMapColorSchemeLegend.draw = function (context, fractions, colors,
                                                   width, height, stepped) {
  if (!stepped) {
    var gradient = context.createLinearGradient(0, 0, width, height);
    for (var i = 0, length = fractions.length; i < length; i++) {
      gradient.addColorStop(fractions[i], colors[i]);
    }
    context.fillStyle = gradient;
    context.fillRect(0, 0, width, height);
  } else {
    // intervals include left end point, exclude right end point, except for
    // the highest interval
    // TODO right-most endpoint is not shown
    var map = d3.scale.linear().domain([0, 1]).range([0, width]).clamp(
      true);
    for (var i = 0, length = fractions.length; i < length; i++) {
      context.fillStyle = colors[i];
      var x1 = map(fractions[i]);
      var x2 = i === length - 1 ? width : map(fractions[i + 1]);
      context.fillRect(Math.min(x1, x2), 0, Math.abs(x2 - x1), height);
    }
  }
};

morpheus.ColorSupplierLegend = function (colorScheme, value) {
  morpheus.AbstractCanvas.call(this, false);
  var _this = this;
  this.value = value;
  this.colorScheme = colorScheme;
  colorScheme.setCurrentValue(value);
  var hiddenValues = colorScheme.getHiddenValues();

  var names = colorScheme.getNames();
  var hasNames = names != null;
  var legendHeight = hasNames ? names.length * 14 : 30;
  var bounds = {
    width: 250,
    height: legendHeight
  };
  this.hasNames = hasNames;
  this.setBounds(bounds);
  if (hasNames && hiddenValues) {
    $(this.canvas)
      .on(
        'click',
        function (e) {
          e.preventDefault();
          e.stopPropagation();
          var clickedRow = Math
            .floor((e.clientY - _this.canvas
                .getBoundingClientRect().top) / 14);
          var fractionToValue = d3.scale.linear().domain(
            [0, 1]).range(
            [colorScheme.getMin(),
              colorScheme.getMax()]).clamp(true);
          var fractions = colorScheme.getFractions();
          var value = fractionToValue(fractions[clickedRow]);
          if (!hiddenValues.has(value)) {
            hiddenValues.add(value);
          } else {
            hiddenValues.remove(value);

          }
          _this.trigger('selectionChanged');
          _this.repaint();
        });
  }
};

morpheus.ColorSupplierLegend.prototype = {
  draw: function (clip, context) {
    var colorScheme = this.colorScheme;
    colorScheme.setCurrentValue(this.value);
    // context.fillStyle = 'white';
    // context.fillRect(0, 0, this.getUnscaledWidth(), this
    // .getUnscaledHeight());
    context.translate(this.hasNames ? 14
      : (this.getUnscaledWidth() - 200) / 2, 0);
    morpheus.HeatMapColorSchemeLegend.drawColorScheme(context, colorScheme,
      200);

  }

};
morpheus.Util.extend(morpheus.ColorSupplierLegend, morpheus.Events);
morpheus.Util.extend(morpheus.ColorSupplierLegend,
  morpheus.AbstractCanvas);






/**
 * @param type
 *            Either relative or fixed.
 * @param stops
 *            An array of objects with value and color
 */
morpheus.HeatMapColorScheme = function (project, scheme) {
  this.project = project;
  var that = this;

  this.separateColorSchemeForRowMetadataField = null;
  this.rowValueToColorSupplier = {};
  this.value = null;
  if (scheme) {
    if (scheme.valueToColorScheme) { // json representation
      this.fromJSON(scheme);
    } else {
      this.rowValueToColorSupplier[null] = morpheus.HeatMapColorScheme
        .createColorSupplier(scheme);
      this.currentColorSupplier = this.rowValueToColorSupplier[this.value];
    }
  }
  project
    .on(
      'rowFilterChanged columnFilterChanged rowSortOrderChanged columnSortOrderChanged datasetChanged',
      function () {
        that.projectUpdated();
      });
  this.projectUpdated();
};
morpheus.HeatMapColorScheme.Predefined = {};
morpheus.HeatMapColorScheme.Predefined.SUMMLY = function () {
  return {
    name: '(-100, -97.5, -95, 95, 97.5, 100)',
    type: 'fixed',
    map: [{
      value: -100,
      color: '#0000ff'
    }, {
      value: -97.5,
      color: '#abdda4'
    }, {
      value: -95,
      color: '#ffffff'
    }, {
      value: 95,
      color: '#ffffff'
    }, {
      value: 97.5,
      color: '#fdae61'
    }, {
      value: 100,
      color: '#ff0000'
    }]
  };
};

morpheus.HeatMapColorScheme.Predefined.SUMMLY2 = function () {
  return {
    name: '(-100, -95, -90, 90, 95, 100)',
    type: 'fixed',
    map: [{
      value: -100,
      color: '#0000ff'
    }, {
      value: -95,
      color: '#abdda4'
    }, {
      value: -90,
      color: '#ffffff'
    }, {
      value: 90,
      color: '#ffffff'
    }, {
      value: 95,
      color: '#fdae61'
    }, {
      value: 100,
      color: '#ff0000'
    }]
  };
};

morpheus.HeatMapColorScheme.Predefined.SUMMLY3 = function () {
  return {
    type: 'fixed',
    map: [{
      value: -100,
      color: '#0000ff'
    }, {
      value: -90,
      color: '#abdda4'
    }, {
      value: -80,
      color: '#e6f598'
    }, {
      value: -70,
      color: '#ffffff'
    }, {
      value: 70,
      color: '#ffffff'
    }, {
      value: 80,
      color: '#fee08b'
    }, {
      value: 90,
      color: '#fdae61'
    }, {
      value: 100,
      color: '#ff0000'
    }]
  };
};

morpheus.HeatMapColorScheme.Predefined.CN = function () {
  return {
    type: 'fixed',
    map: [{
      value: -2,
      color: '#0000ff'
    }, {
      value: -0.1,
      color: '#ffffff'
    }, {
      value: 0.1,
      color: '#ffffff'
    }, {
      value: 2,
      color: '#ff0000'
    }]
  };
};
morpheus.HeatMapColorScheme.Predefined.BINARY = function () {
  return {
    type: 'fixed',
    map: [{
      value: 0,
      color: '#ffffff'
    }, {
      value: 1,
      color: 'black'
    }]
  };
};
morpheus.HeatMapColorScheme.Predefined.RELATIVE = function () {
  return {
    type: 'relative'
  };
};
morpheus.HeatMapColorScheme.Predefined.MAF = function () {
  // coMut plot colors

  var canvas = document.createElement('canvas');
  var ctx = canvas.getContext('2d');
  var toHex = function (rgb) {
    ctx.fillStyle = rgb;
    return ctx.fillStyle;
  };

  return {
    type: 'fixed',
    stepped: true,
    map: [{
      value: 0,
      color: toHex('rgb(' + [255, 255, 255].join(',') + ')')
    }, {
      value: 1,
      color: toHex('rgb(' + [77, 175, 74].join(',') + ')'),
      name: 'Synonymous'
    }, {
      value: 2,
      color: toHex('rgb(' + [255, 255, 51].join(',') + ')'),
      name: 'In Frame Indel'
    }, {
      value: 3,
      color: toHex('rgb(' + [166, 86, 40].join(',') + ')'),
      name: 'Other Non-Synonymous'
    }, {
      value: 4,
      color: toHex('rgb(' + [55, 126, 184].join(',') + ')'),
      name: 'Missense'
    }, {
      value: 5,
      color: toHex('rgb(' + [152, 78, 163].join(',') + ')'),
      name: 'Splice Site'
    }, {
      value: 6,
      color: toHex('rgb(' + [255, 127, 0].join(',') + ')'),
      name: 'Frame Shift'
    }, {
      value: 7,
      color: toHex('rgb(' + [228, 26, 28].join(',') + ')'),
      name: 'Nonsense'
    }]
  };
};
// morpheus.HeatMapColorScheme.Predefined.MAF_NEW = function() {
// // Synonymous 1
// //In_frame_Indel 2
// //Other_non_syn. 3
// //Missense 4
// //Splice_Site 5
// //Frame_Shift 6
// //Nonsense 7
// return {
// type : 'fixed',
// stepped : true,
// map : [ {
// value : 0,
// color : 'rgb(' + [ 255, 255, 255 ].join(',') + ')',
// name : ''
// }, {
// value : 1,
// color : 'rgb(' + [ 255, 255, 179 ].join(',') + ')',
// name : 'Silent'
// }, {
// value : 2,
// color : 'rgb(' + [ 69, 117, 180 ].join(',') + ')',
// name : 'In Frame Indel'
// }, {
// value : 3,
// color : 'rgb(' + [ 247, 182, 210 ].join(',') + ')',
// name : 'Other Non-Synonymous'
// }, {
// value : 4,
// color : 'rgb(' + [ 1, 133, 113 ].join(',') + ')',
// name : 'Missense'
// }, {
// value : 5,
// color : 'rgb(' + [ 253, 180, 98 ].join(',') + ')',
// name : 'Splice Site'
// }, {
// value : 6,
// color : 'rgb(' + [ 140, 81, 10 ].join(',') + ')',
// name : 'Frame Shift'
// }, {
// value : 7,
// color : 'rgb(' + [ 123, 50, 148 ].join(',') + ')',
// name : 'Nonsense'
// } ]
// };
// };
morpheus.HeatMapColorScheme.Predefined.ZS = function () {
  return {
    type: 'fixed',
    map: [{
      value: -10,
      color: '#0000ff'
    }, {
      value: -2,
      color: '#ffffff'
    }, {
      value: 2,
      color: '#ffffff'
    }, {
      value: 10,
      color: '#ff0000'
    }]
  };
};
morpheus.HeatMapColorScheme.ScalingMode = {
  RELATIVE: 0,
  FIXED: 1
};

morpheus.HeatMapConditions = function () {
  this.array = [];
  // each condition is a object with: series, shape, color and
  // accept(val) function

};
morpheus.HeatMapConditions.prototype = {
  insert: function (index, c) {
    this.array.splice(index, 0, c);
  },
  add: function (c) {
    this.array.push(c);
  },
  getConditions: function () {
    return this.array;
  },
  remove: function (index) {
    this.array.splice(index, 1);
  },
  copy: function () {
    var c = new morpheus.HeatMapConditions();
    this.array.forEach(function (cond) {
      c.array.push(_.clone(cond));
    });
    return c;
  }
};

morpheus.HeatMapColorScheme.createColorSupplier = function (options) {
  var type = options.type;
  var stepped = options.stepped;
  var map = options.map;
  var scalingMode;
  var min = 0;
  var max = 1;
  if (type === 'fixed') {
    scalingMode = morpheus.HeatMapColorScheme.ScalingMode.FIXED;
    if (map) { // get min/max
      min = Number.MAX_VALUE;
      max = -Number.MAX_VALUE;
      for (var i = 0; i < map.length; i++) {
        min = Math.min(min, map[i].value);
        max = Math.max(max, map[i].value);
      }
    }
  } else {
    scalingMode = morpheus.HeatMapColorScheme.ScalingMode.RELATIVE;
  }

  var fractions = [];
  var colors = [];
  var names = [];
  var hasNames = false;
  if (map) {
    var valueToFraction = d3.scale.linear().domain(
      [min, max]).range(
      [0, 1]).clamp(true);

    for (var i = 0; i < map.length; i++) {
      fractions.push(valueToFraction(map[i].value));
      colors.push(map[i].color);
      var name = map[i].name;
      if (!hasNames && name !== undefined) {
        hasNames = true;
      }
      names.push(name);
    }
  }

  var json = {
    stepped: options.stepped,
    scalingMode: scalingMode,
    fractions: fractions,
    colors: colors,
    names: hasNames ? names : null,
    min: min,
    max: max,
    transformValues: options.transformValues
  };
  if (options.missingColor != null) {
    json.missingColor = options.missingColor;
  }

  if (options.conditions != null) {
    json.conditions = options.conditions;
  }
  if (options.size != null) {
    json.size = options.size;
  }
  return morpheus.AbstractColorSupplier.fromJSON(json);
};
morpheus.HeatMapColorScheme.prototype = {
  getColors: function () {
    return this.currentColorSupplier.getColors();
  },
  setMissingColor: function (color) {
    this.currentColorSupplier.setMissingColor(color);
  },
  getHiddenValues: function () {
    return this.currentColorSupplier.getHiddenValues ? this.currentColorSupplier
      .getHiddenValues()
      : null;
  },
  getMissingColor: function () {
    return this.currentColorSupplier.getMissingColor();
  },
  getScalingMode: function () {
    return this.currentColorSupplier.getScalingMode();
  },
  getSizer: function () {
    return this.currentColorSupplier.getSizer();
  },
  getConditions: function () {
    return this.currentColorSupplier.getConditions();
  },
  setScalingMode: function (scalingMode) {
    this.currentColorSupplier.setScalingMode(scalingMode);
  },
  getFractions: function () {
    return this.currentColorSupplier.getFractions();
  },
  getNames: function () {
    return this.currentColorSupplier.getNames();
  },
  getMin: function () {
    return this.currentColorSupplier.getMin();
  },
  getMax: function () {
    return this.currentColorSupplier.getMax();
  },
  setMin: function (min) {
    this.currentColorSupplier.setMin(min);
  },
  setMax: function (max) {
    this.currentColorSupplier.setMax(max);
  },
  isStepped: function () {
    return this.currentColorSupplier.isStepped();
  },
  setFractions: function (options) {
    this.currentColorSupplier.setFractions(options);
  },
  setTransformValues: function (options) {
    this.currentColorSupplier.setTransformValues(options);
    this.cachedRowStats.cachedRow = -1;
  },
  getTransformValues: function () {
    return this.currentColorSupplier.getTransformValues();
  },
  setStepped: function (stepped) {
    var oldColorSupplier = this.currentColorSupplier;
    var newColorSupplier = stepped ? new morpheus.SteppedColorSupplier()
      : new morpheus.GradientColorSupplier();
    newColorSupplier.sizer = oldColorSupplier.getSizer();
    newColorSupplier.array = oldColorSupplier.getConditions();
    newColorSupplier.setScalingMode(oldColorSupplier.getScalingMode());
    newColorSupplier.setMin(oldColorSupplier.getMin());
    newColorSupplier.setMax(oldColorSupplier.getMax());
    newColorSupplier.setFractions({
      fractions: oldColorSupplier.getFractions(),
      colors: oldColorSupplier.getColors()
    });
    this.currentColorSupplier = newColorSupplier;
    this.rowValueToColorSupplier[this.value] = this.currentColorSupplier;
  },
  toJSON: function () {
    var json = {};
    var _this = this;
    if (this.separateColorSchemeForRowMetadataField != null) {
      json.separateColorSchemeForRowMetadataField = this.separateColorSchemeForRowMetadataField;
    }
    json.valueToColorScheme = {};
    _.each(_.keys(this.rowValueToColorSupplier), function (key) {
      // save each scheme
      json.valueToColorScheme[key] = morpheus.AbstractColorSupplier.toJSON(_this.rowValueToColorSupplier[key]);
    });

    return json;
  },
  fromJSON: function (json) {
    var _this = this;
    if (json.separateColorSchemeForRowMetadataField) {
      this.separateColorSchemeForRowMetadataField = json.separateColorSchemeForRowMetadataField;
      this.vector = this.project.getSortedFilteredDataset()
        .getRowMetadata().getByName(
          this.separateColorSchemeForRowMetadataField);
    }
    this.rowValueToColorSupplier = {};
    var obj = json.valueToColorScheme || json.colorSchemes;
    _.each(_.keys(obj), function (key) {
      var colorSupplier = morpheus.AbstractColorSupplier
        .fromJSON(obj[key]);
      _this.rowValueToColorSupplier[key] = colorSupplier;
    });
    this._ensureColorSupplierExists();

  },
  copy: function (project) {
    var _this = this;
    var c = new morpheus.HeatMapColorScheme(project);
    c.separateColorSchemeForRowMetadataField = this.separateColorSchemeForRowMetadataField;
    if (c.separateColorSchemeForRowMetadataField != null) {
      c.vector = project.getSortedFilteredDataset().getRowMetadata()
        .getByName(c.separateColorSchemeForRowMetadataField);

    }
    if (c.vector == null) {
      c.separateColorSchemeForRowMetadataField = null;
    }
    _.each(_.keys(this.rowValueToColorSupplier), function (key) {
      c.rowValueToColorSupplier[key] = _this.rowValueToColorSupplier[key]
        .copy();
    });

    c.value = this.value;
    c.currentColorSupplier = c.rowValueToColorSupplier[c.value];

    return c;
  },
  setSeparateColorSchemeForRowMetadataField: function (separateColorSchemeForRowMetadataField) {
    if (separateColorSchemeForRowMetadataField != this.separateColorSchemeForRowMetadataField) {
      this.separateColorSchemeForRowMetadataField = separateColorSchemeForRowMetadataField;
      this.vector = this.project.getSortedFilteredDataset()
        .getRowMetadata().getByName(
          separateColorSchemeForRowMetadataField);
      var that = this;
      _.each(_.keys(this.rowValueToColorSupplier), function (key) {
        // remove old color schemes
        delete that.rowValueToColorSupplier[key];
      });
    }
  },
  getProject: function () {
    return this.project;
  },
  getSeparateColorSchemeForRowMetadataField: function () {
    return this.separateColorSchemeForRowMetadataField;
  },
  getColorByValues: function () {
    return _.keys(this.rowValueToColorSupplier);
  },
  projectUpdated: function () {
    var dataset = this.project.getSortedFilteredDataset();
    if (this.separateColorSchemeForRowMetadataField != null) {
      this.vector = this.project.getSortedFilteredDataset()
        .getRowMetadata().getByName(
          this.separateColorSchemeForRowMetadataField);
    }
    this.cachedRowStats = new morpheus.RowStats(dataset);
  },
  setColorSupplierForCurrentValue: function (colorSupplier) {
    this.rowValueToColorSupplier[this.value] = colorSupplier;
    this.currentColorSupplier = colorSupplier;
  },
  setCurrentValue: function (value) {
    this.value = value;
    this._ensureColorSupplierExists();
  },
  isSizeBy: function () {
    this.currentColorSupplier.isSizeBy();
  },
  getColor: function (row, column, val) {
    if (this.vector !== undefined) {
      var tmp = this.vector.getValue(row);
      if (this.value !== tmp) {
        this.value = tmp;
        this._ensureColorSupplierExists();
      }
    }
    if (this.currentColorSupplier.getScalingMode() === morpheus.HeatMapColorScheme.ScalingMode.RELATIVE) {
      if (this.cachedRowStats.maybeUpdateRelative(row)) {
        this.currentColorSupplier
          .setMin(this.cachedRowStats.rowCachedMin);
        this.currentColorSupplier
          .setMax(this.cachedRowStats.rowCachedMax);
      }
    } else if (this.currentColorSupplier.getTransformValues() && this.cachedRowStats.cachedRow !== row) {
      this.cachedRowStats.cacheTransformValues(row, this.currentColorSupplier.getTransformValues());
      val = (val - this.cachedRowStats.rowCachedMean) / this.cachedRowStats.rowCachedStandardDeviation;
    }
    return this.currentColorSupplier.getColor(row, column, val);
  },
  /**
   * @private
   */
  _ensureColorSupplierExists: function () {
    this.currentColorSupplier = this.rowValueToColorSupplier[this.value];
    if (this.currentColorSupplier === undefined) {
      var cs = morpheus.HeatMapColorScheme.createColorSupplier({
        type: 'relative'
      });
      this.rowValueToColorSupplier[this.value] = cs;
      this.currentColorSupplier = cs;
    }
  }
};
morpheus.RowStats = function (dataset) {
  this.datasetRowView = new morpheus.DatasetRowView(dataset);
  this.cachedRow = -1;
  this.rowCachedMax = 0;
  this.rowCachedMin = 0;
  this.rowCachedStandardDeviation = -1;
  this.rowCachedMean = -1;
};
morpheus.RowStats.prototype = {
  cacheTransformValues: function (row, transform) {
    var meanFunction = transform === morpheus.AbstractColorSupplier.Z_SCORE ? morpheus.Mean : morpheus.Median;
    var stdevFunction = transform === morpheus.AbstractColorSupplier.Z_SCORE ? morpheus.StandardDeviation : morpheus.MAD;
    this.datasetRowView.setIndex(row);
    this.rowCachedMean = meanFunction(this.datasetRowView);
    this.rowCachedStandardDeviation = stdevFunction(this.datasetRowView, this.rowCachedMean);
  },
  maybeUpdateRelative: function (row) {
    if (this.cachedRow !== row) {
      this.cachedRow = row;
      this.datasetRowView.setIndex(row);
      this.rowCachedMax = -Number.MAX_VALUE;
      this.rowCachedMin = Number.MAX_VALUE;
      for (var j = 0, ncols = this.datasetRowView.size(); j < ncols; j++) {
        var d = this.datasetRowView.getValue(j);
        if (!isNaN(d)) {
          this.rowCachedMax = d > this.rowCachedMax ? d
            : this.rowCachedMax;
          this.rowCachedMin = d < this.rowCachedMin ? d
            : this.rowCachedMin;
        }
      }
      if (this.rowCachedMin === this.rowCachedMax) {
        this.rowCachedMin--;
      }
      return true;
    }
    return false;
  }
};

morpheus.HeatMapSynchronizer = function () {
  this.controllers = [];
};
morpheus.HeatMapSynchronizer.prototype = {
  firing: false,
  getProject: function () {
    return this.controllers[0].getProject();
  },
  zoom: function () {
    this.controllers[0].zoom.apply(this.controllers[0], arguments);
  },
  setTrackVisible: function () {
    this.controllers[0].setTrackVisible.apply(this.controllers[0],
      arguments);
  },
  revalidate: function () {
    this.controllers[0].revalidate.apply(this.controllers[0], arguments);
  },
  add: function (heatMap) {
    var that = this;
    this.controllers.push(heatMap);
    // setQuickSearchField, setTrackVisible, removeTrack, updateDataset, zoom, moveTrack, resizeTrack, paintAll, fitToWindow, revalidate, setToolTip, setMousePosition
    heatMap.on('change', function (event) {
      if (!that.firing) {
        var source = event.source;
        var method = event.name;
        that.firing = true;
        _.each(that.controllers, function (c) {
          if (c !== source) {
            c[method].apply(c, event.arguments);
          }
        });
        that.firing = false;
      }
    });
  }
};

morpheus.HeatMapElementCanvas = function (project) {
  morpheus.AbstractCanvas.call(this, true);
  var _this = this;
  this.colorScheme = null;
  this.project = project;
  this.dataset = null;
  this.columnPositions = new morpheus.Positions();
  this.rowPositions = new morpheus.Positions();
  this.lastPosition = {
    left: -1,
    right: -1,
    top: -1,
    bottom: -1
  };
  this.selectedRowElements = [];
  this.selectedColumnElements = [];
  project.getElementSelectionModel().on('selectionChanged', function (e) {
    _this.repaint();
  });
  this.gridColor = morpheus.HeatMapElementCanvas.GRID_COLOR;
  this.gridThickness = 0.1;
  this.elementDrawCallback = null;
  this.drawCallback = null;
};
morpheus.HeatMapElementCanvas.GRID_COLOR = '#808080';
morpheus.HeatMapElementCanvas.prototype = {
  drawGrid: true,
  drawValues: false,
  setPropertiesFromParent: function (parentHeatMapElementCanvas) {
    this.drawGrid = parentHeatMapElementCanvas.drawGrid;
    this.gridThickness = parentHeatMapElementCanvas.gridThickness;
    this.gridColor = parentHeatMapElementCanvas.gridColor;
    this.drawValues = parentHeatMapElementCanvas.drawValues;
  },
  updateRowSelectionCache: function (repaint) {
    this.selectedRowElements = morpheus.HeatMapElementCanvas.getSelectedSpans(this.project.getRowSelectionModel().getViewIndices());
    if (repaint) {
      this.repaint();
    }
  },
  updateColumnSelectionCache: function (repaint) {
    this.selectedColumnElements = morpheus.HeatMapElementCanvas.getSelectedSpans(this.project.getColumnSelectionModel().getViewIndices());
    if (repaint) {
      this.repaint();
    }
  },
  setGridColor: function (gridColor) {
    this.gridColor = gridColor;
  },
  getGridColor: function () {
    return this.gridColor;
  },
  setGridThickness: function (gridThickness) {
    this.gridThickness = gridThickness;
  },
  getGridThickness: function () {
    return this.gridThickness;
  },
  getColorScheme: function () {
    return this.colorScheme;
  },
  isDrawGrid: function () {
    return this.drawGrid;
  },
  setDrawGrid: function (drawGrid) {
    this.drawGrid = drawGrid;
  },
  setDrawValues: function (drawValues) {
    this.drawValues = drawValues;
  },
  isDrawValues: function () {
    return this.drawValues;
  },
  setColorScheme: function (colorScheme) {
    this.colorScheme = colorScheme;
  },
  setDataset: function (dataset) {
    this.dataset = dataset;
    this.columnPositions.setLength(this.dataset.getColumnCount());
    this.rowPositions.setLength(this.dataset.getRowCount());
    this.updateRowSelectionCache(false);
    this.updateColumnSelectionCache(false);
  },
  getColumnPositions: function () {
    return this.columnPositions;
  },
  getRowPositions: function () {
    return this.rowPositions;
  },
  getPreferredSize: function (context) {
    var w = Math.ceil(this.columnPositions.getPosition(this.columnPositions
          .getLength() - 1)
      + this.columnPositions.getItemSize(this.columnPositions
          .getLength() - 1));
    var h = Math.ceil(this.rowPositions.getPosition(this.rowPositions
          .getLength() - 1)
      + this.rowPositions
        .getItemSize(this.rowPositions.getLength() - 1));
    return {
      width: Math.max(12, w),
      height: Math.max(12, h)
    };
  },
  prePaint: function (clip, context) {
    var lastPosition = this.lastPosition;
    var columnPositions = this.columnPositions;
    var rowPositions = this.rowPositions;
    var left = morpheus.Positions.getLeft(clip, columnPositions);
    var right = morpheus.Positions.getRight(clip, columnPositions);
    var top = morpheus.Positions.getTop(clip, rowPositions);
    var bottom = morpheus.Positions.getBottom(clip, rowPositions);
    if (this.invalid || left !== lastPosition.left
      || right !== lastPosition.right || top !== lastPosition.top
      || bottom !== lastPosition.bottom) {
      lastPosition.right = right;
      lastPosition.left = left;
      lastPosition.top = top;
      lastPosition.bottom = bottom;
      this.invalid = true;
    }
  },
  postPaint: function (clip, context) {
    // draw mouse over stuff
    morpheus.CanvasUtil.resetTransform(context);
    var project = this.project;
    context.strokeStyle = 'Grey';
    context.lineWidth = 1;
    var rowPositions = this.getRowPositions();
    var columnPositions = this.getColumnPositions();
    if (project.getHoverColumnIndex() >= 0
      || project.getHoverRowIndex() >= 0) {

      var height = rowPositions
        .getItemSize(project.getHoverColumnIndex());
      var width = columnPositions.getItemSize(project
        .getHoverColumnIndex());
      var y = (project.getHoverRowIndex() === -1 ? rowPositions
        .getPosition(rowPositions.getLength() - 1) : rowPositions
        .getPosition(project.getHoverRowIndex()));
      var x = (project.getHoverColumnIndex() === -1 ? columnPositions
        .getPosition(0) : columnPositions.getPosition(project
        .getHoverColumnIndex()));

      if (project.getHoverColumnIndex() !== -1) {
        // thin rectangle down entire column
        context.strokeRect(x - clip.x, 0, width, this
          .getUnscaledHeight());
      }
      if (project.getHoverRowIndex() !== -1) {
        // thin rectangle across entire row
        context.strokeRect(0, y - clip.y, this.getUnscaledWidth(),
          height);
      }
      if (project.getHoverColumnIndex() !== -1
        && project.getHoverRowIndex() !== -1) {
        context.strokeStyle = 'black';
        context.lineWidth = 3;
        context.strokeRect(x - clip.x + 1.5, y - clip.y + 1.5,
          width - 1.5, height - 1.5);
        if (project.isSymmetric()) {
          var y2 = rowPositions.getPosition(project.getHoverColumnIndex());
          var x2 = columnPositions.getPosition(project.getHoverRowIndex());
          context.strokeRect(x2 - clip.x + 1.5, y2 - clip.y + 1.5,
            width - 1.5, height - 1.5);
        }

      }
    }
    var left = morpheus.Positions.getLeft(clip, columnPositions);
    var right = morpheus.Positions.getRight(clip, columnPositions);
    var top = morpheus.Positions.getTop(clip, rowPositions);
    var bottom = morpheus.Positions.getBottom(clip, rowPositions);

    context.strokeStyle = 'rgb(0,0,0)';
    context.lineWidth = 2;
    // context.fillRect(0, 0, this.canvas.width, this.canvas.height);
    context.translate(-clip.x, -clip.y);
    var selectedElements = project.getElementSelectionModel()
      .getViewIndices();

    if (selectedElements != null) {
      selectedElements.forEach(function (id) {
        var rowIndex = id.getArray()[0];
        var columnIndex = id.getArray()[1];
        if (rowIndex >= top && rowIndex < bottom && columnIndex >= left
          && columnIndex < right) {
          var rowSize = rowPositions.getItemSize(rowIndex);
          var py = rowPositions.getPosition(rowIndex);
          var columnSize = columnPositions.getItemSize(columnIndex);
          var px = columnPositions.getPosition(columnIndex);
          context.strokeRect(px + 1.5, py + 1.5, columnSize - 1.5,
            rowSize - 1.5);

        }
      });
    }
    // draw selection bounding boxes
    context.strokeStyle = 'rgb(182,213,253)';
    var selectedRowElements = this.selectedRowElements;
    var selectedColumnElements = this.selectedColumnElements;

    if (!(selectedRowElements.length === 0 &&
      selectedColumnElements.length === 0)) {
      if (selectedRowElements.length === 0) {
        selectedRowElements = [[top, bottom - 1]];
      }
      if (selectedColumnElements.length === 0) {
        selectedColumnElements = [[left, right - 1]];
      }
    }
    var nrows = selectedRowElements.length;
    var ncols = selectedColumnElements.length;

    if (nrows !== 0 || ncols !== 0) {
      for (var i = 0; i < nrows; i++) {
        var r = selectedRowElements[i];
        var y1 = rowPositions.getPosition(r[0]);
        var y2 = rowPositions.getPosition(r[1]) + rowPositions.getItemSize(i);
        for (var j = 0; j < ncols; j++) {
          var c = selectedColumnElements[j];
          var x1 = columnPositions.getPosition(c[0]);
          var x2 = columnPositions.getPosition(c[1]) + columnPositions.getItemSize(j);
          context.strokeRect(x1, y1, x2 - x1, y2 - y1);
        }
      }
    }
  },
  setElementDrawCallback: function (elementDrawCallback) {
    this.elementDrawCallback = elementDrawCallback;
  },
  setDrawCallback: function (drawCallback) {
    this.drawCallback = drawCallback;
  },
  draw: function (clip, context) {
    var columnPositions = this.columnPositions;
    var rowPositions = this.rowPositions;
    var left = morpheus.Positions.getLeft(clip, columnPositions);
    var right = morpheus.Positions.getRight(clip, columnPositions);
    var top = morpheus.Positions.getTop(clip, rowPositions);
    var bottom = morpheus.Positions.getBottom(clip, rowPositions);
    if (this.dataset.getRowCount() === 0 || this.dataset.getColumnCount() === 0) {
      return context.fillText('No data', 0, 6);
    } else {
      context.translate(-clip.x, -clip.y);
      this._draw({
        left: left,
        right: right,
        top: top,
        bottom: bottom,
        context: context
      });
      context.translate(clip.x, clip.y);
    }
    if (this.drawCallback) {
      this.drawCallback({
        clip: clip,
        context: context
      });
    }

  },
  _draw: function (options) {
    var left = options.left;
    var right = options.right;
    var top = options.top;
    var bottom = options.bottom;
    var context = options.context;

    var columnPositions = this.columnPositions;
    var rowPositions = this.rowPositions;
    //if (rowPositions.getSize() < 1 || columnPositions.getSize() < 1) {
    //force sub-pixel rendering
    context.getImageData(0, 0, 1, 1);
    //}

    context.textAlign = 'center';
    context.textBaseline = 'middle';
    var dataset = this.dataset;

    var colorScheme = this.colorScheme;
    var drawGrid = this.drawGrid;
    var elementDrawCallback = this.elementDrawCallback;
    var hasElementDrawCallback = elementDrawCallback != null;
    var drawValues = this.drawValues && columnPositions.getSize() > 7 && rowPositions.getSize() > 7;
    var nf;
    if (drawValues) {
      nf = typeof d3 !== 'undefined' ? d3.format('.2f') : function (d) {
        return '' + d;
      };
      var fontSize = rowPositions.getSize() - 2;
      context.font = fontSize + 'px ' + morpheus.CanvasUtil.FONT_NAME;
      var textWidth = context.measureText('-9999.99').width;
      fontSize = ((  rowPositions.getSize() - 2) / textWidth) * fontSize;
      context.font = fontSize + 'px ' + morpheus.CanvasUtil.FONT_NAME;
    }
    var seriesNameToIndex = {};
    for (var i = 0; i < dataset.getSeriesCount(); i++) {
      seriesNameToIndex[dataset.getName(i)] = i;
    }
    var sizer;
    var sizeBySeriesName;
    var sizeBySeriesIndex;

    var conditions;
    var conditionSeriesIndices;
    var minSize = 2;
    for (var row = top; row < bottom; row++) {
      var rowSize = rowPositions.getItemSize(row);
      var py = rowPositions.getPosition(row);
      for (var column = left; column < right; column++) {
        var columnSize = columnPositions.getItemSize(column);
        var px = columnPositions.getPosition(column);
        var value = dataset.getValue(row, column);
        context.fillStyle = colorScheme.getColor(row, column, value);
        if (column === left) { // check if the color scheme for this
          // row is sizing
          sizer = colorScheme.getSizer();
          sizeBySeriesName = sizer.getSeriesName();
          sizeBySeriesIndex = sizeBySeriesName != null ? seriesNameToIndex[sizeBySeriesName]
            : undefined;
          conditionSeriesIndices = [];
          conditions = colorScheme.getConditions().getConditions();
          for (var ci = 0, nconditions = conditions.length; ci < nconditions; ci++) {
            conditionSeriesIndices
              .push(seriesNameToIndex[conditions[ci].series]);
          }

        }
        var yoffset = 0;
        var xoffset = 0;
        var cellRowSize = rowSize;
        var cellColumnSize = columnSize;
        if (sizeBySeriesIndex !== undefined) {
          var sizeByValue = dataset.getValue(row, column,
            sizeBySeriesIndex);
          if (!isNaN(sizeByValue)) {
            var f = sizer.valueToFraction(sizeByValue);
            cellRowSize = Math.min(rowSize, Math.max(minSize, cellRowSize * f));
            yoffset = rowSize - cellRowSize;

          }
        }
        if (conditions.length > 0) {
          var condition = null;
          for (var ci = 0, nconditions = conditions.length; ci < nconditions; ci++) {
            var cond = conditions[ci];
            var condValue = dataset.getValue(row, column,
              conditionSeriesIndices[ci]);

            if (!isNaN(condValue) && cond.accept(condValue)) {
              condition = cond;
              break;
            }

          }
          if (condition !== null) {
            if (condition.shape != null) {
              if (condition.inheritColor) {
                var x = px + xoffset + cellRowSize / 2;
                var y = py + yoffset + cellColumnSize / 2;
                morpheus.CanvasUtil.drawShape(context, condition.shape,
                  x, y, Math.min(cellColumnSize, cellRowSize) / 2);
                context.fill();
              } else {
                context.fillRect(px + xoffset, py + yoffset, cellColumnSize,
                  cellRowSize);
                // x and y are at center
                var x = px + xoffset + cellRowSize / 2;
                var y = py + yoffset + cellColumnSize / 2;
                context.fillStyle = condition.color;
                morpheus.CanvasUtil.drawShape(context, condition.shape,
                  x, y, Math.min(cellColumnSize, cellRowSize) / 4);
                context.fill();
              }

            } else {
              context.fillRect(px + xoffset, py + yoffset, cellColumnSize,
                cellRowSize);
            }
          } else {
            context.fillRect(px + xoffset, py + yoffset, cellColumnSize,
              cellRowSize);
          }
        } else {
          context.fillRect(px + xoffset, py + yoffset, cellColumnSize, cellRowSize);
        }
        if (drawValues && cellColumnSize > 7 && cellRowSize > 7) {
          context.fillStyle = 'rgb(0,0,0)';
          context.fillText(nf(value), px + xoffset + cellColumnSize / 2, py + yoffset + cellRowSize / 2, cellColumnSize);
        }
        if (hasElementDrawCallback) {
          elementDrawCallback(context, dataset, row, column, px, py,
            columnSize, rowSize);
        }
      }
    }
    if (drawGrid && rowPositions.getSize() > 10 && columnPositions.getSize() > 10) {
      context.strokeStyle = this.gridColor;
      context.lineWidth = this.gridThickness;
      context.beginPath();

      for (var row = top; row < bottom; row++) {
        var rowSize = rowPositions.getItemSize(row);
        var py = rowPositions.getPosition(row);
        for (var column = left; column < right; column++) {
          var columnSize = columnPositions.getItemSize(column);
          var px = columnPositions.getPosition(column);
          var grid = columnSize > 10 && rowSize > 10;
          if (grid) {
            context.rect(px, py, columnSize, rowSize);
          }
        }
      }
      context.stroke();

    }
    context.lineWidth = 1;
  }
};
morpheus.Util.extend(morpheus.HeatMapElementCanvas, morpheus.AbstractCanvas);

morpheus.HeatMapElementCanvas.getSelectedSpans = function (set) {
  var array = [];
  if (set.size() > 0) {
    var index = 0;
    var start = index;
    var viewIndices = set.values();
    viewIndices.sort(function (a, b) {
      return (a === b ? 0 : (a < b ? -1 : 1));
    });
    var length = viewIndices.length;
    while (index < length) {
      var prior = index === 0 ? viewIndices[0] : viewIndices[index - 1];
      var current = viewIndices[index];
      if ((current - prior) > 1) {
        array.push([viewIndices[start], viewIndices[index - 1]]);
        start = index;
      }
      index++;
    }
    if (start == 0) {
      array.push([viewIndices[0], viewIndices[viewIndices.length - 1]]);
    } else {
      array.push([viewIndices[start], viewIndices[index - 1]]);
    }
  }
  return array;
};

morpheus.KeyboardCharMap = [
  '', // [0]
  '', // [1]
  '', // [2]
  'CANCEL', // [3]
  '', // [4]
  '', // [5]
  'HELP', // [6]
  '', // [7]
  'BACKSPACE', // [8]
  'TAB', // [9]
  '', // [10]
  '', // [11]
  'CLEAR', // [12]
  'ENTER', // [13]
  'ENTER_SPECIAL', // [14]
  '', // [15]
  'SHIFT', // [16]
  'CONTROL', // [17]
  'ALT', // [18]
  'PAUSE', // [19]
  'CAPS_LOCK', // [20]
  'KANA', // [21]
  'EISU', // [22]
  'JUNJA', // [23]
  'FINAL', // [24]
  'HANJA', // [25]
  '', // [26]
  'Escape', // [27]
  'CONVERT', // [28]
  'NONCONVERT', // [29]
  'ACCEPT', // [30]
  'MODECHANGE', // [31]
  'Space', // [32]
  'Page Up', // [33]
  'Page Down', // [34]
  'End', // [35]
  'Home', // [36]
  'Left', // [37]
  'Up', // [38]
  'Right', // [39]
  'Down', // [40]
  'SELECT', // [41]
  'PRINT', // [42]
  'EXECUTE', // [43]
  'PRINTSCREEN', // [44]
  'INSERT', // [45]
  'Delete', // [46]
  '', // [47]
  '0', // [48]
  '1', // [49]
  '2', // [50]
  '3', // [51]
  '4', // [52]
  '5', // [53]
  '6', // [54]
  '7', // [55]
  '8', // [56]
  '9', // [57]
  'COLON', // [58]
  'SEMICOLON', // [59]
  'LESS_THAN', // [60]
  'Equals', // [61]
  'GREATER_THAN', // [62]
  'QUESTION_MARK', // [63]
  'AT', // [64]
  'A', // [65]
  'B', // [66]
  'C', // [67]
  'D', // [68]
  'E', // [69]
  'F', // [70]
  'G', // [71]
  'H', // [72]
  'I', // [73]
  'J', // [74]
  'K', // [75]
  'L', // [76]
  'M', // [77]
  'N', // [78]
  'O', // [79]
  'P', // [80]
  'Q', // [81]
  'R', // [82]
  'S', // [83]
  'T', // [84]
  'U', // [85]
  'V', // [86]
  'W', // [87]
  'X', // [88]
  'Y', // [89]
  'Z', // [90]
  'OS_KEY', // [91] Windows Key (Windows) or Command Key (Mac)
  '', // [92]
  'CONTEXT_MENU', // [93]
  '', // [94]
  'SLEEP', // [95]
  '0', // [96]
  '1', // [97]
  '2', // [98]
  '3', // [99]
  '4', // [100]
  '5', // [101]
  '6', // [102]
  '7', // [103]
  '8', // [104]
  '9', // [105]
  'MULTIPLY', // [106]
  '+', // [107]
  'SEPARATOR', // [108]
  'SUBTRACT', // [109]
  'DECIMAL', // [110]
  'DIVIDE', // [111]
  'F1', // [112]
  'F2', // [113]
  'F3', // [114]
  'F4', // [115]
  'F5', // [116]
  'F6', // [117]
  'F7', // [118]
  'F8', // [119]
  'F9', // [120]
  'F10', // [121]
  'F11', // [122]
  'F12', // [123]
  'F13', // [124]
  'F14', // [125]
  'F15', // [126]
  'F16', // [127]
  'F17', // [128]
  'F18', // [129]
  'F19', // [130]
  'F20', // [131]
  'F21', // [132]
  'F22', // [133]
  'F23', // [134]
  'F24', // [135]
  '', // [136]
  '', // [137]
  '', // [138]
  '', // [139]
  '', // [140]
  '', // [141]
  '', // [142]
  '', // [143]
  'NUM_LOCK', // [144]
  'SCROLL_LOCK', // [145]
  'WIN_OEM_FJ_JISHO', // [146]
  'WIN_OEM_FJ_MASSHOU', // [147]
  'WIN_OEM_FJ_TOUROKU', // [148]
  'WIN_OEM_FJ_LOYA', // [149]
  'WIN_OEM_FJ_ROYA', // [150]
  '', // [151]
  '', // [152]
  '', // [153]
  '', // [154]
  '', // [155]
  '', // [156]
  '', // [157]
  '', // [158]
  '', // [159]
  'CIRCUMFLEX', // [160]
  'EXCLAMATION', // [161]
  'DOUBLE_QUOTE', // [162]
  'HASH', // [163]
  'DOLLAR', // [164]
  'PERCENT', // [165]
  'AMPERSAND', // [166]
  'UNDERSCORE', // [167]
  'OPEN_PAREN', // [168]
  'CLOSE_PAREN', // [169]
  'ASTERISK', // [170]
  'Plus', // [171]
  'PIPE', // [172]
  '-', // [173]
  'OPEN_CURLY_BRACKET', // [174]
  'CLOSE_CURLY_BRACKET', // [175]
  'TILDE', // [176]
  '', // [177]
  '', // [178]
  '', // [179]
  '', // [180]
  'VOLUME_MUTE', // [181]
  'VOLUME_DOWN', // [182]
  'VOLUME_UP', // [183]
  '', // [184]
  '', // [185]
  'SEMICOLON', // [186]
  'EQUALS', // [187]
  'COMMA', // [188]
  'MINUS', // [189]
  'PERIOD', // [190]
  '/', // [191]
  'BACK_QUOTE', // [192]
  '', // [193]
  '', // [194]
  '', // [195]
  '', // [196]
  '', // [197]
  '', // [198]
  '', // [199]
  '', // [200]
  '', // [201]
  '', // [202]
  '', // [203]
  '', // [204]
  '', // [205]
  '', // [206]
  '', // [207]
  '', // [208]
  '', // [209]
  '', // [210]
  '', // [211]
  '', // [212]
  '', // [213]
  '', // [214]
  '', // [215]
  '', // [216]
  '', // [217]
  '', // [218]
  'OPEN_BRACKET', // [219]
  'BACK_SLASH', // [220]
  'CLOSE_BRACKET', // [221]
  'QUOTE', // [222]
  '', // [223]
  'META', // [224]
  'ALTGR', // [225]
  '', // [226]
  'WIN_ICO_HELP', // [227]
  'WIN_ICO_00', // [228]
  '', // [229]
  'WIN_ICO_CLEAR', // [230]
  '', // [231]
  '', // [232]
  'WIN_OEM_RESET', // [233]
  'WIN_OEM_JUMP', // [234]
  'WIN_OEM_PA1', // [235]
  'WIN_OEM_PA2', // [236]
  'WIN_OEM_PA3', // [237]
  'WIN_OEM_WSCTRL', // [238]
  'WIN_OEM_CUSEL', // [239]
  'WIN_OEM_ATTN', // [240]
  'WIN_OEM_FINISH', // [241]
  'WIN_OEM_COPY', // [242]
  'WIN_OEM_AUTO', // [243]
  'WIN_OEM_ENLW', // [244]
  'WIN_OEM_BACKTAB', // [245]
  'ATTN', // [246]
  'CRSEL', // [247]
  'EXSEL', // [248]
  'EREOF', // [249]
  'PLAY', // [250]
  'ZOOM', // [251]
  '', // [252]
  'PA1', // [253]
  'WIN_OEM_CLEAR', // [254]
  '' // [255]
];
morpheus.HeatMapKeyListener = function (heatMap) {
  var allActions = heatMap.getActionManager().getActions();
  var actions = allActions.filter(function (a) {
    return a.cb != null && a.which != null;
  });
  allActions.sort(function (a, b) {
    a = a.name.toLowerCase();
    b = b.name.toLowerCase();
    return (a === b ? 0 : (a < b ? -1 : 1));
  });
  var keydown = function (e) {
    var tagName = e.target.tagName;
    var found = false;
    var commandKey = morpheus.Util.IS_MAC ? e.metaKey : e.ctrlKey;
    var altKey = e.altKey;
    var shiftKey = e.shiftKey;
    var which = e.which;
    var isInputField = (tagName === 'INPUT' || tagName === 'SELECT' || tagName === 'TEXTAREA');
    var acceptOptions = {
      isInputField: isInputField,
      heatMap: heatMap
    };
    var shortcutMatches = function (sc) {
      if (sc.which.indexOf(which) !== -1 && (sc.commandKey === undefined || commandKey === sc.commandKey) && (sc.shiftKey === undefined || shiftKey === sc.shiftKey) && (sc.accept == undefined || sc.accept(acceptOptions))) {
        sc.cb({heatMap: heatMap});
        return true;
      }
    };

    if (!isInputField) {
      for (var i = 0, n = actions.length; i < n; i++) {
        var sc = actions[i];
        if (shortcutMatches(sc)) {
          found = true;
          break;
        }
      }
    } else { // only search global shortcuts
      for (var i = 0, n = actions.length; i < n; i++) {
        var sc = actions[i];
        if (sc.global && shortcutMatches(sc)) {
          found = true;
          break;
        }
      }
    }

    if (found) {
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
      return false;
    }
  };
  var $keyelement = heatMap.$tabPanel;
  $keyelement.on('keydown', keydown);

  $keyelement.on('dragover.morpheus dragenter.morpheus', function (e) {
    e.preventDefault();
    e.stopPropagation();
  }).on(
    'drop.morpheus',
    function (e) {
      if (heatMap.options.menu.File && heatMap.options.menu.File.indexOf('Open') !== -1 && e.originalEvent.dataTransfer
        && e.originalEvent.dataTransfer.files.length) {
        e.preventDefault();
        e.stopPropagation();
        var files = e.originalEvent.dataTransfer.files;
        morpheus.HeatMap.showTool(new morpheus.OpenFileTool({
          file: files[0]
        }), heatMap);
      }
    });
  $keyelement.on('paste.morpheus',
    function (e) {
      if (heatMap.options.toolbar.openFile) {
        var tagName = e.target.tagName;
        if (tagName == 'INPUT' || tagName == 'SELECT'
          || tagName == 'TEXTAREA') {
          return;
        }
        var text = e.originalEvent.clipboardData.getData('text/plain');
        if (text != null && text.length > 0) {
          e.preventDefault();
          e.stopPropagation();
          var blob = new Blob([text]);
          var url = window.URL.createObjectURL(blob);
          morpheus.HeatMap.showTool(new morpheus.OpenFileTool({
            file: url
          }), heatMap);
        }
      }
    });

  $keyelement.on('mousewheel', function (e) {
    var scrolly = e.deltaY * e.deltaFactor;
    var scrollx = e.deltaX * e.deltaFactor;
    var stop = false;
    if (e.altKey) {
      heatMap.zoom(scrolly > 0, {
        rows: true,
        columns: true
      });
      stop = true;
    } else {
      if (scrolly !== 0) {
        var scrollTop = heatMap.scrollTop();
        if (heatMap.scrollTop(scrollTop - scrolly) !== scrollTop) {
          stop = true;
        }
      }
      if (scrollx !== 0) {
        var scrollLeft = heatMap.scrollLeft();
        if (heatMap.scrollLeft(scrollLeft + scrollx) !== scrollLeft) {
          stop = true;
        }
      }
    }
    if (stop) {
      e.preventDefault();
      e.stopPropagation();
    }

  });
  function shortcutToString(sc) {
    var s = ['<b>'];

    if (sc.commandKey) {
      s.push(morpheus.Util.COMMAND_KEY);
    }
    if (sc.shiftKey) {
      s.push('Shift+');
    }
    s.push(morpheus.KeyboardCharMap[sc.which[0]]);

    s.push('</b>');
    return s.join('');
  }

  this.showKeyMapReference = function () {
    var html = [];
    html.push('<table class="table table-condensed">');
    allActions.forEach(function (sc) {
      html.push('<tr><td>');
      html.push(shortcutToString(sc));
      html.push('</td><td>');
      if (sc.icon) {
        html.push('<span class="' + sc.icon + '"></span> ');
      }

      html.push(sc.name);
      html.push('</td></tr>');
    });

    html.push('</table>');
    morpheus.FormBuilder.showInModal({
      title: 'Keymap Reference',
      html: html.join(''),
      focus: document.activeElement
    });
  };
};

morpheus.HeatMapOptions = function (heatMap) {
  var items = [
    {
      name: 'color_by',
      required: true,
      help: 'Use a different color scheme for distinct row annotation values',
      type: 'select',
      options: ['(None)'].concat(morpheus.MetadataUtil
        .getMetadataNames(heatMap.getProject()
          .getFullDataset().getRowMetadata())),
      value: heatMap.heatmap.getColorScheme()
        .getSeparateColorSchemeForRowMetadataField()
    }, {
      name: 'color_by_value',
      required: true,
      type: 'select',
      options: []
    }, {
      name: 'load_predefined_scheme',
      required: true,
      type: 'select',
      options: [{
        name: '',
        value: ''
      }, {
        name: 'relative',
        value: 'gene'
      }, {
        name: 'binary',
        value: 'binary'
      }, {
        name: 'MAF',
        value: 'MAF'
      }, {
        name: 'fixed (-1, -0.5, 0.5, 1)',
        value: 'wtcs'
      }, {
        name: 'fixed (-1.5, -0.1, 0.1, 1.5)',
        value: 'cn'
      }, {
        name: 'fixed ' + morpheus.HeatMapColorScheme.Predefined.SUMMLY2().name,
        value: '100scale2'
      }, {
        name: 'fixed ' + morpheus.HeatMapColorScheme.Predefined.SUMMLY().name,
        value: '100scale1'
      }]
    }, {
      name: 'save_color_scheme',
      type: 'button'
    }, {
      name: 'load_color_scheme',
      type: 'file'
    }];

  items.push({
    name: 'size_by',
    required: true,
    type: 'select',
    options: ['(None)'].concat(morpheus.DatasetUtil
      .getSeriesNames(heatMap.getProject().getFullDataset()))
  });
  items.push({
    name: 'size_by_minimum',
    title: 'Size by minimum',
    required: true,
    type: 'text',
    col: 'col-xs-4'
  });
  items.push({
    name: 'size_by_maximum',
    title: 'Size by maximum',
    required: true,
    type: 'text',
    col: 'col-xs-4'
  });

  items.push({
    name: 'conditional_rendering',
    required: true,
    type: 'button',
    col: 'col-xs-4'
  });

  var displayItems = [
    {
      disabled: heatMap.getProject().getFullDataset().getColumnCount() !== heatMap.getProject().getFullDataset().getRowCount(),
      name: 'link_rows_and_columns',
      required: true,
      type: 'checkbox',
      col: 'col-xs-4',
      value: heatMap.getProject().isSymmetric()
    },
    {
      name: 'show_grid',
      required: true,
      type: 'checkbox',
      value: heatMap.heatmap.isDrawGrid()
    },
    {
      name: 'grid_thickness',
      required: true,
      type: 'text',
      col: 'col-xs-4',
      value: morpheus.Util.nf(heatMap.heatmap.getGridThickness())
    },
    {
      name: 'grid_color',
      required: true,
      type: 'color',
      col: 'col-xs-2',
      value: heatMap.heatmap.getGridColor()
    },
    {
      name: 'row_size',
      required: true,
      type: 'text',
      col: 'col-xs-4',
      value: morpheus.Util.nf(heatMap.heatmap.getRowPositions()
        .getSize())
    },
    {
      name: 'column_size',
      required: true,
      type: 'text',
      col: 'col-xs-4',
      value: morpheus.Util.nf(heatMap.heatmap
        .getColumnPositions().getSize())
    }, {
      name: 'show_values',
      required: true,
      type: 'checkbox',
      value: heatMap.heatmap.isDrawValues()
    }];
  if (heatMap.rowDendrogram) {
    displayItems
      .push({
        name: 'row_dendrogram_line_thickness',
        required: true,
        type: 'text',
        col: 'col-xs-4',
        value: morpheus.Util
          .nf(heatMap.rowDendrogram ? heatMap.rowDendrogram.lineWidth
            : 1)
      });
  }
  if (heatMap.columnDendrogram) {
    displayItems
      .push({
        name: 'column_dendrogram_line_thickness',
        required: true,
        type: 'text',
        col: 'col-xs-4',
        value: morpheus.Util
          .nf(heatMap.columnDendrogram ? heatMap.columnDendrogram.lineWidth
            : 1)
      });
  }

  displayItems.push({
    name: 'info_window',
    required: true,
    type: 'select',
    col: 'col-xs-4',
    options: [{
      name: 'Fixed To Top',
      value: 0
    }, {
      name: 'New Window',
      value: 1
    }],
    value: heatMap.tooltipMode
  });

  displayItems.push({
    name: 'inline_tooltip',
    required: true,
    type: 'checkbox',
    value: heatMap.options.inlineTooltip
  });

  var colorSchemeFormBuilder = new morpheus.FormBuilder();
  _.each(items, function (item) {
    colorSchemeFormBuilder.append(item);
  });
  var displayFormBuilder = new morpheus.FormBuilder();
  _.each(displayItems, function (item) {
    displayFormBuilder.append(item);
  });
  var colorSchemeChooser = new morpheus.HeatMapColorSchemeChooser({
    showRelative: true,
    colorScheme: heatMap.heatmap
      .getColorScheme()
  });
  var updatingSizer = false;

  function colorSchemeChooserUpdated() {
    if (heatMap.heatmap.getColorScheme().getSizer
      && heatMap.heatmap.getColorScheme().getSizer() != null) {
      colorSchemeFormBuilder.setValue('size_by', heatMap.heatmap
        .getColorScheme().getSizer().getSeriesName());
      colorSchemeFormBuilder.setEnabled('size_by_minimum',
        heatMap.heatmap.getColorScheme().getSizer()
          .getSeriesName() != null);
      colorSchemeFormBuilder.setEnabled('size_by_maximum',
        heatMap.heatmap.getColorScheme().getSizer()
          .getSeriesName() != null);

      if (!updatingSizer) {
        colorSchemeFormBuilder.setValue('size_by_minimum',
          heatMap.heatmap.getColorScheme().getSizer().getMin());
        colorSchemeFormBuilder.setValue('size_by_maximum',
          heatMap.heatmap.getColorScheme().getSizer().getMax());
      }
    }
  }

  colorSchemeChooser.on('change', function () {
    colorSchemeChooserUpdated();
    // repaint the heat map when color scheme changes
    heatMap.heatmap.setInvalid(true);
    heatMap.heatmap.repaint();
    colorSchemeChooser.restoreCurrentValue();
  });
  function createMetadataField(isColumns) {
    var options = [];
    var value = {};
    _.each(heatMap.getVisibleTrackNames(isColumns), function (name) {
      value[name] = true;
    });
    _.each(morpheus.MetadataUtil.getMetadataNames(isColumns ? heatMap
        .getProject().getFullDataset().getColumnMetadata() : heatMap
        .getProject().getFullDataset().getRowMetadata()),
      function (name) {
        options.push(name);
      });
    var field = {
      type: 'bootstrap-select',
      search: options.length > 10,
      name: isColumns ? 'column_annotations' : 'row_annotations',
      multiple: true,
      value: value,
      options: options,
      toggle: true
    };

    return field;
  }

  var annotationsBuilder = new morpheus.FormBuilder();
  annotationsBuilder.append(createMetadataField(false));
  annotationsBuilder.append(createMetadataField(true));
  function annotationsListener($select, isColumns) {
    var names = [];
    _.each(heatMap.getVisibleTrackNames(isColumns), function (name) {
      names.push(name);
    });
    var values = $select.val();
    var selectedNow = _.difference(values, names);
    var unselectedNow = _.difference(names, values);
    var tracks = [];
    _.each(selectedNow, function (name) {
      tracks.push({
        name: name,
        isColumns: isColumns,
        visible: true
      });
    });
    _.each(unselectedNow, function (name) {
      tracks.push({
        name: name,
        isColumns: isColumns,
        visible: false
      });
    });
    heatMap.setTrackVisibility(tracks);
    colorSchemeChooser.restoreCurrentValue();
  }

  var $ca = annotationsBuilder.$form.find('[name=column_annotations]');
  $ca.on('change', function (e) {
    annotationsListener($(this), true);
  });
  var $ra = annotationsBuilder.$form.find('[name=row_annotations]');
  $ra.on('change', function (e) {
    annotationsListener($(this), false);
  });
  var annotationOptionsTabId = _.uniqueId('morpheus');
  var heatMapOptionsTabId = _.uniqueId('morpheus');
  var displayOptionsTabId = _.uniqueId('morpheus');

  var $metadataDiv = $('<div class="tab-pane" id="' + annotationOptionsTabId
    + '"></div>');
  $metadataDiv.append($(annotationsBuilder.$form));
  var $heatMapDiv = $('<div class="tab-pane active" id="'
    + heatMapOptionsTabId + '"></div>');
  $heatMapDiv.append(colorSchemeChooser.$div);
  $heatMapDiv.append($(colorSchemeFormBuilder.$form));
  var $displayDiv = $('<div class="tab-pane" id="' + displayOptionsTabId
    + '"></div>');
  $displayDiv.append($(displayFormBuilder.$form));
  displayFormBuilder.setEnabled('grid_thickness', heatMap.heatmap.isDrawGrid());
  displayFormBuilder.setEnabled('grid_color', heatMap.heatmap.isDrawGrid());

  displayFormBuilder.$form.find('[name=show_grid]').on('click', function (e) {
    var grid = $(this).prop('checked');
    displayFormBuilder.setEnabled('grid_thickness', grid);
    displayFormBuilder.setEnabled('grid_color', grid);
    heatMap.heatmap.setDrawGrid(grid);
    heatMap.revalidate();
    colorSchemeChooser.restoreCurrentValue();
  });
  displayFormBuilder.$form.find('[name=show_values]').on('click', function (e) {
    heatMap.heatmap.setDrawValues($(this).prop('checked'));
    heatMap.revalidate();
    colorSchemeChooser.restoreCurrentValue();
  });
  displayFormBuilder.$form.find('[name=inline_tooltip]').on('click',
    function (e) {
      heatMap.options.inlineTooltip = $(this).prop('checked');
    });

  displayFormBuilder.$form.find('[name=grid_color]').on(
    'change',
    function (e) {
      var value = $(this).val();
      heatMap.heatmap.setGridColor(value);
      heatMap.heatmap.setInvalid(true);
      heatMap.heatmap.repaint();
    });

  displayFormBuilder.$form.find('[name=grid_thickness]').on(
    'keyup',
    _.debounce(function (e) {
      var value = parseFloat($(this).val());
      if (!isNaN(value)) {
        heatMap.heatmap.setGridThickness(value);
        heatMap.heatmap.setInvalid(true);
        heatMap.heatmap.repaint();
      }
    }, 100));

  displayFormBuilder.$form.find('[name=row_size]').on(
    'keyup',
    _.debounce(function (e) {
      var value = parseFloat($(this).val());
      if (!isNaN(value)) {
        heatMap.heatmap.getRowPositions().setSize(
          value);
        heatMap.revalidate();
        colorSchemeChooser.restoreCurrentValue();
      }

    }, 100));
  displayFormBuilder.$form.find('[name=info_window]').on('change',
    function (e) {
      heatMap.setTooltipMode(parseInt($(this).val()));
    });
  displayFormBuilder.find('link_rows_and_columns').on('click',
    function (e) {
      var checked = $(this).prop('checked');
      if (checked) {
        heatMap.getProject().setSymmetric(heatMap);
      } else {
        heatMap.getProject().setSymmetric(null);
      }
    });

  var $colorByValue = colorSchemeFormBuilder.$form
    .find('[name=color_by_value]');
  var separateSchemesField = heatMap.heatmap.getColorScheme()
    .getSeparateColorSchemeForRowMetadataField();
  if (separateSchemesField != null) {
    $colorByValue.html(morpheus.Util.createOptions(morpheus.VectorUtil
      .createValueToIndexMap(
        heatMap.project.getFullDataset().getRowMetadata()
          .getByName(separateSchemesField)).keys()));
  }

  if (separateSchemesField != null) {
    colorSchemeChooser.setCurrentValue($colorByValue.val());
  }
  if (heatMap.heatmap.getColorScheme().getSizer
    && heatMap.heatmap.getColorScheme().getSizer() != null
    && heatMap.heatmap.getColorScheme().getSizer().getSeriesName()) {
    colorSchemeFormBuilder.setValue('size_by', heatMap.heatmap
      .getColorScheme().getSizer().getSeriesName());
  }
  colorSchemeFormBuilder.$form.find('[name=size_by]')
    .on(
      'change',
      function (e) {
        var series = $(this).val();
        if (series == '(None)') {
          series = null;
        }
        colorSchemeChooser.colorScheme.getSizer()
          .setSeriesName(series);
        colorSchemeChooser.fireChanged();
      });
  colorSchemeFormBuilder.$form.find('[name=size_by_minimum]').on(
    'keyup',
    _.debounce(function (e) {
      updatingSizer = true;
      colorSchemeChooser.colorScheme.getSizer().setMin(
        parseFloat($(this).val()));
      colorSchemeChooser.fireChanged(true);
      updatingSizer = false;
    }, 100));
  colorSchemeFormBuilder.$form.find('[name=size_by_maximum]').on(
    'keyup',
    _.debounce(function (e) {
      updatingSizer = true;
      colorSchemeChooser.colorScheme.getSizer().setMax(
        parseFloat($(this).val()));
      colorSchemeChooser.fireChanged(true);
      updatingSizer = false;
    }, 100));
  colorSchemeFormBuilder.$form
    .find('[name=conditional_rendering]')
    .on(
      'click',
      function (e) {
        e.preventDefault();
        var conditionalRenderingUI = new morpheus.ConditionalRenderingUI(
          heatMap);
        morpheus.FormBuilder.showInModal({
          title: 'Conditional Rendering',
          html: conditionalRenderingUI.$div,
          close: 'Close',
          modalClass: 'morpheus-sub-modal'
        });
      });

  colorSchemeFormBuilder.find('save_color_scheme').on('click', function (e) {
    e.preventDefault();
    var blob = new Blob([JSON.stringify(heatMap.heatmap.getColorScheme().toJSON())], {
      type: 'application/json'
    });
    saveAs(blob, 'color_scheme.json');
  });
  colorSchemeFormBuilder.on('change', function (e) {
    if (e.name === 'load_color_scheme') {
      if (e.value !== '' && e.value != null) {
        morpheus.Util.getText(e.value).done(
          function (text) {
            var json = JSON.parse($.trim(text));
            heatMap.heatmap.getColorScheme().fromJSON(json);
            colorSchemeChooser
              .setColorScheme(heatMap.heatmap
                .getColorScheme());
            heatMap.heatmap.setInvalid(true);
            heatMap.heatmap.repaint();

          }).fail(function () {
          morpheus.FormBuilder.showInModal({
            title: 'Error',
            html: 'Unable to read saved color scheme.'
          });
        });

      }
    }
  });

  colorSchemeFormBuilder.$form
    .on(
      'change',
      '[name=load_predefined_scheme]',
      function (e) {
        var val = $(this).val();
        if (val !== '') {
          if (val === 'gene') {
            heatMap.heatmap
              .getColorScheme()
              .setColorSupplierForCurrentValue(
                morpheus.HeatMapColorScheme
                  .createColorSupplier(morpheus.HeatMapColorScheme.Predefined
                    .RELATIVE()));
          } else if (val === 'cn') {
            heatMap.heatmap
              .getColorScheme()
              .setColorSupplierForCurrentValue(
                morpheus.HeatMapColorScheme
                  .createColorSupplier(morpheus.HeatMapColorScheme.Predefined
                    .CN()));
          } else if (val === 'wtcs') {
            heatMap.heatmap.getColorScheme()
              .setColorSupplierForCurrentValue(
                morpheus.HeatMapColorScheme
                  .createColorSupplier({
                    type: 'fixed',
                    map: [{
                      value: -1,
                      color: 'blue'
                    }, {
                      value: -0.5,
                      color: 'white'
                    }, {
                      value: 0.5,
                      color: 'white'
                    }, {
                      value: 1,
                      color: 'red'
                    }]
                  }));
          } else if (val === 'MAF') {
            heatMap.heatmap
              .getColorScheme()
              .setColorSupplierForCurrentValue(
                morpheus.HeatMapColorScheme
                  .createColorSupplier(morpheus.HeatMapColorScheme.Predefined
                    .MAF()));
          } else if (val === 'binary') {
            heatMap.heatmap
              .getColorScheme()
              .setColorSupplierForCurrentValue(
                morpheus.HeatMapColorScheme
                  .createColorSupplier(morpheus.HeatMapColorScheme.Predefined
                    .BINARY()));
          } else if (val === '100scale1') {
            heatMap.heatmap
              .getColorScheme()
              .setColorSupplierForCurrentValue(
                morpheus.HeatMapColorScheme
                  .createColorSupplier(morpheus.HeatMapColorScheme.Predefined
                    .SUMMLY()));

          } else if (val === '100scale2') {
            heatMap.heatmap
              .getColorScheme()
              .setColorSupplierForCurrentValue(
                morpheus.HeatMapColorScheme
                  .createColorSupplier(morpheus.HeatMapColorScheme.Predefined
                    .SUMMLY2()));

          } else {
            console.log('not found');
          }
          colorSchemeChooser
            .setColorScheme(heatMap.heatmap
              .getColorScheme());
          heatMap.heatmap.setInvalid(true);
          heatMap.heatmap.repaint();
          $(this).val('');
        } else {
          console.log('empty option selected');
        }
        colorSchemeChooser.restoreCurrentValue();
      });
  colorSchemeFormBuilder.$form
    .find('[name=color_by]')
    .on(
      'change',
      function (e) {
        var colorByField = $(this).val();
        if (colorByField == '(None)') {
          colorByField = null;
        }
        var colorByValue = null;
        heatMap.heatmap.getColorScheme()
          .setSeparateColorSchemeForRowMetadataField(
            colorByField);
        if (colorByField != null) {
          $colorByValue
            .html(morpheus.Util
              .createOptions(morpheus.VectorUtil
                .createValueToIndexMap(
                  heatMap.project
                    .getFullDataset()
                    .getRowMetadata()
                    .getByName(
                      colorByField))
                .keys()));
          colorByValue = $colorByValue.val();
        } else {
          $colorByValue.html('');
        }

        heatMap.heatmap.getColorScheme().setCurrentValue(
          colorByValue);
        colorSchemeChooser.setCurrentValue(colorByValue);
        heatMap.heatmap.setInvalid(true);
        heatMap.heatmap.repaint();
        colorSchemeChooser.setColorScheme(heatMap.heatmap
          .getColorScheme());
      });
  $colorByValue.on('change', function (e) {
    if (heatMap.heatmap.getColorScheme()
        .getSeparateColorSchemeForRowMetadataField() == null) {
      colorSchemeChooser.setCurrentValue(null);
      heatMap.heatmap.getColorScheme().setCurrentValue(null);
      colorSchemeChooser.setColorScheme(heatMap.heatmap
        .getColorScheme());
    } else {
      colorSchemeChooser.setCurrentValue($colorByValue.val());
      colorSchemeChooser.setColorScheme(heatMap.heatmap
        .getColorScheme());
    }
  });
  displayFormBuilder.$form.find('[name=column_size]').on(
    'keyup',
    _.debounce(function (e) {
      heatMap.heatmap.getColumnPositions().setSize(
        parseFloat($(this).val()));
      heatMap.revalidate();
      colorSchemeChooser.restoreCurrentValue();

    }, 100));
  displayFormBuilder.$form.find('[name=gap_size]').on('keyup',
    _.debounce(function (e) {
      heatMap.gapSize = parseFloat($(this).val());
      heatMap.revalidate();
      colorSchemeChooser.restoreCurrentValue();
    }, 100));
  displayFormBuilder.$form.find('[name=squish_factor]').on('keyup',
    _.debounce(function (e) {
      var f = parseFloat($(this).val());
      heatMap.heatmap.getColumnPositions().setSquishFactor(f);
      heatMap.heatmap.getRowPositions().setSquishFactor(f);
      heatMap.revalidate();
      colorSchemeChooser.restoreCurrentValue();
    }, 100));
  displayFormBuilder.$form.find('[name=row_dendrogram_line_thickness]').on(
    'keyup', _.debounce(function (e) {
      heatMap.rowDendrogram.lineWidth = parseFloat($(this).val());
      heatMap.revalidate();
      colorSchemeChooser.restoreCurrentValue();

    }, 100));
  displayFormBuilder.$form.find('[name=column_dendrogram_line_thickness]')
    .on(
      'keyup',
      _.debounce(function (e) {
        heatMap.columnDendrogram.lineWidth = parseFloat($(
          this).val());
        heatMap.revalidate();
        colorSchemeChooser.restoreCurrentValue();
      }, 100));
  var $tab = $('<div class="tab-content"></div>');
  $metadataDiv.appendTo($tab);
  $heatMapDiv.appendTo($tab);
  $displayDiv.appendTo($tab);
  var $div = $('<div></div>');
  var $ul = $('<ul class="nav nav-tabs" role="tablist">' + '<li><a href="#'
    + annotationOptionsTabId
    + '" role="tab" data-toggle="tab">Annotations</a></li>'
    + '<li><a href="#' + heatMapOptionsTabId
    + '" role="tab" data-toggle="tab">Color Scheme</a></li>'
    + '<li><a href="#' + displayOptionsTabId
    + '" role="tab" data-toggle="tab">Display</a></li>' + '</ul>');
  $ul.appendTo($div);
  $tab.appendTo($div);
  // set current scheme
  colorSchemeChooser.setColorScheme(heatMap.heatmap.getColorScheme());
  colorSchemeChooserUpdated();
  $ul.find('[role=tab]:eq(1)').tab('show');
  morpheus.FormBuilder.showInModal({
    title: 'Options',
    html: $div,
    close: 'Close',
    focus: heatMap.getFocusEl(),
    onClose: function () {
      $div.find('input').off('keyup');
      $ca.off('change');
      $ra.off('change');
      $div.remove();
      colorSchemeChooser.dispose();
    }
  });
};

morpheus.HeatMapSizer = function () {
  this.seriesName = null;
  this.sizeByScale = d3.scale.linear().domain([this.min, this.max])
    .range([0, 1]).clamp(true);
};
morpheus.HeatMapSizer.prototype = {
  min: 0,
  max: 1,
  copy: function () {
    var sizer = new morpheus.HeatMapSizer();
    sizer.seriesName = this.seriesName;
    sizer.min = this.min;
    sizer.max = this.max;
    sizer.sizeByScale = this.sizeByScale.copy();
    return sizer;
  },
  valueToFraction: function (value) {
    return this.sizeByScale(value);
  },
  setMin: function (min) {
    this.min = min;
    this.sizeByScale = d3.scale.linear().domain([this.min, this.max])
      .range([0, 1]).clamp(true);
  },
  setMax: function (max) {
    this.max = max;
    this.sizeByScale = d3.scale.linear().domain([this.min, this.max])
      .range([0, 1]).clamp(true);
  },
  getMin: function () {
    return this.min;
  },
  getMax: function () {
    return this.max;
  },
  getSeriesName: function () {
    return this.seriesName;
  },
  setSeriesName: function (name) {
    this.seriesName = name;
  }
};

morpheus.HeatMapToolBar = function (heatMap) {
  this.heatMap = heatMap;
  this.rowSearchResultModelIndices = [];
  this.columnSearchResultModelIndices = [];
  var _this = this;
  var $el = $('<div class="hidden-print container-fluid">'
    + '<div class="row"><div style="padding-left:0px;padding-right:0px;"' +
    ' class="col-xs-12"><div' +
    ' data-name="lineOneColumn"></div></div></div>'
    + '<div class="row"><div class="col-xs-12"><div data-name="tip" style="white-space:nowrap; border-top: thin solid #e7e7e7;margin-bottom:2px;height: 14px; font-size: 10px;overflow:hidden;"></div></div></div>'
    + '</div>');
  var searchHtml = [];
  var $searchForm = $('<form style="display:inline-block;margin-right:14px;" name="searchForm"' +
    ' class="form' +
    ' form-inline' +
    ' form-compact"' +
    ' role="search"></form>');
  $searchForm.on('submit', function (e) {
    e.preventDefault();
  });

  // toogle search buttons
  searchHtml.push('<div title="Toggle' +
    ' Search (' + morpheus.Util.COMMAND_KEY + '/)" class="btn-group"' +
    ' data-toggle="buttons">');
  searchHtml.push('<label class="btn btn-default btn-xxs">');
  searchHtml
    .push('<input data-search="rows" type="radio" autocomplete="off" name="searchToggle"' +
      ' type="button"> Rows');
  searchHtml.push('</label>');

  searchHtml.push('<label class="btn btn-default btn-xxs">');
  searchHtml
    .push('<input data-search="columns" type="radio" autocomplete="off" name="searchToggle"> Columns');
  searchHtml.push('</label>');

  searchHtml.push('<label class="btn btn-default btn-xxs">');
  searchHtml
    .push('<input data-search="values" type="radio" autocomplete="off" name="searchToggle">' +
      ' Values');
  searchHtml.push('</label>');

  searchHtml.push('<label class="btn btn-default btn-xxs">');
  searchHtml
    .push('<input data-search="rowDendrogram" type="radio" autocomplete="off"' +
      ' name="searchToggle"> Row Dendrogram');
  searchHtml.push('</label>');

  searchHtml.push('<label class="btn btn-default btn-xxs">');
  searchHtml
    .push('<input data-search="columnDendrogram" type="radio" autocomplete="off"' +
      ' name="searchToggle"> Column Dendrogram');
  searchHtml.push('</label>');
  searchHtml.push('</div>');

  function createSearchMenu(dataName, navigation) {
    searchHtml.push('<div style="display:inline-block;" data-name="' + dataName + '">');
    searchHtml.push('<div class="form-group">');
    searchHtml.push('<div style="display:inline-block;" class="dropdown">');
    searchHtml
      .push('<button type="button" class="btn btn-default btn-xxs dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"> <span class="fa fa-caret-down"></span></button>');
    searchHtml.push('<ul data-name="searchOptions" class="dropdown-menu">');
    searchHtml.push('<li><a data-group="matchMode" data-name="exact" href="#"><span' +
      ' data-type="toggle"></span>Exact' +
      ' Match</a></li>');
    searchHtml
      .push('<li><a data-group="matchMode" data-name="contains" href="#"><span' +
        ' data-type="toggle"' +
        ' class="dropdown-checkbox fa fa-check"></span>Contains</a></li>');
    searchHtml
      .push('<li role="separator" class="divider"></li>');

    searchHtml
      .push('<li><a data-group="searchMode" data-name="matchAny" href="#"><span' +
        ' data-type="toggle"' +
        ' class="dropdown-checkbox fa fa-check"></span>Match Any Search Term</a></li>');

    searchHtml
      .push('<li><a data-group="searchMode" data-name="matchAll" href="#"><span' +
        ' data-type="toggle"></span>Match All Search Terms</a></li>');

    searchHtml
      .push('<li role="separator" class="divider"></li>');
    searchHtml
      .push('<li><a data-name="searchHelp" href="#">Help</a></li>');
    searchHtml.push('</ul>');
    searchHtml.push('</div>');

    searchHtml.push('<div class="form-group">');
    searchHtml
      .push('<input type="text" class="form-control input-sm" autocomplete="off"' +
        ' name="search">');
    searchHtml.push('</div>');
    searchHtml.push('<div class="form-group">');
    searchHtml.push('<span data-name="searchResultsWrapper" style="display:none;">');
    searchHtml
      .push('<span style="font-size:12px;" data-name="searchResults"></span>');
    if (navigation) {
      searchHtml
        .push('<button name="previousMatch" type="button" class="btn btn-default btn-xxs" data-toggle="tooltip" title="Previous"><i class="fa fa-chevron-up"></i></button>');
      searchHtml
        .push('<button name="nextMatch" type="button" class="btn btn-default btn-xxs" data-toggle="tooltip" title="Next"><i class="fa fa-chevron-down"></i></button>');
      searchHtml
        .push('<button name="matchesToTop" type="button" class="btn btn-default btn-xxs" data-toggle="tooltip" title="Matches To Top"><i class="fa fa-level-up"></i></button>');
    }
    searchHtml.push('</span>');
    searchHtml.push('</div>');
    searchHtml.push('</div>');
    searchHtml.push('</div>');
  }

  if (heatMap.options.toolbar.searchRows) {
    createSearchMenu('searchRowsGroup', true);
  }
  if (heatMap.options.toolbar.searchColumns) {
    createSearchMenu('searchColumnsGroup', true);
  }

  if (heatMap.options.toolbar.searchValues) {
    createSearchMenu('searchValuesGroup', false);
  }
  createSearchMenu('searchRowDendrogramGroup', false);
  createSearchMenu('searchColumnDendrogramGroup', false);

  // dimensions
  if (heatMap.options.toolbar.dimensions) {
    searchHtml.push('<div class="form-group">');
    searchHtml
      .push('<h6 style="display: inline; margin-left:10px;" data-name="dim"></h6>');
    searchHtml
      .push('<h6 style="display: inline; margin-left:10px; background-color:rgb(182,213,253);"' +
        ' data-name="selection"></h6>');
    searchHtml.push('</div>');
  }

  var $menus = $('<div style="display: inline-block;margin-right:14px;"></div>');

  function createMenu(menuName, actions, minWidth) {
    //console.log("HeatMapToolbar.createMenu::", menuName, actions, minWidth);
    if (!minWidth) {
      minWidth = '0px';
    }
    var menu = [];
    var dropdownId = _.uniqueId('morpheus');
    menu.push('<div class="dropdown morpheus-menu">');
    menu.push('<a class="dropdown-toggle morpheus-black-link morpheus-black-link-background" type="button"' +
      ' id="' + dropdownId + '" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true">');
    menu.push(menuName);

    menu.push('</a>');
    menu.push('<ul style="min-width:' + minWidth + ';" class="dropdown-menu" aria-labelledby="' + dropdownId + '">');
    actions.forEach(function (name) {
      if (name == null) {
        menu.push('<li role="separator" class="divider"></li>');
      } else {
        var action = heatMap.getActionManager().getAction(name);
        if (action == null) {
          throw name;
        }
        menu.push('<li>');
        menu.push('<a class="morpheus-menu-item" data-action="' + action.name + '" href="#">');
        menu.push(action.name);
        if (action.icon) {
          menu.push('<span class="' + action.icon + ' morpheus-menu-item-icon"></span> ');
        }
        if (action.which) {
          menu.push('<span class="pull-right">');
          if (action.commandKey) {
            menu.push(morpheus.Util.COMMAND_KEY);
          }
          if (action.shiftKey) {
            menu.push('Shift+');
          }
          menu.push(morpheus.KeyboardCharMap[action.which[0]]);
          menu.push('</span>');
        }

        menu.push('</a>');
        menu.push('</li>');
      }
    });

    menu.push('</ul>');
    menu.push('</div>');
    $(menu.join('')).appendTo($menus);
  }

  console.log("HeatMapToolbar ::", "heatMap:", heatMap, "heatMap.options:", heatMap.options);
  if (heatMap.options.menu) {
    if (heatMap.options.menu.File) {
      createMenu('File', heatMap.options.menu.File, '240px');
    }
    if (heatMap.options.menu.View) {
      createMenu('Edit', heatMap.options.menu.Edit);
    }
    if (heatMap.options.menu.View) {
      createMenu('View', heatMap.options.menu.View);
    }
    if (heatMap.options.menu.Tools) {
      createMenu('Tools', heatMap.options.menu.Tools);
    }
    if (heatMap.options.menu.Help) {
      createMenu('Help', heatMap.options.menu.Help, '200px');
    }
  }

  $(searchHtml.join('')).appendTo($searchForm);
  var $lineOneColumn = $el.find('[data-name=lineOneColumn]');
  $menus.appendTo($lineOneColumn);
  $searchForm.appendTo($lineOneColumn);
  var toolbarHtml = ['<div style="display: inline;">'];
  toolbarHtml.push('<div class="morpheus-button-divider"></div>');
  // zoom
  if (heatMap.options.toolbar.zoom) {
    // toolbarHtml
    // .push('<button type="button" class="btn btn-default btn-xxs" data-toggle="tooltip"' +
    //   ' title="Zoom Out (-)" name="Zoom Out"><span class="fa fa-minus"></span></button>');
    // toolbarHtml
    // .push('<button type="button" class="btn btn-default btn-xxs" data-toggle="tooltip"' +
    //   ' title="Zoom In (+)" name="Zoom In"><span class="fa fa-plus"></span></button>');
    // toolbarHtml
    // .push('<button type="button" class="btn btn-default btn-xxs" data-toggle="tooltip"' +
    //   ' title="Fit To Window" name="Fit To Window"><span class="fa fa-compress"></span></button>');
    // toolbarHtml
    // .push('<button type="button" class="btn btn-default btn-xxs" data-toggle="tooltip"' +
    //   ' title="Reset Zoom" name="Reset Zoom">100%</button>');

    var dropdownId = _.uniqueId('morpheus');
    toolbarHtml.push('<div style="display:inline-block;" class="dropdown">');
    toolbarHtml.push('<a class="dropdown-toggle morpheus-black-link" type="button" id="' + dropdownId + '" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true">');
    // toolbarHtml.push('<input style="width:2em;height:21px;" id="' + dropdownId + '" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true">');
    toolbarHtml.push('<button type="button"' +
      ' class="btn btn-default btn-xxs"><span class="fa' +
      ' fa-search-plus"></span>');
    toolbarHtml.push(' <span style="font-size: .8em;" class="fa fa-caret-down"></span>');
    toolbarHtml.push('</button>');
    toolbarHtml.push('<ul class="dropdown-menu" aria-labelledby="' + dropdownId + '">');
    toolbarHtml
      .push('<li><a class="morpheus-menu-item" href="#" data-action="Zoom Out">Zoom' +
        ' Out<span' +
        ' class="fa' +
        ' fa-minus morpheus-menu-item-icon"></span><span class="pull-right">-</span></a></li>');
    toolbarHtml
      .push('<li><a class="morpheus-menu-item" href="#" data-action="Zoom In">Zoom In<span class="fa' +
        ' fa-plus morpheus-menu-item-icon"></span><span class="pull-right">+</span></a></li>');
    toolbarHtml
      .push('<li role="separator" class="divider"></li>');
    toolbarHtml
      .push('<li><a class="morpheus-menu-item" href="#" data-action="Fit To Window">Fit To Window<span' +
        ' class="fa' +
        ' fa-compress morpheus-menu-item-icon"></span></a></li>');
    toolbarHtml
      .push('<li role="separator" class="divider"></li>');
    toolbarHtml
      .push('<li><a class="morpheus-menu-item" href="#" data-action="Reset Zoom">100%</a></li>');
    toolbarHtml.push('</ul>');
    toolbarHtml.push('</div>');
  }
  toolbarHtml.push('<div class="morpheus-button-divider"></div>');
  if (heatMap.options.toolbar.sort) {
    toolbarHtml
      .push('<button data-toggle="tooltip" title="Sort" name="Sort" type="button" class="btn' +
        ' btn-default btn-xxs"><span class="fa fa-sort-alpha-asc"></span></button>');
  }
  if (heatMap.options.toolbar.options) {
    toolbarHtml
      .push('<button data-action="Options" data-toggle="tooltip" title="Options" type="button"' +
        ' class="btn btn-default btn-xxs"><span class="fa fa-cog"></span></button>');

  }

  toolbarHtml.push('<div class="morpheus-button-divider"></div>');
  if (heatMap.options.toolbar.openFile) {
    toolbarHtml
      .push('<button data-action="Open File" data-toggle="tooltip" title="Open File ('
        + morpheus.Util.COMMAND_KEY
        + 'O)" type="button" class="btn btn-default btn-xxs"><span class="fa fa-folder-open-o"></span></button>');
  }
  if (heatMap.options.toolbar.saveImage) {
    toolbarHtml
      .push('<button data-action="Save Image" data-toggle="tooltip" title="Save Image ('
        + morpheus.Util.COMMAND_KEY
        + 'S)" type="button" class="btn btn-default btn-xxs"><span class="fa fa-file-image-o"></span></button>');
  }
  if (heatMap.options.toolbar.saveDataset) {
    toolbarHtml
      .push('<button data-action="Save Dataset" data-toggle="tooltip" title="Save Dataset ('
        + morpheus.Util.COMMAND_KEY
        + 'Shift+S)" type="button" class="btn btn-default btn-xxs"><span class="fa fa-floppy-o"></span></button>');
  }
  if (heatMap.options.toolbar.saveSession) {
    toolbarHtml
      .push('<button data-action="Save Session" data-toggle="tooltip" title="Save Session" type="button"' +
        ' class="btn btn-default btn-xxs"><span class="fa fa-anchor"></span></button>');
  }

  toolbarHtml.push('<div class="morpheus-button-divider"></div>');
  if (heatMap.options.toolbar.filter) {
    toolbarHtml
      .push('<button data-action="Filter" data-toggle="tooltip" title="Filter" type="button"' +
        ' class="btn btn-default btn-xxs"><span class="fa fa-filter"></span></button>');
  }
  if (heatMap.options.toolbar.chart && typeof Plotly !== 'undefined') {
    toolbarHtml
      .push('<button data-action="Chart" data-toggle="tooltip" title="Chart" type="button" class="btn' +
        ' btn-default btn-xxs"><span class="fa fa-line-chart"></span></button>');

  }
  // legend
  if (heatMap.options.toolbar.colorKey) {
    toolbarHtml.push('<div class="morpheus-button-divider"></div>');
    toolbarHtml.push('<div class="btn-group">');
    toolbarHtml
      .push('<button type="button" class="btn btn-default btn-xxs" data-toggle="dropdown"><span title="Color Key" data-toggle="tooltip" class="fa fa-key"></span></button>');
    //toolbarHtml.push('<')
    toolbarHtml.push('</div>');
    toolbarHtml.push('<div class="morpheus-button-divider"></div>');
  }
  toolbarHtml.push('</div>');
  var $toolbar = $(toolbarHtml.join(''));

  $toolbar.find('[data-action]').on('click', function (e) {
    heatMap.getActionManager().execute($(this).data('action'));
  }).on('blur', function (e) {
    if (document.activeElement === document.body) {
      heatMap.focus();
    }
  });
  $menus.on('click', 'li > a', function (e) {
    e.preventDefault();
    heatMap.getActionManager().execute($(this).data('action'));
  }).on('blur', function (e) {
    if (document.activeElement === document.body) {
      heatMap.focus();
    }
  });
  if (heatMap.options.toolbar.$customButtons) {
    heatMap.options.toolbar.$customButtons.appendTo($toolbar);
  }
  $toolbar.appendTo($lineOneColumn);
  // $hide.appendTo($el.find('[data-name=toggleEl]'));
  $el.prependTo(heatMap.$content);
  this.$tip = $el.find('[data-name=tip]');

  $el.find('[data-toggle="tooltip"]').tooltip({
    placement: 'bottom',
    container: 'body',
    trigger: 'hover'
  }).on('click', function () {
    $(this).tooltip('hide');
  });
  var $key = $el.find('[data-name=key]');
  var $keyContent = $el.find('[data-name=keyContent]');
  $key.dropdown().parent().on('show.bs.dropdown', function () {
    new morpheus.HeatMapColorSchemeLegend(heatMap, $keyContent);
    morpheus.Util.trackEvent({
      eventCategory: 'ToolBar',
      eventAction: 'colorKey'
    });
  });

  var searchHelpHtml = [];
  searchHelpHtml.push('<h4>Symbols</h4>');
  searchHelpHtml.push('<table class="table table-bordered">');
  searchHelpHtml.push('<tr><th>Term</th><th>Description</th></tr>');
  searchHelpHtml.push('<tr><td><code><strong>*</strong></code></td><td>Quote a search term for an' +
    ' exact' +
    ' match. <br' +
    ' />Example: <code><strong>"root beer"</strong></code></td></tr>');

  searchHelpHtml.push('<tr><td><code><strong>-</strong></code></td><td>Exclude matches using -' +
    ' modifier.</td></tr>');
  searchHelpHtml.push('<tr><td><code><strong>..</strong></code></td><td>Separate numbers by two' +
    ' periods' +
    ' without spaces to' +
    ' see numbers that fall within a range.. <br' +
    ' />Example: <code><strong>1..10</strong></code></td></tr>');
  searchHelpHtml.push('<tr><td><code><strong><= < > >= =</strong></code></td><td>Perform a' +
    ' numeric' +
    ' search.' +
    ' <br' +
    ' />Example: <code><strong>>4</strong></code></td></tr>');
  searchHelpHtml.push('</table>');
  searchHelpHtml.push('<h4>Search fields</h4>');
  searchHelpHtml.push('<p>You can restrict your search to any field by typing the field name followed by a colon ":" and then the term you are looking for. For example, to search for matches containing "beer" in the beverage field, you can enter:' +
    ' <code><strong>beverage:beer</strong></code>');
  searchHelpHtml.push('Note that searches only include metadata fields that are displayed. You' +
    ' can search a hidden field by performing a field search.');

  // searchHelpHtml.push('<br />Note: The field is only valid for the term that it directly' +
  // 	' precedes.');
  searchHelpHtml.push('<p>You can search for an exact list of values by enclosing the list of' +
    ' values in parentheses. For example: <code><strong>pet:(cat dog)</strong></code>' +
    ' searches all pets that are either cats or dogs.</p>');
  var $searchHelp = $(searchHelpHtml.join(''));
  $el.find('[data-name=searchHelp]').on('click', function (e) {
    e.preventDefault();
    morpheus.FormBuilder.showInModal({
      title: 'Search Help',
      html: $searchHelp,
      appendTo: heatMap.getContentEl()
    });
  });
  var $searchRowsGroup = $searchForm.find('[data-name=searchRowsGroup]');
  var $searchColumnsGroup = $searchForm.find('[data-name=searchColumnsGroup]');
  var $searchValuesGroup = $searchForm.find('[data-name=searchValuesGroup]');
  var $searchRowDendrogramGroup = $searchForm.find('[data-name=searchRowDendrogramGroup]');
  var $searchColumnDendrogramGroup = $searchForm.find('[data-name=searchColumnDendrogramGroup]');

  this.$searchRowDendrogramGroup = $searchRowDendrogramGroup;
  this.$searchColumnDendrogramGroup = $searchColumnDendrogramGroup;

  var $searchToggle = $searchForm.find('[name=searchToggle]'); // buttons
  var nameToSearchObject = {};

  function getSearchElements($group, searchName, cb) {
    var obj = {
      $group: $group,
      $search: $group.find('[name=search]'),
      $searchResultsWrapper: $group.find('[data-name=searchResultsWrapper]'),
      $searchResults: $group.find('[data-name=searchResults]'),
      $previousMatch: $group.find('[name=previousMatch]'),
      $nextMatch: $group.find('[name=nextMatch]'),
      $matchesToTop: $group.find('[name=matchesToTop]'),
      matchMode: 'contains',
      matchAllPredicates: false,
      $toggleButton: $searchToggle.filter('[data-search=' + searchName + ']').parent()
    };
    var $searchOptions = $group.find('[data-name=searchOptions]');
    $searchOptions.on('click', 'li > a', function (e) {
      e.preventDefault();
      var $this = $(this);
      var group = $this.data('group');
      if (group === 'matchMode') {
        obj.matchMode = $this.data('name');
      } else {
        obj.matchAllPredicates = $this.data('name') === 'matchAll';
      }
      cb();
      var $span = $(this).find('span');
      if ($span.data('type') === 'toggle') {
        $searchOptions.find('[data-group=' + group + '] > [data-type=toggle]').removeClass('dropdown-checkbox' +
          ' fa' +
          ' fa-check');
        $span.addClass('dropdown-checkbox fa fa-check');
      }
      morpheus.Util.trackEvent({
        eventCategory: 'ToolBar',
        eventAction: 'searchMatchMode'
      });
    });
    nameToSearchObject[searchName] = obj;
    return obj;
  }

  this.rowSearchObject = getSearchElements($searchRowsGroup, 'rows', function () {
    _this.search(true);
  });
  this.columnSearchObject = getSearchElements($searchColumnsGroup, 'columns', function () {
    _this.search(false);
  });
  this.rowDendrogramSearchObject = getSearchElements($searchRowDendrogramGroup, 'rowDendrogram', function () {
    _this.searchDendrogram(false);
  });
  this.columnDendrogramSearchObject = getSearchElements($searchColumnDendrogramGroup, 'columnDendrogram', function () {
    _this.searchDendrogram(false);
  });
  this.valueSearchObject = getSearchElements($searchValuesGroup, 'values', function () {
    searchValues();
  });

  // set button and search controls visibility
  if (!heatMap.options.toolbar.searchRows) {
    this.rowSearchObject.$toggleButton.hide();
    this.rowSearchObject.$group.css('display', 'none');
  }

  if (!heatMap.options.toolbar.searchColumns) {
    this.columnSearchObject.$toggleButton.hide();
    this.columnSearchObject.$group.css('display', 'none');
  }
  if (!heatMap.options.toolbar.searchValues) {
    this.valueSearchObject.$toggleButton.hide();
  }
  this.rowDendrogramSearchObject.$toggleButton.hide();
  this.rowDendrogramSearchObject.$group.hide();

  this.columnDendrogramSearchObject.$toggleButton.hide();
  this.columnDendrogramSearchObject.$group.hide();

  this.rowDendrogramSearchObject.$searchResultsWrapper.show();
  this.columnDendrogramSearchObject.$searchResultsWrapper.show();
  this.valueSearchObject.$searchResultsWrapper.show();

  this.rowSearchObject.$search.css({
    'border-top': '3.8px solid #e6e6e6',
    'border-bottom': '3.8px solid #e6e6e6',
    width: '240px'
  });

  this.columnSearchObject.$search.css({
    'border-right': '3.8px solid #e6e6e6',
    'border-left': '3.8px solid #e6e6e6',
    width: '240px'
  });

  this.$valueSearchResults = $searchValuesGroup.find('[name=searchResults]');
  this.$valueTextField = $searchValuesGroup.find('[name=search]');
  this.$dimensionsLabel = $el.find('[data-name=dim]');
  this.$selectionLabel = $el.find('[data-name=selection]');

  $searchToggle.on('change', function (e) {
    var search = $(this).data('search');
    for (var name in nameToSearchObject) {
      var searchObject = nameToSearchObject[name];
      if (name === search) {
        searchObject.$group.css('display', 'inline-block');
        searchObject.$search.focus();
      } else {
        searchObject.$group.css('display', 'none');
      }
    }
  });

  this.toggleSearch = function () {
    var $visible = $searchToggle.filter(':visible');
    var $checked = $searchToggle.filter(':checked');
    var $next = $visible.eq($visible.index($checked) + 1);
    if (!$next.length) {
      $next = $visible.first();
    }
    $next.click();
  };
  for (var i = 0; i < $searchToggle.length; i++) {
    var $button = $($searchToggle[i]);
    if ($button.css('display') === 'block') {
      $button.click();
      break;
    }
  }

  heatMap.on('dendrogramAnnotated', function (e) {
    if (e.isColumns) { // show buttons
      _this.rowDendrogramSearchObject.$toggleButton.show();
    } else {
      _this.columnDendrogramSearchObject.$toggleButton.show();
    }
  });
  heatMap.on('dendrogramChanged', function (e) {
    if (e.isColumns) {
      _this.rowDendrogramSearchObject.$group.hide();
      _this.rowDendrogramSearchObject.$toggleButton.hide();
    } else {
      _this.columnDendrogramSearchObject.$group.hide();
      _this.columnDendrogramSearchObject.$toggleButton.hide();
    }
  });
  var project = heatMap.getProject();

  morpheus.Util.autosuggest({
    $el: this.rowSearchObject.$search,
    filter: function (terms, cb) {
      var indices = [];
      var meta = project.getSortedFilteredDataset().getRowMetadata();
      heatMap.getVisibleTrackNames(false).forEach(function (name) {
        indices.push(morpheus.MetadataUtil.indexOf(meta, name));
      });
      meta = new morpheus.MetadataModelColumnView(meta, indices);
      morpheus.MetadataUtil.autocomplete(meta)(terms, cb);
    },
    select: function () {
      _this.search(true);
    }
  });

  this.rowSearchObject.$search.on('keyup', _.debounce(function (e) {
    if (e.which === 13) {
      e.preventDefault();
    }
    _this.search(true);
    morpheus.Util.trackEvent({
      eventCategory: 'ToolBar',
      eventAction: 'searchRows'
    });
  }, 500));
  morpheus.Util.autosuggest({
    $el: this.columnSearchObject.$search,
    filter: function (terms, cb) {
      var indices = [];
      var meta = project.getSortedFilteredDataset().getColumnMetadata();
      heatMap.getVisibleTrackNames(true).forEach(function (name) {
        indices.push(morpheus.MetadataUtil.indexOf(meta, name));
      });
      meta = new morpheus.MetadataModelColumnView(meta, indices);
      morpheus.MetadataUtil.autocomplete(meta)(terms, cb);
    },
    select: function () {
      _this.search(false);
    }
  });
  this.columnSearchObject.$search.on('keyup', _.debounce(function (e) {
    if (e.which === 13) {
      e.preventDefault();
    }
    _this.search(false);
    morpheus.Util.trackEvent({
      eventCategory: 'ToolBar',
      eventAction: 'searchColumns'
    });
  }, 500));

  // dendrogram search

  morpheus.Util.autosuggest({
    $el: this.rowDendrogramSearchObject.$search,
    filter: function (tokens, cb) {
      var d = heatMap.getDendrogram(false);
      if (!d.searchTerms) {
        cb([]);
      } else {
        var token = tokens != null && tokens.length > 0 ? tokens[tokens.selectionStartIndex]
          : '';
        token = $.trim(token);
        if (token === '') {
          cb([]);
        } else {
          morpheus.Util.autocompleteArrayMatcher(token, cb, d.searchTerms, null, 10);
        }
      }
    },
    select: function () {
      _this.searchDendrogram(false);
    }
  });

  this.rowDendrogramSearchObject.$search.on('keyup', _.debounce(function (e) {
    if (e.which === 13) {
      e.preventDefault();
    }
    _this.searchDendrogram(false);
    morpheus.Util.trackEvent({
      eventCategory: 'ToolBar',
      eventAction: 'searchRowDendrogram'
    });
  }, 500));

  morpheus.Util.autosuggest({
    $el: this.columnDendrogramSearchObject.$search,
    filter: function (tokens, cb) {
      var d = heatMap.getDendrogram(true);
      if (!d.searchTerms) {
        cb([]);
      } else {
        var token = tokens != null && tokens.length > 0 ? tokens[tokens.selectionStartIndex]
          : '';
        token = $.trim(token);
        if (token === '') {
          cb([]);
        } else {
          morpheus.Util.autocompleteArrayMatcher(token, cb, d.searchTerms, null, 10);
        }
      }
    },
    select: function () {
      _this.searchDendrogram(true);
    }
  });

  this.columnDendrogramSearchObject.$search.on('keyup', _.debounce(function (e) {
    if (e.which === 13) {
      e.preventDefault();
    }
    _this.searchDendrogram(true);
    morpheus.Util.trackEvent({
      eventCategory: 'ToolBar',
      eventAction: 'searchColumnDendrogram'
    });
  }, 500));

  function searchValues() {
    var $searchResultsLabel = _this.$valueSearchResults;
    var text = $.trim(_this.$valueTextField.val());
    if (text === '') {
      $searchResultsLabel.html('');
      project.getElementSelectionModel().setViewIndices(null);
    } else {
      var viewIndices = morpheus.DatasetUtil.searchValues({
        dataset: project
          .getSortedFilteredDataset(),
        text: text,
        matchAllPredicates: _this.valueSearchObject.matchAllPredicates,
        defaultMatchMode: _this.valueSearchObject.matchMode
      });

      project.getElementSelectionModel().setViewIndices(viewIndices);
      $searchResultsLabel.html(viewIndices.size() + ' match'
        + (viewIndices.size() === 1 ? '' : 'es'));
    }
  }

  morpheus.Util.autosuggest({
    $el: this.$valueTextField,
    filter: function (terms, cb) {
      morpheus.DatasetUtil.autocompleteValues(
        project.getSortedFilteredDataset())(terms, cb);
    },
    select: function () {
      searchValues();
    }
  });

  this.$valueTextField.on('keyup', _.debounce(function (e) {
    if (e.which === 13) {
      _this.$valueTextField.autocomplete('close');
      e.preventDefault();
    }
    searchValues();
  }, 500));

  this.toggleControls = function () {
    if ($lineOneColumn.css('display') === 'none') {
      $lineOneColumn.css('display', '');
      _this.rowSearchObject.$search.focus();
    } else {
      $lineOneColumn.css('display', 'none');
      $(_this.heatMap.heatmap.canvas).focus();
    }
  };
  this.$el = $el;
  var updateFilterStatus = function () {
    if (heatMap.getProject().getRowFilter().isEnabled()
      || heatMap.getProject().getColumnFilter().isEnabled()) {
      _this.$el.find('[name=filterButton]').addClass('btn-primary');
    } else {
      _this.$el.find('[name=filterButton]').removeClass('btn-primary');
    }

  };
  updateFilterStatus();

  this.columnSearchObject.$matchesToTop
    .on(
      'click',
      function (e) {
        e.preventDefault();
        var $this = $(this);
        $this.toggleClass('btn-primary');
        _this.setSelectionOnTop({
          isColumns: true,
          isOnTop: $this.hasClass('btn-primary'),
          updateButtonStatus: false
        });
        morpheus.Util.trackEvent({
          eventCategory: 'ToolBar',
          eventAction: 'columnMatchesToTop'
        });
      });
  this.rowSearchObject.$matchesToTop
    .on(
      'click',
      function (e) {
        e.preventDefault();
        var $this = $(this);
        $this.toggleClass('btn-primary');
        _this.setSelectionOnTop({
          isColumns: false,
          isOnTop: $this.hasClass('btn-primary'),
          updateButtonStatus: false
        });
        morpheus.Util.trackEvent({
          eventCategory: 'ToolBar',
          eventAction: 'rowMatchesToTop'
        });
      });
  project.on('rowSortOrderChanged.morpheus', function (e) {
    if (_this.searching) {
      return;
    }
    _this._updateSearchIndices(false);
    _this.rowSearchObject.$matchesToTop.removeClass('btn-primary');
  });

  project.on('columnSortOrderChanged.morpheus', function (e) {
    if (_this.searching) {
      return;
    }
    _this._updateSearchIndices(true);
    _this.columnSearchObject.$matchesToTop.removeClass('btn-primary');
  });

  heatMap.getProject().on('rowFilterChanged.morpheus', function (e) {
    _this.search(true);
    updateFilterStatus();
  });
  heatMap.getProject().on('columnFilterChanged.morpheus', function (e) {
    _this.search(false);
    updateFilterStatus();
  });
  heatMap.getProject().on('datasetChanged.morpheus', function () {
    _this.search(true);
    _this.search(false);
    updateFilterStatus();
  });
  heatMap.getProject().getRowSelectionModel().on(
    'selectionChanged.morpheus', function () {
      _this.updateSelectionLabel();
    });
  heatMap.getProject().getColumnSelectionModel().on(
    'selectionChanged.morpheus', function () {
      _this.updateSelectionLabel();
    });
  this.rowSearchResultViewIndicesSorted = null;
  this.currentRowSearchIndex = 0;
  this.columnSearchResultViewIndicesSorted = null;
  this.currentColumnSearchIndex = -1;
  this.columnSearchObject.$previousMatch
    .on(
      'click',
      function () {
        _this.currentColumnSearchIndex--;
        if (_this.currentColumnSearchIndex < 0) {
          _this.currentColumnSearchIndex = _this.columnSearchResultViewIndicesSorted.length - 1;
        }
        heatMap
          .scrollLeft(heatMap
            .getHeatMapElementComponent()
            .getColumnPositions()
            .getPosition(
              _this.columnSearchResultViewIndicesSorted[_this.currentColumnSearchIndex]));
        morpheus.Util.trackEvent({
          eventCategory: 'ToolBar',
          eventAction: 'previousColumnMatch'
        });
      });
  this.rowSearchObject.$previousMatch
    .on(
      'click',
      function () {
        _this.currentRowSearchIndex--;
        if (_this.currentRowSearchIndex < 0) {
          _this.currentRowSearchIndex = _this.rowSearchResultViewIndicesSorted.length - 1;
        }
        heatMap
          .scrollTop(heatMap
            .getHeatMapElementComponent()
            .getRowPositions()
            .getPosition(
              _this.rowSearchResultViewIndicesSorted[_this.currentRowSearchIndex]));
        morpheus.Util.trackEvent({
          eventCategory: 'ToolBar',
          eventAction: 'previousRowMatch'
        });
      });
  this.columnSearchObject.$nextMatch.on('click', function () {
    _this.next(true);
    morpheus.Util.trackEvent({
      eventCategory: 'ToolBar',
      eventAction: 'nextColumnMatch'
    });

  });
  this.rowSearchObject.$nextMatch.on('click', function () {
    _this.next(false);
    morpheus.Util.trackEvent({
      eventCategory: 'ToolBar',
      eventAction: 'nextRowMatch'
    });
  });
  this.updateDimensionsLabel();
  this.updateSelectionLabel();
}
;
morpheus.HeatMapToolBar.HIGHLIGHT_SEARCH_MODE = 0;
morpheus.HeatMapToolBar.FILTER_SEARCH_MODE = 1;
morpheus.HeatMapToolBar.MATCHES_TO_TOP_SEARCH_MODE = 2;
morpheus.HeatMapToolBar.SELECT_MATCHES_SEARCH_MODE = 3;
morpheus.HeatMapToolBar.prototype = {
  quickColumnFilter: false,
  searching: false,
  rowSearchMode: morpheus.HeatMapToolBar.SELECT_MATCHES_SEARCH_MODE,
  columnSearchMode: morpheus.HeatMapToolBar.SELECT_MATCHES_SEARCH_MODE,
  _updateSearchIndices: function (isColumns) {
    var project = this.heatMap.getProject();
    if (isColumns) {
      var viewIndices = [];
      var modelIndices = this.columnSearchResultModelIndices;
      for (var i = 0, length = modelIndices.length; i < length; i++) {
        var index = project
          .convertModelColumnIndexToView(modelIndices[i]);
        if (index !== -1) {
          viewIndices.push(index);
        }
      }
      viewIndices.sort(function (a, b) {
        return a < b ? -1 : 1;
      });
      this.columnSearchResultViewIndicesSorted = viewIndices;
      this.currentColumnSearchIndex = -1;
    } else {
      var viewIndices = [];
      var modelIndices = this.rowSearchResultModelIndices;
      for (var i = 0, length = modelIndices.length; i < length; i++) {
        var index = project.convertModelRowIndexToView(modelIndices[i]);
        if (index !== -1) {
          viewIndices.push(index);
        }
      }
      viewIndices.sort(function (a, b) {
        return a < b ? -1 : 1;
      });
      this.rowSearchResultViewIndicesSorted = viewIndices;
      this.currentRowSearchIndex = -1;
    }
  },
  next: function (isColumns) {
    var heatMap = this.heatMap;
    if (isColumns) {
      this.currentColumnSearchIndex++;
      if (this.currentColumnSearchIndex >= this.columnSearchResultViewIndicesSorted.length) {
        this.currentColumnSearchIndex = 0;
      }
      heatMap
        .scrollLeft(heatMap
          .getHeatMapElementComponent()
          .getColumnPositions()
          .getPosition(
            this.columnSearchResultViewIndicesSorted[this.currentColumnSearchIndex]));
    } else {
      this.currentRowSearchIndex++;
      if (this.currentRowSearchIndex >= this.rowSearchResultViewIndicesSorted.length) {
        this.currentRowSearchIndex = 0;
      }
      heatMap
        .scrollTop(heatMap
          .getHeatMapElementComponent()
          .getRowPositions()
          .getPosition(
            this.rowSearchResultViewIndicesSorted[this.currentRowSearchIndex]));
    }
  },
  getSearchField: function (type) {
    if (type === morpheus.HeatMapToolBar.COLUMN_SEARCH_FIELD) {
      return this.columnSearchObject.$search;
    } else if (type === morpheus.HeatMapToolBar.ROW_SEARCH_FIELD) {
      return this.rowSearchObject.$search;
    } else if (type === morpheus.HeatMapToolBar.COLUMN_DENDROGRAM_SEARCH_FIELD) {
      return this.columnDendrogramSearchObject.$search;
    } else if (type === morpheus.HeatMapToolBar.ROW_DENDROGRAM_SEARCH_FIELD) {
      return this.rowDendrogramSearchObject.$search;
    }
  },
  setSearchText: function (options) {
    var $tf = options.isColumns ? this.columnSearchObject.$search
      : this.rowSearchObject.$search;
    var existing = options.append ? $.trim($tf.val()) : '';
    if (existing !== '') {
      existing += ' ';
    }
    if (options.onTop) {
      options.isColumns ? this.columnSearchObject.$matchesToTop
        .addClass('btn-primary') : this.rowSearchObject.$matchesToTop
        .addClass('btn-primary');

    }
    $tf.val(existing + options.text);
    this.search(!options.isColumns);
    if (options.scrollTo) {
      this.next(options.isColumns);
      // click next
    }
  },
  updateDimensionsLabel: function () {
    var p = this.heatMap.getProject();
    var d = p.getFullDataset();
    var f = p.getSortedFilteredDataset();
    var text = 'showing ' + morpheus.Util.intFormat(f.getRowCount())
      + '/' + morpheus.Util.intFormat(d.getRowCount()) + ' rows, '
      + morpheus.Util.intFormat(f.getColumnCount()) + '/'
      + morpheus.Util.intFormat(d.getColumnCount()) + ' columns';
    this.$dimensionsLabel.html(text);
  },
  updateSelectionLabel: function () {
    var nc = this.heatMap.getProject().getColumnSelectionModel().count();
    var nr = this.heatMap.getProject().getRowSelectionModel().count();
    var text = [];
    text.push(morpheus.Util.intFormat(nr) + ' row');
    if (nr !== 1) {
      text.push('s');
    }
    text.push(', ');
    text.push(morpheus.Util.intFormat(nc) + ' column');
    if (nc !== 1) {
      text.push('s');
    }
    text.push(' selected');
    this.$selectionLabel.html(text.join(''));
  },
  searchDendrogram: function (isColumns) {
    var searchObject = isColumns ? this.columnDendrogramSearchObject : this.rowDendrogramSearchObject;
    var text = $.trim(searchObject.$search.val());
    var dendrogram = isColumns ? this.heatMap.columnDendrogram
      : this.heatMap.rowDendrogram;
    var $searchResults = searchObject.$searchResults;
    var matches = morpheus.DendrogramUtil.search({
      rootNode: dendrogram.tree.rootNode,
      text: text,
      matchAllPredicates: searchObject.matchAllPredicates,
      defaultMatchMode: searchObject.matchMode
    });
    if (matches === -1) {
      $searchResults.html('');
    } else {
      $searchResults.html(matches + ' match'
        + (matches === 1 ? '' : 'es'));
    }
    if (matches <= 0) {
      var positions = isColumns ? this.heatMap
        .getHeatMapElementComponent().getColumnPositions()
        : this.heatMap.getHeatMapElementComponent()
        .getRowPositions();
      positions.setSquishedIndices(null);
      if (isColumns) {
        this.heatMap.getProject().setGroupColumns([], true);
      } else {
        this.heatMap.getProject().setGroupRows([], true);
      }
      positions.setSize(isColumns ? this.heatMap.getFitColumnSize()
        : this.heatMap.getFitRowSize());
    } else {
      morpheus.DendrogramUtil.squishNonSearchedNodes(this.heatMap,
        isColumns);
    }
    this.heatMap.updateDataset(); // need to update spaces for group
    // by
    this.heatMap.revalidate();
  },
  search: function (isRows) {
    this.searching = true;
    var isMatchesOnTop = isRows ? this.rowSearchObject.$matchesToTop
      .hasClass('btn-primary') : this.columnSearchObject.$matchesToTop
      .hasClass('btn-primary');
    var heatMap = this.heatMap;
    var project = heatMap.getProject();

    var sortKeys = isRows ? project.getRowSortKeys() : project
      .getColumnSortKeys();
    sortKeys = sortKeys.filter(function (key) {
      return !(key instanceof morpheus.MatchesOnTopSortKey && key.toString() === 'matches on top');
    });

    var dataset = project.getSortedFilteredDataset();
    var $searchResultsLabel = isRows ? this.rowSearchObject.$searchResults : this.columnSearchObject.$searchResults;
    var searchText = !isRows ? $.trim(this.columnSearchObject.$search.val()) : $
      .trim(this.rowSearchObject.$search.val());

    var metadata = isRows ? dataset.getRowMetadata() : dataset
      .getColumnMetadata();
    var visibleIndices = [];
    heatMap.getVisibleTrackNames(!isRows).forEach(function (name) {
      visibleIndices.push(morpheus.MetadataUtil.indexOf(metadata, name));
    });
    var fullModel = metadata;
    metadata = new morpheus.MetadataModelColumnView(metadata,
      visibleIndices);

    var searchResultViewIndices = morpheus.MetadataUtil.search({
      model: metadata,
      fullModel: fullModel,
      text: searchText,
      isColumns: !isRows,
      matchAllPredicates: isRows ? this.rowSearchObject.matchAllPredicates : this.columnSearchObject.matchAllPredicates,
      defaultMatchMode: isRows ? this.rowSearchObject.matchMode
        : this.columnSearchObject.matchMode
    });
    if (searchText === '') {
      $searchResultsLabel.html('');
      if (isRows) {
        this.rowSearchObject.$searchResultsWrapper.hide();
      } else {
        this.columnSearchObject.$searchResultsWrapper.hide();
      }

    } else {
      $searchResultsLabel.html(searchResultViewIndices.length + ' match'
        + (searchResultViewIndices.length === 1 ? '' : 'es'));
      if (isRows) {
        this.rowSearchObject.$searchResultsWrapper.show();
      } else {
        this.columnSearchObject.$searchResultsWrapper.show();
      }

    }

    var searchResultsModelIndices = [];
    if (searchResultViewIndices != null) {
      for (var i = 0, length = searchResultViewIndices.length; i < length; i++) {
        var viewIndex = searchResultViewIndices[i];
        searchResultsModelIndices.push(isRows ? project
          .convertViewRowIndexToModel(viewIndex) : project
          .convertViewColumnIndexToModel(viewIndex));
      }
    }

    if (searchResultViewIndices !== null && isMatchesOnTop) {
      var key = new morpheus.MatchesOnTopSortKey(project,
        searchResultsModelIndices, 'matches on top', !isRows);
      // keep other sort keys
      searchResultViewIndices = key.indices; // matching indices
      // are now on top
      // add to beginning of sort keys
      sortKeys.splice(0, 0, key);
      if (isRows) {
        project.setRowSortKeys(sortKeys, false);
      } else {
        project.setColumnSortKeys(sortKeys, false);
      }
    }
    var searchResultsViewIndicesSet = new morpheus.Set();
    if (searchResultViewIndices != null) {
      for (var i = 0, length = searchResultViewIndices.length; i < length; i++) {
        var viewIndex = searchResultViewIndices[i];
        searchResultsViewIndicesSet.add(viewIndex);
      }
    }
    if (searchResultViewIndices == null) {
      searchResultViewIndices = [];
    }

    if (isRows) {
      this.rowSearchResultModelIndices = searchResultsModelIndices;
      this.rowSearchResultViewIndicesSorted = searchResultViewIndices
        .sort(function (a, b) {
          return a < b ? -1 : 1;
        });
      this.currentRowSearchIndex = -1;

    } else {
      this.columnSearchResultModelIndices = searchResultsModelIndices;
      this.columnSearchResultViewIndicesSorted = searchResultViewIndices
        .sort(function (a, b) {
          return a < b ? -1 : 1;
        });
      this.currentColumnSearchIndex = -1;
    }
    // update selection
    (!isRows ? project.getColumnSelectionModel() : project
      .getRowSelectionModel()).setViewIndices(
      searchResultsViewIndicesSet, true);

    if (isMatchesOnTop) { // resort
      if (isRows) {
        project.setRowSortKeys(morpheus.SortKey.keepExistingSortKeys(
          sortKeys, project.getRowSortKeys()), true);
      } else {
        project.setColumnSortKeys(morpheus.SortKey
          .keepExistingSortKeys(sortKeys, project
            .getColumnSortKeys()), true);
      }
    }
    this.updateDimensionsLabel();
    this.updateSelectionLabel();
    this.searching = false;

  },
  isSelectionOnTop: function (isColumns) {
    var $btn = isColumns ? this.columnSearchObject.$matchesToTop : this.rowSearchObject.$matchesToTop;
    return $btn.hasClass('btn-primary');
  },
  setSelectionOnTop: function (options) {
    if (options.updateButtonStatus) {
      var $btn = options.isColumns ? this.columnSearchObject.$matchesToTop : this.rowSearchObject.$matchesToTop;
      if (options.isOnTop) {
        $btn.addClass('btn-primary');
      } else {
        $btn.removeClass('btn-primary');
      }
    }
    var project = this.heatMap.getProject();
    var sortKeys = options.isColumns ? project.getColumnSortKeys() : project.getRowSortKeys();
    // remove existing matches on top key
    sortKeys = sortKeys
      .filter(function (key) {
        return !(key instanceof morpheus.MatchesOnTopSortKey && key.name === 'matches on top');
      });
    if (options.isOnTop) { // bring to top
      var key = new morpheus.MatchesOnTopSortKey(project,
        options.isColumns ? this.columnSearchResultModelIndices : this.rowSearchResultModelIndices,
        'matches on top');
      sortKeys.splice(0, 0, key);
      if (options.isColumns) {
        this.heatMap.scrollLeft(0);
      } else {
        this.heatMap.scrollTop(0);
      }
    }
    this.searching = true;
    if (options.isColumns) {
      project.setColumnSortKeys(sortKeys, true);
    } else {
      project.setRowSortKeys(sortKeys, true);
    }
    this._updateSearchIndices(options.isColumns);
    this.searching = false;

  }
};
morpheus.HeatMapToolBar.COLUMN_SEARCH_FIELD = 'column';
morpheus.HeatMapToolBar.ROW_SEARCH_FIELD = 'column';
morpheus.HeatMapToolBar.COLUMN_DENDROGRAM_SEARCH_FIELD = 'column_dendrogram';
morpheus.HeatMapToolBar.ROW_DENDROGRAM_SEARCH_FIELD = 'row_dendrogram';

morpheus.HeatMapTooltipProvider = function (heatMap, rowIndex, columnIndex, options, separator, quick, tipText) {
  var dataset = heatMap.project.getSortedFilteredDataset();
  if (!quick) {
    if (options.value) { // key value pairs for custom tooltip
      _.each(options.value, function (pair) {
        if (tipText.length > 0) {
          tipText.push(separator);
        }
        tipText.push(pair.name);
        tipText.push(': <b>');
        if (_.isArray(pair.value)) {
          for (var i = 0; i < pair.value.length; i++) {
            if (i > 0) {
              tipText.push(', ');
            }
            tipText.push(pair.value[i]);
          }
        } else {
          tipText.push(pair.value);
        }
        tipText.push('</b>');
      });
    }
  }
  if (rowIndex !== -1 && columnIndex !== -1) {
    var tooltipSeriesIndices = options.tooltipSeriesIndices ? options.tooltipSeriesIndices : morpheus.Util.sequ32(dataset.getSeriesCount());
    for (var i = 0, nseries = tooltipSeriesIndices.length; i < nseries; i++) {
      morpheus.HeatMapTooltipProvider._matrixValueToString(dataset,
        rowIndex, columnIndex, tooltipSeriesIndices[i], tipText, separator,
        options.showSeriesNameInTooltip || i > 0);
      if (heatMap.options.symmetric && dataset.getValue(rowIndex, columnIndex, tooltipSeriesIndices[i]) !== dataset.getValue(columnIndex, rowIndex, tooltipSeriesIndices[i])) {
        morpheus.HeatMapTooltipProvider._matrixValueToString(dataset,
          columnIndex, rowIndex, tooltipSeriesIndices[i], tipText, separator, false);
      }
    }

    if (quick) {
      var quickRowTracks = heatMap.rowTracks.filter(function (t) {
        return t.settings.inlineTooltip;
      });
      morpheus.HeatMapTooltipProvider._tracksToString(quickRowTracks, dataset.getRowMetadata(), rowIndex, tipText, separator);
      morpheus.HeatMapTooltipProvider._tracksToString(heatMap.columnTracks.filter(function (t) {
        return t.settings.inlineTooltip;
      }), dataset.getColumnMetadata(), columnIndex, tipText, separator);

    }
  } else if (quick) {
    if (rowIndex !== -1) {
      morpheus.HeatMapTooltipProvider._tracksToString(heatMap.rowTracks.filter(function (t) {
        return t.settings.inlineTooltip && options.name !== t.getName();
      }), dataset.getRowMetadata(), rowIndex, tipText, separator);
    }
    if (columnIndex !== -1) {
      morpheus.HeatMapTooltipProvider._tracksToString(heatMap.columnTracks.filter(function (t) {
        return t.settings.inlineTooltip && options.name !== t.getName();
      }), dataset.getColumnMetadata(), columnIndex, tipText, separator);
    }
  }

  if (!quick) {
    if (rowIndex !== -1) {
      morpheus.HeatMapTooltipProvider._metadataToString(options,
        heatMap.rowTracks, dataset.getRowMetadata(), rowIndex,
        tipText, separator);
    }
    if (columnIndex !== -1) {
      morpheus.HeatMapTooltipProvider._metadataToString(options,
        heatMap.columnTracks, dataset.getColumnMetadata(),
        columnIndex, tipText, separator);
    }
  } else if (options.name != null) {
    var metadata = (rowIndex !== -1 ? dataset.getRowMetadata() : dataset.getColumnMetadata());
    var vector = metadata.getByName(options.name);
    var track = heatMap.getTrack(options.name, columnIndex !== -1);
    var colorByName = track != null ? track.settings.colorByField : null;
    var additionalVector = colorByName != null ? metadata
      .getByName(colorByName) : null;
    morpheus.HeatMapTooltipProvider.vectorToString(vector,
      rowIndex !== -1 ? rowIndex : columnIndex, tipText, separator,
      additionalVector);

  }
  var rowNodes = [];
  var columnNodes = [];
  var selectedRowNodes = [];
  var selectedColumnNodes = [];

  if (options.rowNodes) {
    rowNodes = options.rowNodes;
  }
  if (options.columnNodes) {
    columnNodes = options.columnNodes;
  }
  if (!quick) {
    if (heatMap.rowDendrogram) {
      selectedRowNodes = _
        .values(heatMap.rowDendrogram.selectedRootNodeIdToNode);
    }
    if (heatMap.columnDendrogram) {
      selectedColumnNodes = _
        .values(heatMap.columnDendrogram.selectedRootNodeIdToNode);
    }
    if (selectedRowNodes.length > 0 && rowNodes.length > 0) {
      var nodeIds = {};
      _.each(selectedRowNodes, function (n) {
        nodeIds[n.id] = true;
      });
      rowNodes = _.filter(rowNodes, function (n) {
        return nodeIds[n.id] === undefined;
      });
    }
    if (selectedColumnNodes.length > 0 && columnNodes.length > 0) {
      var nodeIds = {};
      _.each(selectedColumnNodes, function (n) {
        nodeIds[n.id] = true;
      });
      columnNodes = _.filter(columnNodes, function (n) {
        return nodeIds[n.id] === undefined;
      });
    }
  }
  morpheus.HeatMapTooltipProvider._nodesToString(tipText, rowNodes, null, separator);
  morpheus.HeatMapTooltipProvider._nodesToString(tipText, columnNodes, null, separator);
  if (!quick) {
    if (selectedRowNodes.length > 0) {
      morpheus.HeatMapTooltipProvider._nodesToString(tipText,
        selectedRowNodes, heatMap.rowDendrogram._selectedNodeColor,
        separator);
    }
    if (selectedColumnNodes.length > 0) {
      morpheus.HeatMapTooltipProvider._nodesToString(tipText,
        selectedColumnNodes,
        heatMap.columnDendrogram._selectedNodeColor, separator);
    }
  }

};

morpheus.HeatMapTooltipProvider._matrixValueToString = function (dataset, rowIndex, columnIndex, seriesIndex, tipText, separator, showSeriesNameInTooltip) {
  var val = dataset.getValue(rowIndex, columnIndex, seriesIndex);
  if (val != null) {

    if (val.toObject || !_.isNumber(val)) {
      var obj = val.toObject ? val.toObject() : val;
      if (morpheus.Util.isArray(obj)) {
        var v = morpheus.Util.toString(obj);
        if (tipText.length > 0) {
          tipText.push(separator);
        }
        if (showSeriesNameInTooltip) {
          tipText.push(dataset.getName(seriesIndex));
          tipText.push(': ');
        }
        tipText.push('<b>');
        tipText.push(v);
        tipText.push('</b>');
      } else {
        var keys = _.keys(obj);
        if (keys.length === 0) {
          var v = morpheus.Util.toString(obj);
          if (tipText.length > 0) {
            tipText.push(separator);
          }
          if (showSeriesNameInTooltip) {
            tipText.push(dataset.getName(seriesIndex));
            tipText.push(': ');
          }
          tipText.push('<b>');
          tipText.push(v);
          tipText.push('</b>');
        } else {
          for (var i = 0, nkeys = keys.length; i < nkeys; i++) {
            var key = keys[i];
            if (key !== '__v') { // special value key
              var objVal = obj[key];
              var v;
              if (morpheus.Util.isArray(objVal)) {
                v = morpheus.Util.arrayToString(objVal, ', ');
              } else {
                v = morpheus.Util.toString(objVal);
              }
              if (tipText.length > 0) {
                tipText.push(separator);
              }
              tipText.push(key);
              tipText.push(': <b>');
              tipText.push(v);
              tipText.push('</b>');
            }
          }
          if (_.isNumber(val)) {
            tipText.push(separator);
            tipText.push('Value: <b>');
            tipText.push(morpheus.Util.nf(val));
            tipText.push('</b>');
          }
        }
      }
    } else {
      if (tipText.length > 0) {
        tipText.push(separator);
      }

      if (showSeriesNameInTooltip) {
        tipText.push(dataset.getName(seriesIndex));
        tipText.push(': ');
      }
      tipText.push('<b>');
      tipText.push(morpheus.Util.nf(val));
      tipText.push('</b>');
    }
  }
};

morpheus.HeatMapTooltipProvider.vectorToString = function (vector, index, tipText, separator, additionalVector) {
  var arrayValueToString = function (arrayFieldName, arrayVal) {
    if (arrayVal != null) {
      if (arrayFieldName != null) {
        if (tipText.length > 0) {
          tipText.push(separator);
        }
        tipText.push(arrayFieldName); // e.g. PC3
      }
      if (arrayVal.toObject) {
        tipText.push(' ');
        var obj = arrayVal.toObject();
        var keys = _.keys(obj);
        _.each(keys, function (key) {
          var subVal = obj[key];
          if (subVal != null && subVal != '') {
            if (tipText.length > 0) {
              tipText.push(separator);
            }
            tipText.push(key);
            tipText.push(': <b>');
            tipText.push(morpheus.Util.toString(subVal));
            tipText.push('</b>');
          }
        });
      } else {
        tipText.push(': <b>');
        tipText.push(morpheus.Util.toString(arrayVal));
        tipText.push('</b>');
      }

    }
  };
  if (vector != null) {
    var primaryVal = vector.getValue(index);
    if (primaryVal != null && primaryVal != '') {
      var primaryFields = vector.getProperties().get(
        morpheus.VectorKeys.FIELDS);
      if (primaryFields != null) {
        var visibleFieldIndices = vector.getProperties().get(
          morpheus.VectorKeys.VISIBLE_FIELDS);
        if (visibleFieldIndices === undefined) {
          visibleFieldIndices = morpheus.Util
            .seq(primaryFields.length);
        }
        var additionalFieldNames = additionalVector != null ? additionalVector
          .getProperties().get(morpheus.VectorKeys.FIELDS)
          : null;
        var additionalVal = additionalFieldNames != null ? additionalVector
          .getValue(index)
          : null;
        if (tipText.length > 0) {
          tipText.push(separator);
        }
        tipText.push(vector.getName());
        for (var j = 0; j < visibleFieldIndices.length; j++) {
          arrayValueToString(primaryFields[visibleFieldIndices[j]],
            primaryVal[visibleFieldIndices[j]]);
        }

        if (additionalVal != null) {
          if (tipText.length > 0) {
            tipText.push(separator);
          }
          tipText.push(additionalVector.getName());
          for (var j = 0; j < visibleFieldIndices.length; j++) {
            arrayValueToString(
              additionalFieldNames[visibleFieldIndices[j]],
              additionalVal[visibleFieldIndices[j]]);
          }

        }
      } else if (primaryVal.summary) {
        if (tipText.length > 0) {
          tipText.push(separator);
        }
        tipText.push(vector.getName());
        tipText.push(': ');
        var obj = primaryVal.summary;
        var keys = _.keys(obj);
        for (var i = 0, nkeys = keys.length; i < nkeys; i++) {
          var key = keys[i];
          if (key !== '__v') { // special value key
            var objVal = obj[key];
            var v;
            if (morpheus.Util.isArray(objVal)) {
              v = morpheus.Util.arrayToString(objVal, ', ');
            } else {
              v = morpheus.Util.toString(objVal);
            }
            if (tipText.length > 0) {
              tipText.push(separator);
            }
            tipText.push(key);
            tipText.push(': <b>');
            tipText.push(v);
            tipText.push('</b>');
          }
        }

      } else {
        if (tipText.length > 0) {
          tipText.push(separator);
        }
        tipText.push(vector.getName());
        tipText.push(': <b>');
        tipText.push(morpheus.Util.toString(primaryVal));
        tipText.push('</b>');
      }

    }
  }
};
morpheus.HeatMapTooltipProvider._tracksToString = function (tracks, metadata, index, tipText, separator) {
  for (var i = 0; i < tracks.length; i++) {
    morpheus.HeatMapTooltipProvider.vectorToString(metadata.getByName(tracks[i].name), index, tipText,
      separator);

  }
};
morpheus.HeatMapTooltipProvider._metadataToString = function (options, tracks, metadata, index,
                                                              tipText, separator) {
  var filtered = [];
  for (var i = 0, ntracks = tracks.length; i < ntracks; i++) {
    var track = tracks[i];
    if ((track.isVisible() && track.isShowTooltip())) {
      if (tracks[i].name === options.name) { // show the vector that we're mousing over 1st
        filtered.splice(0, 0, track);
      } else {
        filtered.push(track);
      }
    }
  }

  morpheus.HeatMapTooltipProvider._tracksToString(filtered, metadata, index, tipText, separator);

};
morpheus.HeatMapTooltipProvider._nodesToString = function (tipText, nodes, color, separator) {
  var renderField = function (name, value) {
    if (value != null) {
      if (tipText.length > 0) {
        tipText.push(separator);
      }
      if (color) {
        tipText.push('<span style="color:' + color + '">');
      }
      tipText.push(name);
      tipText.push(': <b>');
      if (_.isArray(value)) {
        for (var i = 0; i < value.length; i++) {
          if (i > 0) {
            tipText.push(', ');
          }
          tipText.push(morpheus.Util.toString(value[i]));
        }
      } else {
        tipText.push(morpheus.Util.toString(value));
      }
      tipText.push('</b>');
      if (color) {
        tipText.push('</span>');
      }
    }
  };
  _.each(nodes, function (node) {
    if (node.info) {
      for (var name in node.info) {
        var value = node.info[name];
        renderField(name, value);
      }
    }
    renderField('height', node.height);
    renderField('depth', node.depth);
    var nLeafNodes = 1 + Math.abs(node.maxIndex - node.minIndex);
    if (nLeafNodes > 0) {
      renderField('# of leaf nodes', nLeafNodes);
      // renderField('height', node.height);
    }
  });
};

morpheus.HeatMapTrackColorLegend = function (tracks, colorModel) {
  morpheus.AbstractCanvas.call(this, false);
  this.tracks = tracks;
  this.colorModel = colorModel;
  this.canvas.style.position = '';
};
morpheus.HeatMapTrackColorLegend.prototype = {
  getPreferredSize: function () {
    var tracks = this.tracks;
    var colorModel = this.colorModel;
    var xpix = 0;
    var ypix = 0;
    var maxYPix = 0;
    var canvas = this.canvas;
    var context = canvas.getContext('2d');
    context.font = '12px ' + morpheus.CanvasUtil.FONT_NAME;
    for (var i = 0; i < tracks.length; i++) {
      ypix = 0;
      var maxWidth = 0;
      var vector = tracks[i].getVector();
      var map = colorModel.getDiscreteColorScheme(vector);
      if (map == null) { // continuous
        maxWidth = 220;
        ypix += 40;
      } else {
        map.forEach(function (color, key) {
          var width = context.measureText(key).width;
          if (!isNaN(width)) {
            maxWidth = Math.max(maxWidth, width);
          }
          ypix += 14;
        });
      }
      maxWidth = Math.max(maxWidth,
        context.measureText(vector.getName()).width);
      xpix += maxWidth + 10 + 14;
      maxYPix = Math.max(maxYPix, ypix);
    }
    return {
      width: xpix,
      height: maxYPix > 0 ? (maxYPix + 12) : 0
    };
  },
  draw: function (clip, context) {
    var tracks = this.tracks;
    var colorModel = this.colorModel;
    var xpix = 0;
    // legends are placed side by side
    for (var i = 0; i < tracks.length; i++) {
      var ypix = 0;
      var vector = tracks[i].getVector();
      context.fillStyle = morpheus.CanvasUtil.FONT_COLOR;
      context.font = '12px ' + morpheus.CanvasUtil.FONT_NAME;
      context.textAlign = 'left';
      // draw name
      context.textBaseline = 'top';
      context.fillText(vector.getName(), xpix, ypix);

      context.strokeStyle = 'LightGrey';
      var maxWidth = 0;
      var textWidth = context.measureText(vector.getName()).width;
      if (!isNaN(textWidth)) {
        maxWidth = Math.max(0, textWidth);
      }
      ypix += 14;

      var scheme = colorModel.getContinuousColorScheme(vector);
      if (scheme != null) { // draw continuous color legend
        context.save();
        context.translate(xpix, ypix);
        morpheus.HeatMapColorSchemeLegend.drawColorScheme(context,
          scheme, 200);
        context.restore();
        maxWidth = Math.max(maxWidth, 220);
        ypix += 40;
      } else {
        var map = colorModel.getDiscreteColorScheme(vector);
        var values = map.keys().sort(
          morpheus.SortKey.ASCENDING_COMPARATOR);
        values.forEach(function (key) {
          if (key != null) {
            var color = colorModel.getMappedValue(vector, key);
            var textWidth = context.measureText(key).width;
            if (!isNaN(textWidth)) {
              maxWidth = Math.max(maxWidth, textWidth);
            }
            context.fillStyle = color;
            context.fillRect(xpix, ypix, 12, 12);
            context.strokeRect(xpix, ypix, 12, 12);
            context.fillStyle = morpheus.CanvasUtil.FONT_COLOR;
            context.fillText(key, xpix + 16, ypix);
            ypix += 14;
          }
        });
      }
      xpix += maxWidth + 10 + 14; // space between tracks + color chip
    }
  }
};
morpheus.Util.extend(morpheus.HeatMapTrackColorLegend, morpheus.AbstractCanvas);

morpheus.HeatMapTrackShapeLegend = function (tracks, shapeModel) {
  morpheus.AbstractCanvas.call(this, false);
  this.tracks = tracks;
  this.shapeModel = shapeModel;
  this.canvas.style.position = '';
};
morpheus.HeatMapTrackShapeLegend.prototype = {
  getPreferredSize: function () {
    var tracks = this.tracks;
    var shapeModel = this.shapeModel;
    var canvas = this.canvas;
    var context = canvas.getContext('2d');
    var xpix = 0;
    var ypix = 0;
    var maxYPix = 0;
    for (var i = 0; i < tracks.length; i++) {
      ypix = 0;
      var maxWidth = 0;
      var vector = tracks[i].getVector();
      var map = shapeModel.getMap(vector.getName());

      map.forEach(function (color, key) {
        var width = context.measureText(key).width;
        if (!isNaN(width)) {
          maxWidth = Math.max(maxWidth, width);
        }
        ypix += 14;
      });

      xpix += maxWidth + 24;
      maxYPix = Math.max(maxYPix, ypix);
    }
    return {
      width: xpix,
      height: maxYPix > 0 ? (maxYPix + 30) : 0
    };
  },
  draw: function (clip, context) {
    // draw legends horizontally
    var tracks = this.tracks;
    var shapeModel = this.shapeModel;
    var xpix = 0;
    var ypix = 0;
    context.textAlign = 'left';
    context.textBaseline = 'top';
    context.font = '12px ' + morpheus.CanvasUtil.FONT_NAME;
    context.fillStyle = morpheus.CanvasUtil.FONT_COLOR;
    context.strokeStyle = 'black';
    for (var i = 0; i < tracks.length; i++) {
      ypix = 0;
      var maxWidth = 0;
      var vector = tracks[i].getVector();
      context.fillText(vector.getName(), xpix, ypix);
      maxWidth = Math.max(maxWidth,
        context.measureText(vector.getName()).width);
      ypix += 14;
      var map = shapeModel.getMap(vector.getName());
      var values = map.keys().sort(morpheus.SortKey.ASCENDING_COMPARATOR);
      values.forEach(function (key) {
        var shape = shapeModel.getMappedValue(vector, key);
        var width = context.measureText(key).width;
        if (!isNaN(width)) {
          maxWidth = Math.max(maxWidth, width);
        }
        morpheus.CanvasUtil.drawShape(context, shape, xpix + 8,
          ypix + 6, 6);
        context.fillText(key, xpix + 16, ypix);
        ypix += 14;
      });

      xpix += maxWidth + 24; // space between columns + shape
    }
  }
};
morpheus.Util.extend(morpheus.HeatMapTrackShapeLegend, morpheus.AbstractCanvas);

/**
 * rows and columns can contain field, renameTo, display, order
 *
 */

morpheus.HeatMap = function (options) {
  morpheus.Util.loadTrackingCode();
  var _this = this;
  // don't extend
  var parent = options.parent;
  options.parent = null;
  options = $
    .extend(
      true,
      {},
      {
        /*
         * The element in which to render to the heat map.
         */
        el: null,
        /*
         * A File or URL to a <a target="_blank"
         * href="http://support.lincscloud.org/hc/en-us/articles/202105453-GCT-Gene-Cluster-Text-Format-">GCT
         * 1.3</a>, ' + '<a target="_blank"
         * href="http://www.broadinstitute.org/cancer/software/genepattern/gp_guides/file-formats/sections/gct">GCT
         * 1.2</a>, ' + '<a target="_blank"
         * href="https://wiki.nci.nih.gov/display/TCGA/Mutation+Annotation+Format+%28MAF%29+Specification">MAF</a>, ' + '<a
         * target="_blank",
         * href="http://www.broadinstitute.org/cancer/software/gsea/wiki/index.php/Data_formats#GMT:_Gene_Matrix_Transposed_file_format_.28.2A.gmt.29">GMT</a>, ' + '
         * or a tab-delimitted text file. Can also be an array
         * of File or URLs in which case the datasets are
         * combined by matching on column ids.
         */
        dataset: undefined,
        /*
         *
         * @description Array of file, datasetField, fileField,
         *              and include (optional fields to include
         *              from file). File can be xlsx file,
         *              tab-delimitted text file, or gmt file.
         *              <p>
         *              <b>Example:</b> Annotate rows matching
         *              'name' field in dataset to 'id' field in
         *              file.
         *              </p>
         *              <code>[{file:'https://MY_URL', datasetField:'name', fileField:'id'}]</code>
         */
        rowAnnotations: undefined,
        /*
         * Array of file, datasetField, fileField, and include
         * (optional fields to include from file). File can be
         * xlsx file, tab-delimitted text file, or gmt file.
         */
        columnAnnotations: undefined,

        /*
         * Array of column metadata names to group the heat map
         * by.
         *
         * <p>
         * <b>Example:</b> Group by the type and gender
         * metadata field.
         * </p>
         *
         * <code>['type', 'gender']</code>
         */
        columnGroupBy: undefined,
        /*
         * Array of row metadata names to group the heat map by.
         *
         * <p>
         * <b>Example:</b> Group by the gene metadata field.
         * </p>
         * <code>['gene']</code>
         */
        rowGroupBy: undefined,
        /*
         * Object that describes mapping of values to colors.
         * Type can be 'fixed' or 'relative'. Stepped indicates
         * whether color scheme is continuous (false) or
         * discrete (true).
         * <p>
         * <b>Example:</b> Use a fixed color scheme with color
         * stops at -100, -90, 90, and 100.
         * <p>
         * <code>{ type : 'fixed', stepped:false, map : [ { value : -100, color :
         * 'blue' }, { value : -90, color : 'white' }, { value :
         * 90, color : 'white' }, { value : 100, color : 'red' } ] };</code>
         */
        colorScheme: undefined,
        /*
         * Array of metadata names and sort order. Use 0 for
         * ascending and 1 for descending. To sort by values use
         * modelIndices.
         *
         * <p>
         * <b>Example:</b> Sort ascending by gene, and then
         * descending by stdev
         * </p>
         * <code>[{field:'gene', order:0}, {field:'stdev',
         *              order:1}]</code>
         */
        rowSortBy: undefined,
        /*
         * Array of metadata names and sort order. Use 0 for
         * ascending and 1 for descending.
         *
         * <p>
         * <b>Example:</b> to sort ascending by gene, and then
         * descending by stdev
         * </p>
         * <code> [{name:'gene',
         *              order:0}, {name:'stdev', order:1}]</code>
         */
        columnSortBy: undefined,
        /*
         * URL to a dendrogram in <a target="_blank"
         * href="https://en.wikipedia.org/wiki/Newick_format">Newick
         * format</a>
         */
        rowDendrogram: undefined,
        /*
         * URL to a dendrogram in <a target="_blank"
         * href="https://en.wikipedia.org/wiki/Newick_format">Newick
         * format</a>
         */
        columnDendrogram: undefined,

        /*
         * Column metadata field in dataset used to match leaf
         * node ids in column dendrogram Newick file
         */
        columnDendrogramField: 'id',
        /*
         * Row metadata field in dataset used to match leaf node
         * ids in row dendrogram Newick file
         */
        rowDendrogramField: 'id',
        /*
         * Array of objects describing how to display row
         * metadata fields. Each object in the array must have
         * field, and optionally display, order, and renameTo.
         * Field is the metadata field name. Display is a comma
         * delimited string that describes how to render a
         * metadata field. Options are text, color, stacked_bar,
         * bar, highlight, shape, discrete, and continuous.
         * Order is a number that indicates the order in which
         * the field should appear in the heat map. RenameTo
         * allows you to rename a field.
         */
        rows: [],
        /*
         * Array of objects describing how to display column
         * metadata fields. Each object in the array must have
         * field, and optionally display, order, and renameTo.
         * Field is the metadata field name. Display is a comma
         * delimited string that describes how to render a
         * metadata field. Options are text, color, stacked_bar,
         * bar, highlight, shape, discrete, and continuous.
         * Order is a number that indicates the order in which
         * the field should appear in the heat map. RenameTo
         * allows you to rename a field.
         */
        columns: [],
        /*
         * Optional array of tools to run at load time. For
         * example: <code>tools : [ {
         * name : 'Marker Selection',
         * params : {
         * 		field : [ comparisonVector.getName() ],
         *      class_a : [ 'A' ], class_b : [ 'B' ] }} ]</code>
         */
        tools: undefined,
        /*
         * Optional array of {name:string, values:[]}
         */
        rowFilter: undefined,
        columnFilter: undefined,
        /*
         * Whether to auto-hide the tab bar when only one tab is visible
         */
        autohideTabBar: false,
        /*
         * Whether this heat map tab can be closed
         */
        closeable: true,
        /*
         * Whether heat map tab can be renamed
         */
        rename: true,
        rowSize: undefined,
        columnSize: undefined,
        customUrls: undefined, // Custom urls for File>Open.
        height: 'window', // set the available height for the
        // heat map. If not
        // set, it will be determined automatically
        width: undefined, // set the available width for the
        // heat map. If not
        // set, it will be determined automatically
        /* Whether to focus this tab */
        focus: true,
        tooltipMode: 0, // 0=top status bar, 1=dialog, 2=follow
        inheritFromParent: true,
        inheritFromParentOptions: {
          transpose: false
        },
        /** Callback function to invoke for customizing inline matrix tooltips. */
        tooltip: undefined,
        structureUrlProvider: undefined,
        promises: undefined, // additional promises to wait
        // for
        // not inherited
        renderReady: undefined,
        // not inherited
        datasetReady: undefined,
        // inherited
        tabOpened: undefined,
        loadedCallback: undefined,
        name: undefined,
        rowsSortable: true,
        columnsSortable: true,
        popupEnabled: true,
        symmetric: false,
        keyboard: true,
        inlineTooltip: true,
        $loadingImage: morpheus.Util.createLoadingEl(),
        menu: {
          File: ['Open', 'Save Image', 'Save Dataset', 'Save Session', null, 'Close Tab', 'Rename Tab'],
          Tools: ['New Heat Map', null, 'Hierarchical Clustering', 'Marker Selection', 'Nearest Neighbors',
            'Adjust', 'Collapse', 'Create Calculated Annotation', 'Similarity Matrix', 'Transpose',
            't-SNE', null, 'Chart', null, 'Sort', 'Filter', null, 'API', null, 'k-means', 'limma', 'PCA Plot'],
          View: ['Zoom In', 'Zoom Out', 'Fit To Window', 'Reset Zoom', null, 'Options'],
          Edit: ['Copy Image', 'Copy Selected Dataset', null, 'Move Selected Rows To Top', 'Annotate Selected Rows', 'Invert' +
          ' Selected Rows', 'Copy Selected Rows', 'Select All Rows', null, 'Move Selected Columns' +
          ' To Top', 'Annotate Selected Columns', 'Invert Selected Columns', 'Copy Selected' +
          ' Columns', 'Select' +
          ' All' +
          ' Columns'],
          Help: ['Find Action', null, 'Contact', 'Linking', 'Tutorial', 'Source Code', null, 'Keymap' +
          ' Reference']
        },
        toolbar: {
          dimensions: true,
          zoom: true,
          searchRows: true,
          searchColumns: true,
          searchValues: false,
          options: true,
          saveImage: true,
          filter: true,
          colorKey: true
        }
      }, options);
  options.parent = parent;
  if (options.menu == null) {
    options.menu = {};
  }
  this.options = options;
  this.tooltipProvider = morpheus.HeatMapTooltipProvider;
  if (!options.el) {
    this.$el = $('<div></div>');
  } else {
    this.$el = $(options.el);
  }
  this.actionManager = new morpheus.ActionManager();
  this.actionManager.heatMap = this;
  this.$el.addClass('morpheus');
  if (!options.landingPage) {
    options.landingPage = new morpheus.LandingPage();
    options.landingPage.$el.prependTo(this.$el);
  }

  if (this.options.dataset == null) {
    var datasetFormBuilder = new morpheus.FormBuilder();
    datasetFormBuilder.append({
      name: 'file',
      type: 'file'
    });
    this.options.dataset = $.Deferred();
    morpheus.FormBuilder.showOkCancel({
      title: 'Dataset',
      appendTo: this.getContentEl(),
      content: datasetFormBuilder.$form,
      okCallback: function () {
        var file = datasetFormBuilder.getValue('file');
        morpheus.DatasetUtil.read(file).done(function (dataset) {
          _this.options.dataset.resolve(dataset);
        }).fail(function (err) {
          _this.options.dataset.reject(err);
        });
      },
      cancelCallback: function () {
        _this.options.dataset.reject('Session cancelled.');
      }
    });
  }
  if (this.options.name == null) {
    this.options.name = morpheus.Util
      .getBaseFileName(morpheus.Util
        .getFileName(this.options.dataset.file ? this.options.dataset.file
          : this.options.dataset));
  }

  var isPrimary = this.options.parent == null;
  if (this.options.parent == null) {

    this.tabManager = this.options.tabManager != null ? this.options.tabManager
      : new morpheus.TabManager({
      landingPage: this.options.landingPage,
      autohideTabBar: this.options.autohideTabBar
    });

    if (!this.options.tabManager) {
      this.tabManager.appendTo(this.$el);
    }
  } else {
    if (this.options.inheritFromParent) {
      this.popupItems = this.options.parent.popupItems;
      if (!this.options.tabOpened) {
        this.options.tabOpened = this.options.parent.options.tabOpened;
      }
      this.options.drawCallback = this.options.parent.options.drawCallback;
    }
    this.tabManager = this.options.parent.tabManager;
  }
  this.$content = $('<div></div>');
  this.$content.css({
    'width': '100%',
    'user-select': 'none',

    '-webkit-user-select': 'none',
    '-webkit-user-drag': 'none',
    '-webkit-tap-highlight-color': 'rgba(0, 0, 0, 0)',

    '-moz-user-select': 'none',
    '-moz-user-drag': 'none',
    '-moz-tap-highlight-color': 'rgba(0, 0, 0, 0)',

    '-ms-user-select': 'none',
    '-ms-user-drag': 'none',
    '-ms-tap-highlight-color': 'rgba(0, 0, 0, 0)',

    '-o-user-select': 'none',
    '-o-user-drag': 'none',
    '-o-tap-highlight-color': 'rgba(0, 0, 0, 0)',

    'overflow-x': 'visible',
    'overflow-y': 'visible'
  });

  this.$content.on('remove.morpheus', function () {
    _this.$content.off('remove.morpheus');
    _this.dispose();
  });
  var tab = this.tabManager.add({
    $el: this.$content,
    closeable: this.options.closeable,
    rename: this.options.rename,
    title: this.options.name,
    object: this,
    focus: this.options.focus
  });
  this.tabId = tab.id;
  this.$tabPanel = tab.$panel;

  if (options.$loadingImage) {
    options.$loadingImage.appendTo(this.$content);
  }

  this.options.dataSource = !options.dataset ? ''
    : (options.dataset.file ? options.dataset.file : options.dataset);
  this._togglingInfoWindow = false;

  var promises = [];
  if (options.promises) {
    for (var i = 0; i < options.promises.length; i++) {
      promises.push(options.promises[i]);
    }
  }
  this.whenLoaded = [];

  if (options.rowAnnotations) {
    var rowDef = morpheus.DatasetUtil.annotate({
      annotations: options.rowAnnotations,
      isColumns: false
    });
    rowDef.done(function (callbacks) {
      _this.whenLoaded = _this.whenLoaded.concat(callbacks);
    });
    promises.push(rowDef);

  }
  console.log("HeatMap creation ::", options.columnAnnotations);
  if (options.columnAnnotations) {
    var columnDef = morpheus.DatasetUtil.annotate({
      annotations: options.columnAnnotations,
      isColumns: true
    });
    columnDef.done(function (callbacks) {
      _this.whenLoaded = _this.whenLoaded.concat(callbacks);
    });
    promises.push(columnDef);
  }

  if (options.rowDendrogram !== undefined
    && _.isString(options.rowDendrogram)) {
    if (options.rowDendrogram[0] === '(') {
      _this.options.rowDendrogram = morpheus.DendrogramUtil
        .parseNewick(options.rowDendrogram);
    } else {
      var rowDendrogramDeferred = morpheus.Util
        .getText(options.rowDendrogram);
      rowDendrogramDeferred.done(function (text) {
        _this.options.rowDendrogram = morpheus.DendrogramUtil
          .parseNewick(text);
      });
      promises.push(rowDendrogramDeferred);
    }

  }
  if (options.columnDendrogram !== undefined
    && _.isString(options.columnDendrogram)) {
    if (options.columnDendrogram[0] === '(') {
      _this.options.columnDendrogram = morpheus.DendrogramUtil
        .parseNewick(options.columnDendrogram);
    } else {
      var columnDendrogramDeferred = morpheus.Util
        .getText(options.columnDendrogram);
      columnDendrogramDeferred.done(function (text) {
        _this.options.columnDendrogram = morpheus.DendrogramUtil
          .parseNewick(text);
      });
      promises.push(columnDendrogramDeferred);
    }

  }
  var heatMapLoaded = function () {
    morpheus.DatasetUtil.toESSessionPromise(options.dataset);
    if (typeof window !== 'undefined') {
      $(window).on('orientationchange.morpheus resize.morpheus', _this.resizeListener = function () {
        _this.revalidate();
      });
    }
    _this.revalidate();
    if (options.loadedCallback) {
      options.loadedCallback(_this);
    }

    if (_this.options.focus) {
      _this.tabManager.setActiveTab(tab.id);
      _this.focus();
    } else if (_this.tabManager.getTabCount() === 1) {
      _this.tabManager.setActiveTab(tab.id);
    }
    _this.$el.trigger('heatMapLoaded', _this);
  };
  if (morpheus.Util.isArray(options.dataset)) {
    var d = morpheus.DatasetUtil.readDatasetArray(options.dataset);
    d.fail(function (message) {
      if (_this.options.$loadingImage) {
        _this.options.$loadingImage.remove();
      }
      morpheus.FormBuilder.showInModal({
        title: 'Error',
        html: message,
        appendTo: _this.getContentEl()
      });
    });
    d
      .done(function (joined) {
        if (_this.options.$loadingImage) {
          _this.options.$loadingImage.remove();
        }

        _this.options.dataset = joined;
        _this._init();
        if (joined.getRowMetadata().getByName('Source') != null
          && !_this.options.colorScheme) {
          _this.heatmap.getColorScheme()
            .setSeparateColorSchemeForRowMetadataField(
              'Source');
        }

        _
          .each(
            options.dataset,
            function (option) {
              if (option.colorScheme) {
                _this.heatmap
                  .getColorScheme()
                  .setCurrentValue(
                    morpheus.Util
                      .getBaseFileName(morpheus.Util
                        .getFileName(option.dataset)));
                _this.heatmap
                  .getColorScheme()
                  .setColorSupplierForCurrentValue(
                    morpheus.HeatMapColorScheme
                      .createColorSupplier(option.colorScheme));

              } else {
                try {
                  _this
                    .autoDisplay({
                      extension: morpheus.Util
                        .getExtension(morpheus.Util
                          .getFileName(option.dataset)),
                      filename: morpheus.Util
                        .getBaseFileName(morpheus.Util
                          .getFileName(option.dataset))
                    });
                }
                catch (x) {
                  console
                    .log('Autodisplay errror');
                }

              }
            });

        heatMapLoaded();
      });
  } else {
    var deferred = options.dataset.file ? morpheus.DatasetUtil.read(
      options.dataset.file, options.dataset.options)
      : morpheus.DatasetUtil.read(options.dataset);
    deferred.done(function (dataset) {
      _this.options.dataset = dataset;
    });
    deferred.fail(function (err) {
      _this.options.$loadingImage.remove();
      var message = ['Error opening '
      + (options.dataset.file ? morpheus.Util
        .getFileName(options.dataset.file) : morpheus.Util
        .getFileName(options.dataset)) + '.'];

      if (err.message) {
        message.push('<br />Cause: ');
        message.push(err.message);

      }

      morpheus.FormBuilder.showInModal({
        title: 'Error',
        html: message.join(''),
        appendTo: _this.getContentEl()
      });
    });

    promises.push(deferred);
    var datasetOverlay = null;
    if (options.datasetOverlay) {
      var d = options.datasetOverlay.file ? morpheus.DatasetUtil.read(
        options.datasetOverlay.file, options.datasetOverlay.options)
        : morpheus.DatasetUtil.read(options.datasetOverlay);
      d.done(function (dataset) {
        datasetOverlay = dataset;
      });
      promises.push(d);
    }
    $.when.apply($, promises).done(function () {

      if (_this.options.$loadingImage) {
        _this.options.$loadingImage.remove();
      }
      if (_this.options.dataset == null) {
        return _this.tabManager.remove(_this.tabId);
      }
      _this._init();
      if (datasetOverlay) {
        morpheus.DatasetUtil.overlay({
          dataset: _this.options.dataset,
          newDataset: datasetOverlay,
          rowAnnotationName: 'id',
          newRowAnnotationName: 'id',
          columnAnnotationName: 'id',
          newColumnAnnotationName: 'id'
        });
      }
      heatMapLoaded();
    });
  }
};

morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS = 6;

morpheus.HeatMap.showTool = function (tool, heatMap, callback) {
  console.log("HeatMap.showTool::", tool, heatMap);
  if (tool.gui) {
    var gui = tool.gui(heatMap.getProject());
    var formBuilder = new morpheus.FormBuilder();
    _.each(gui, function (item) {
      formBuilder.append(item);
    });
    var tabId = heatMap.getTabManager().getActiveTabId();
    if (tool.init) {
      tool.init(heatMap.getProject(), formBuilder, {
        heatMap: heatMap
      });
    }
    heatMap.trigger('beforeToolShown', {
      tool: tool,
      formBuilder: formBuilder
    });
    var okCallback = function () {
      var task = {
        name: tool.toString(),
        tabId: tabId
      };
      heatMap.getTabManager().addTask(task);
      var input = {};
      _.each(gui, function (item) {
        input[item.name] = formBuilder.getValue(item.name);
      });
      var value = tool.execute({
        heatMap: heatMap,
        project: heatMap.getProject(),
        input: input
      });
      if (value instanceof Worker) {
        value.onerror = function (e) {
          task.worker.terminate();
          morpheus.FormBuilder.showInModal({
            title: 'Error',
            html: e,
            close: 'Close',
            focus: heatMap.getFocusEl(),
            appendTo: heatMap.getContentEl()
          });
          if (e.stack) {
            console.log(e.stack);
          }
        };
        var terminate = _.bind(value.terminate, value);
        task.worker = value;
        value.terminate = function () {
          terminate();
          heatMap.getTabManager().removeTask(task);
          if (callback) {
            callback(input);
          }
        };
      } else {
        if (callback) {
          callback(input);
        }
      }
    };
    var $formDiv;
    tool.ok = function () {
      $formDiv.modal('hide');
      okCallback();
    };
    var guiOptions = $.extend({}, {
      ok: true
    }, gui.options);
    $formDiv = morpheus.FormBuilder.showOkCancel({
      title: tool.toString(),
      apply: tool.apply,
      ok: guiOptions.ok,
      size: guiOptions.size,
      draggable: true,
      content: formBuilder.$form,
      appendTo: heatMap.getContentEl(),
      align: 'right',
      okCallback: okCallback,
      focus: heatMap.getFocusEl()
    });
  }
  else { // run headless
    tool.execute({
      heatMap: heatMap,
      project: heatMap.getProject(),
      input: {}
    });
    if (callback) {
      callback({});
    }
  }
};

morpheus.HeatMap.getSpaces = function (groupByKeys, length, gapSize) {
  var previousArray = [];
  var nkeys = groupByKeys.length;
  for (var keyIndex = 0; keyIndex < nkeys; keyIndex++) {
    var key = groupByKeys[keyIndex];
    previousArray.push(key.getValue(0));
  }
  var spaces = [];
  var sum = 0;
  spaces.push(sum);
  for (var i = 1; i < length; i++) {
    var isEqual = true;
    for (var keyIndex = 0; keyIndex < nkeys; keyIndex++) {
      var key = groupByKeys[keyIndex];
      var comparator = key.getComparator();
      var val = key.getValue(i);
      var c = comparator(val, previousArray[keyIndex]);
      if (c !== 0) { // not equal, add space
        isEqual = false;
        for (var keyIndex2 = 0; keyIndex2 < nkeys; keyIndex2++) {
          previousArray[keyIndex2] = groupByKeys[keyIndex2]
            .getValue(i);
        }
        break;
      }
    }
    if (!isEqual) {
      sum += gapSize;
    }
    spaces.push(sum);
  }
  return spaces;
};
morpheus.HeatMap.createGroupBySpaces = function (dataset, groupByKeys, gapSize, isColumns) {
  if (groupByKeys.length > 0) {
    var nkeys = groupByKeys.length;
    for (var keyIndex = 0; keyIndex < nkeys; keyIndex++) {
      groupByKeys[keyIndex].init(groupByKeys[keyIndex].isColumns() ? new morpheus.TransposedDatasetView(dataset) : dataset);
    }
    return morpheus.HeatMap.getSpaces(groupByKeys, isColumns ? dataset.getColumnCount() : dataset.getRowCount(),
      gapSize);
  }
};
morpheus.HeatMap.isDendrogramVisible = function (project, isColumns) {
  var sortKeys = isColumns ? project.getColumnSortKeys() : project
    .getRowSortKeys();
  // var filter = isColumns ? this.project.getColumnFilter()
  //   : this.project.getRowFilter();
  // // FIXME compare filters
  var size = isColumns ? project.getSortedFilteredDataset().getColumnCount()
    : project.getSortedFilteredDataset().getRowCount();
  return sortKeys.length === 1 && sortKeys[0] instanceof morpheus.SpecifiedModelSortOrder
    && sortKeys[0].name === 'dendrogram'
    && sortKeys[0].nvisible === size;

};

morpheus.HeatMap.prototype = {
  gapSize: 10,
  updatingScroll: false,
  getWhitespaceEl: function () {
    return this.$whitespace;
  },
  getActionManager: function () {
    return this.actionManager;
  },
  autoDisplay: function (options) {
    if (options.filename == null) {
      options.filename = '';
    }
    var colorScheme;
    if (options.extension === 'segtab' || options.extension === 'seg') {
      colorScheme = {
        type: 'fixed',
        map: morpheus.HeatMapColorScheme.Predefined.CN().map
          .map(function (item) {
            return {
              value: Math.pow(2, 1 + item.value),
              color: item.color
            };
          })
      };
    } else if (options.extension === 'maf') {
      colorScheme = morpheus.HeatMapColorScheme.Predefined.MAF();
      var colorMap = morpheus.HeatMapColorScheme.Predefined.MAF().map;
      var rowMutProfile = this.project.getFullDataset().getRowMetadata()
        .getByName('mutation_summary');
      var fieldNames = rowMutProfile.getProperties().get(morpheus.VectorKeys.FIELDS);
      var useMafColorMap = true;
      if (fieldNames.length !== morpheus.MafFileReader.FIELD_NAMES.length) {
        useMafColorMap = false;
      } else {
        for (var i = 0; i < fieldNames.length; i++) {
          if (fieldNames[i] !== morpheus.MafFileReader.FIELD_NAMES[i]) {
            useMafColorMap = false;
            break;
          }
        }
      }
      if (!useMafColorMap) {
        colorScheme = {
          type: 'fixed',
          stepped: true,
          map: [{
            value: 0,
            color: 'rgb(255,255,255)'
          }]
        };
        for (var i = 0; i < fieldNames.length; i++) {
          colorScheme.map.push({
            value: i + 1,
            color: morpheus.VectorColorModel.TWENTY_COLORS[i % morpheus.VectorColorModel.TWENTY_COLORS.length],
            name: fieldNames[i]
          });
        }
        colorMap = colorScheme.map;
      }
      var columnMutationSummaryVectors = [];
      var columnMutationSummaryNames = ['mutation_summary', 'mutation_summary_selection'];
      for (var i = 0; i < columnMutationSummaryNames.length; i++) {
        var name = columnMutationSummaryNames[i];
        if (this.project.getFullDataset()
            .getColumnMetadata().getByName(name)) {
          columnMutationSummaryVectors.push(this.project.getFullDataset()
            .getColumnMetadata().getByName(name));
          track = this.getTrack(name, true);
          if (track) {
            track.settingFromConfig('stacked_bar');
            if (name === 'mutation_summary_selection') {
              track.settings.autoscaleAlways = true;
            }
          }
        }
      }

      var track = this.getTrack('mutation_summary', false);
      if (track) {
        track.settingFromConfig('stacked_bar');
      }

      for (var i = 1; i < colorMap.length; i++) {
        if (rowMutProfile) {
          this.getProject().getRowColorModel().setMappedValue(
            rowMutProfile, i - 1, colorMap[i].color);
        }
        for (var j = 0; j < columnMutationSummaryVectors.length; j++) {
          this.getProject().getColumnColorModel().setMappedValue(
            columnMutationSummaryVectors[j], i - 1, colorMap[i].color);
        }

      }
    } else if (options.extension === 'gmt') {
      colorScheme = morpheus.HeatMapColorScheme.Predefined.BINARY();
    } else if (options.filename === 'all_lesions.conf_99'
      || options.filename === 'all_data_by_genes.txt' || options.filename.toLowerCase().indexOf('gistic') !== -1) {
      colorScheme = {
        type: 'fixed',
        map: [{
          value: -0.5,
          color: 'blue'
        }, {
          value: 0,
          color: 'white'
        }, {
          value: 0.5,
          color: 'red'
        }]
      };
    } else if (options.filename.toLowerCase().indexOf('copynumber') !== -1 || options.filename.toLowerCase().indexOf('copy number') !== -1) {
      colorScheme = {
        type: 'fixed',
        map: [{
          value: -1.5,
          color: 'blue'
        }, {
          value: 0,
          color: 'white'
        }, {
          value: 1.5,
          color: 'red'
        }]
      };
    } else if (options.filename.toLowerCase().indexOf('achilles') !== -1) {
      colorScheme = {
        type: 'fixed',
        map: [{
          value: -3,
          color: 'blue'
        }, {
          value: -1,
          color: 'white'
        }, {
          value: 1,
          color: 'white'
        }, {
          value: 3,
          color: 'red'
        }]
      };
    }

    if (colorScheme && options.filename && this.heatmap.getColorScheme()) {
      this.heatmap.getColorScheme().setCurrentValue(options.filename);
      this.heatmap.getColorScheme().setColorSupplierForCurrentValue(
        morpheus.HeatMapColorScheme
          .createColorSupplier(colorScheme));
    }
    return colorScheme;
  },
  /**
   *
   * @param sortOrder
   * @param isColumns
   *            Whether sorting based on column selection
   * @param append
   *            Whether to add to existing sort order
   */
  sortBasedOnSelection: function (sortOrder, isColumns, append) {
    // if isColumns, sort rows
    var project = this.project;
    var selectionModel = isColumns ? project.getColumnSelectionModel()
      : project.getRowSelectionModel();
    var modelIndices = selectionModel.toModelIndices();
    if (modelIndices.length === 0) {
      return;
    }

    var priorSortKeyIndex = -1;
    if (sortOrder == null) {
      // toggle sort order?
      var existingSortKeys = isColumns ? project.getRowSortKeys()
        : project.getColumnSortKeys();
      for (var i = 0, length = existingSortKeys.length; i < length; i++) {
        var key = existingSortKeys[i];
        if (key instanceof morpheus.SortByValuesKey
          && morpheus.Util.arrayEquals(key.modelIndices,
            modelIndices)) {
          priorSortKeyIndex = i;
          if (key.getSortOrder() === morpheus.SortKey.SortOrder.UNSORTED) {
            sortOrder = morpheus.SortKey.SortOrder.DESCENDING; // 1st
            // click
          } else if (key.getSortOrder() === morpheus.SortKey.SortOrder.DESCENDING) {
            sortOrder = morpheus.SortKey.SortOrder.ASCENDING; // 2nd
            // click
          } else if (key.getSortOrder() === morpheus.SortKey.SortOrder.ASCENDING) {
            sortOrder = morpheus.SortKey.SortOrder.TOP_N; // 3rd
            // click
          } else if (key.getSortOrder() === morpheus.SortKey.SortOrder.TOP_N) {
            sortOrder = morpheus.SortKey.SortOrder.UNSORTED; // 4th
            // click
          }
          break;
        }
      }

    }

    if (sortOrder == null) {
      sortOrder = morpheus.SortKey.SortOrder.DESCENDING;
    }

    var sortKeys;
    if (append) {
      sortKeys = !isColumns ? project.getColumnSortKeys() : project
        .getRowSortKeys();

      if (priorSortKeyIndex !== -1) {
        if (sortOrder === morpheus.SortKey.SortOrder.UNSORTED) {
          // remove existing sort key
          sortKeys.splice(priorSortKeyIndex, 1);
        } else {
          sortKeys[priorSortKeyIndex].setSortOrder(sortOrder);
        }

      } else {
        if (sortOrder !== morpheus.SortKey.SortOrder.UNSORTED) {
          sortKeys.push(new morpheus.SortByValuesKey(modelIndices,
            sortOrder, !isColumns));
        }
        // add new sort key
      }

      sortKeys = morpheus.SortKey.keepExistingSortKeys(sortKeys,
        !isColumns ? project.getColumnSortKeys() : project
          .getRowSortKeys());

    } else {
      var newSortKeys = sortOrder === morpheus.SortKey.SortOrder.UNSORTED ? []
        : [new morpheus.SortByValuesKey(modelIndices, sortOrder,
        !isColumns)];
      sortKeys = morpheus.SortKey.keepExistingSortKeys(newSortKeys,
        !isColumns ? project.getColumnSortKeys() : project
          .getRowSortKeys());
    }

    if (!isColumns) { // sort columns by selected rows
      project.setColumnSortKeys(sortKeys, true);
      this.scrollLeft(0);
    } else { // sort rows by selected column
      project.setRowSortKeys(sortKeys, true);
      this.scrollTop(0);
    }
    morpheus.Util.trackEvent({
      eventCategory: 'Tool',
      eventAction: isColumns ? 'sortRowsBasedOnSelection' : 'sortColumnsBasedOnSelection'
    });

  },
  getToolbarElement: function () {
    return this.toolbar.$el;
  },
  getToolbar: function () {
    return this.toolbar;
  },
  setName: function (name) {
    this.options.name = name;
  },
  getName: function () {
    return this.options.name;
  },
  showOptions: function () {
    new morpheus.HeatMapOptions(this);
  },
  getProject: function () {
    return this.project;
  },
  getDendrogram: function (isColumns) {
    return isColumns ? this.columnDendrogram : this.rowDendrogram;
  },
  toJSON: function (options) {
    var json = {};
    // color scheme
    json.colorScheme = this.heatmap.getColorScheme().toJSON();

    json.name = this.options.name;

    // TODO shapes

    // annotation colors
    json.rowColorModel = this.getProject().getRowColorModel().toJSON();
    json.columnColorModel = this.getProject().getColumnColorModel().toJSON();
    // annotation display
    json.rows = this.rowTracks.map(function (track) {
      return {
        field: track.getName(),
        display: track.settings
      };
    });
    json.columns = this.columnTracks.map(function (track) {
      return {
        field: track.getName(),
        display: track.settings
      };
    });
    // sort
    json.rowSortBy = morpheus.SortKey.toJSON(this.getProject().getRowSortKeys());
    json.columnSortBy = morpheus.SortKey.toJSON(this.getProject().getColumnSortKeys());

    // group
    json.rowGroupBy = morpheus.SortKey.toJSON(this.getProject().getGroupRows());
    json.columnGroupBy = morpheus.SortKey.toJSON(this.getProject().getGroupColumns());

    // filter
    json.rowFilter = morpheus.CombinedFilter.toJSON(this.getProject().getRowFilter());
    json.columnFilter = morpheus.CombinedFilter.toJSON(this.getProject().getColumnFilter());

    // element size, symmetric
    json.symmetric = this.options.symmetric;
    json.rowSize = this.heatmap.getRowPositions().getSize();
    json.drawGrid = this.heatmap.isDrawGrid();
    json.gridColor = this.heatmap.getGridColor();
    json.gridThickness = this.heatmap.getGridThickness();
    json.drawValues = this.heatmap.isDrawValues();

    // selection
    json.rowSelection = this.getProject().getRowSelectionModel().toModelIndices();
    json.columnSelection = this.getProject().getColumnSelectionModel().toModelIndices();

    // search terms
    json.rowSearchTerm = this.toolbar.getSearchField(morpheus.HeatMapToolBar.ROW_SEARCH_FIELD).val();
    json.columnSearchTerm = this.toolbar.getSearchField(morpheus.HeatMapToolBar.COLUMN_SEARCH_FIELD).val();

    //  dendrogram
    if (this.rowDendrogram != null) {
      var out = [];
      morpheus.DendrogramUtil.writeNewick(this.rowDendrogram.tree.rootNode, out);
      json.rowDendrogram = out.join('');
      json.rowDendrogramField = null;
    }
    if (this.columnDendrogram != null) {
      var out = [];
      morpheus.DendrogramUtil.writeNewick(this.columnDendrogram.tree.rootNode, out);
      json.columnDendrogram = out.join('');
      json.columnDendrogramField = null;
    }
    if (options.dataset) {
      json.dataset = morpheus.Dataset.toJSON(this.getProject().getFullDataset());
    }

    return json;
  },
  /**
   * @param tree
   *            An object with maxHeight, a rootNode, leafNodes, and
   *            nLeafNodes
   */
  setDendrogram: function (tree, isColumns, modelOrder) {
    var dendrogram = isColumns ? this.columnDendrogram : this.rowDendrogram;
    if (dendrogram) {
      dendrogram.dispose();
      dendrogram = null;
    }
    if (tree != null) {
      //  var modelIndexSet = new morpheus.Set();
      var size = isColumns ? this.project.getFullDataset()
        .getColumnCount() : this.project.getFullDataset()
        .getRowCount();
      if (isColumns) {
        dendrogram = new morpheus.ColumnDendrogram(this, tree,
          this.heatmap.getColumnPositions(), this.project);
        dendrogram.filter = this.project.getColumnFilter()
          .shallowClone();
        this.columnDendrogram = dendrogram;
        this.project.setColumnSortKeys(
          [new morpheus.SpecifiedModelSortOrder(modelOrder,
            modelOrder.length, 'dendrogram', true)], true);
      } else {
        dendrogram = new morpheus.RowDendrogram(this, tree,
          this.heatmap.getRowPositions(), this.project);
        dendrogram.filter = this.project.getRowFilter().shallowClone();
        this.rowDendrogram = dendrogram;
        this.project.setRowSortKeys(
          [new morpheus.SpecifiedModelSortOrder(modelOrder,
            modelOrder.length, 'dendrogram', false)], true);
      }
      dendrogram.appendTo(this.$parent);
      dendrogram.$label.appendTo(this.$parent);
      dendrogram.$squishedLabel.appendTo(this.$parent);

    } else { // no more dendrogram
      var sortKeys = isColumns ? this.project.getColumnSortKeys()
        : this.project.getRowSortKeys();
      // remove dendrogram sort key
      for (var i = 0; i < sortKeys.length; i++) {
        if (sortKeys[i] instanceof morpheus.SpecifiedModelSortOrder
          && sortKeys[i].name === 'dendrogram') {
          sortKeys.splice(i, 1);
          i--;
        }
      }
      if (isColumns) {
        this.heatmap.getColumnPositions().setSquishedIndices(null);
        delete this.columnDendrogram;
        this.project.setColumnSortKeys(sortKeys, true);
      } else {
        delete this.rowDendrogram;
        this.project.setRowSortKeys(sortKeys, true);
        this.heatmap.getRowPositions().setSquishedIndices(null);
      }

    }
    // FIXME update grouping
    this.trigger('dendrogramChanged', {
      isColumns: isColumns
    });
  },

  setCustomUrls: function (customUrls) {
    this._customUrls = customUrls;
  },
  getTabManager: function () {
    return this.tabManager;
  },
  getSelectedElementsText: function () {
    var _this = this;
    var project = this.project;
    var selectedViewIndices = project.getElementSelectionModel()
      .getViewIndices();
    if (selectedViewIndices.size() > 0) {
      var tipText = [];
      var dataset = project.getSortedFilteredDataset();
      var rowTracks = _this.rowTracks.filter(function (t) {
        return t.settings.inlineTooltip;
      });
      var columnTracks = _this.columnTracks.filter(function (t) {
        return t.settings.inlineTooltip;
      });
      selectedViewIndices.forEach(function (id) {
        var rowIndex = id.getArray()[0];
        var columnIndex = id.getArray()[1];
        tipText.push(morpheus.Util.nf(dataset.getValue(rowIndex,
          columnIndex)));
        rowTracks.forEach(function (track) {
          tipText.push('\t');
          tipText.push(morpheus.Util.toString(dataset
            .getRowMetadata().getByName(track.name).getValue(
              rowIndex)));
        });
        columnTracks.forEach(function (track) {
          tipText.push('\t');
          tipText.push(morpheus.Util.toString(dataset
            .getColumnMetadata().getByName(track.name)
            .getValue(columnIndex)));
        });

        tipText.push('\n');

      });
      return tipText.join('');

    }

  },
  _init: function () {
    var _this = this;
    morpheus.MetadataUtil.renameFields(this.options.dataset, this.options);
    var dataset = this.options.dataset;
    var rowDendrogram = this.options.rowDendrogram;
    var columnDendrogram = this.options.columnDendrogram;
    _.each(this.whenLoaded, function (f) {
      f(_this.options.dataset);
    });
    if (this.options.datasetReady) {
      var updatedDataset = this.options.datasetReady(dataset);
      if (updatedDataset) {
        dataset = updatedDataset;
      }
    }

    this.project = new morpheus.Project(dataset);

    this.tabManager.setTabTitle(this.tabId, this.project.getFullDataset()
        .getRowCount()
      + ' row'
      + morpheus.Util.s(this.project.getFullDataset().getRowCount())
      + ' x '
      + this.project.getFullDataset().getColumnCount()
      + ' column'
      + morpheus.Util.s(this.project.getFullDataset()
        .getColumnCount()));
    if (this.options.inheritFromParent && this.options.parent != null) {
      morpheus.HeatMap.copyFromParent(this.project, this.options);
    }

    // filter ui will be initialized automatically
    if (this.options.rowFilter) {
      morpheus.CombinedFilter.fromJSON(_this.project.getRowFilter(), this.options.rowFilter);
      _this.project.setRowFilter(_this.project.getRowFilter(), true);
    }
    if (this.options.columnFilter) {
      morpheus.CombinedFilter.fromJSON(_this.project.getColumnFilter(), this.options.columnFilter);
      _this.project.setColumnFilter(_this.project.getColumnFilter(), true);
    }
    this.whenLoaded = null;
    this.$parent = $('<div></div>').css('position', 'relative');

    this.$parent.appendTo(this.$content);
    this.toolbar = new morpheus.HeatMapToolBar(this);
    if (this.options.customUrls) {
      this.setCustomUrls(this.options.customUrls);
    }

    // scroll bars at the bottom of the heatmap, and right of the heatmap
    // TODO along bottom of row metadata, and along left of column metadata
    // the viewport is the size of the visible region, the view is the full
    // size of the heat map
    this.vscroll = new morpheus.ScrollBar(true);
    this.vscroll.appendTo(this.$parent);
    this.vscroll.on('scroll', function () {
      if (_this.updatingScroll) {
        return;
      }
      _this.paintAll({
        paintRows: true,
        paintColumns: false,
        invalidateRows: true,
        invalidateColumns: false
      });
    });

    // for resizing column dendrogram
    this.beforeColumnTrackDivider = new morpheus.Divider(false);
    this.beforeColumnTrackDivider.appendTo(this.$parent);
    var dragStartHeight = 0;
    this.beforeColumnTrackDivider.on('resizeStart', function (e) {
      dragStartHeight = _this.columnDendrogram.getUnscaledHeight();
    }).on('resize', function (e) {
      // grow or shrink the column dendrogram
      var newHeight = Math.max(8, dragStartHeight + e.delta);
      _this.columnDendrogram.setPrefHeight(newHeight);
      _this.revalidate();
    }).on('resizeEnd', function () {
      dragStartHeight = 0;
    });

    // for resizing row dendrogram
    this.afterRowDendrogramDivider = new morpheus.Divider(true);
    this.afterRowDendrogramDivider.appendTo(this.$parent);
    var rowDendrogramStartWidth = 0;
    this.afterRowDendrogramDivider.on('resizeStart', function (e) {
      rowDendrogramStartWidth = _this.rowDendrogram.getUnscaledWidth();
    }).on('resize', function (e) {
      // grow or shrink the column dendrogram
      var newWidth = Math.max(8, rowDendrogramStartWidth + e.delta);
      _this.rowDendrogram.setPrefWidth(newWidth);
      _this.revalidate();
    }).on('resizeEnd', function () {
      rowDendrogramStartWidth = 0;
    });

    this.afterVerticalScrollBarDivider = new morpheus.Divider(true);
    this.afterVerticalScrollBarDivider.appendTo(this.$parent);
    var resizeStartHeatMapWidth = 0;
    this.afterVerticalScrollBarDivider.on('resizeStart', function (e) {
      resizeStartHeatMapWidth = _this.heatmap.getUnscaledWidth();
    }).on('resize', function (e) {
      // grow or shrink the heat map
      _this.heatmap.prefWidth = resizeStartHeatMapWidth + e.delta;
      _this.revalidate();
    });
    // horizontal scroll
    this.hscroll = new morpheus.ScrollBar(false);
    this.hscroll.appendTo(this.$parent);
    this.hscroll.on('scroll', function () {
      if (_this.updatingScroll) {
        return;
      }
      _this.paintAll({
        paintRows: false,
        paintColumns: true,
        invalidateRows: false,
        invalidateColumns: true
      });
    });
    this.$whitespace = $('<div style="position: absolute;"></div>');
    this.$whitespace.appendTo(this.$parent);
    var heatmap = new morpheus.HeatMapElementCanvas(this.project);
    if (this.options.drawCallback) {
      heatmap.setDrawCallback(this.options.drawCallback);
    }

    $(heatmap.canvas)
      .on(
        'contextmenu',
        function (e) {
          var items = [];
          morpheus.Popup
            .showPopup(
              [

                {
                  name: 'Copy Image',
                  class: 'copy'
                },
                {
                  name: 'Save Image (' + morpheus.Util.COMMAND_KEY + 'S)'
                },
                {
                  separator: true
                },
                {
                  name: 'Copy Selection',
                  disabled: _this.project
                    .getElementSelectionModel()
                    .count() === 0,
                  class: 'copy'
                },
                {
                  separator: true
                },
                {
                  name: 'Show Inline Tooltip',
                  checked: _this.options.inlineTooltip
                }],
              {
                x: e.pageX,
                y: e.pageY
              },
              e.target,
              function (event, item) {
                if (item === 'Show Inline Tooltip') {
                  _this.options.inlineTooltip = !_this.options.inlineTooltip;
                } else if (item === ('Save Image (' + morpheus.Util.COMMAND_KEY + 'S)')) {
                  _this.getActionManager().execute('Save Image');
                } else if (item === 'Copy Selection') {
                  var text = _this
                    .getSelectedElementsText();
                  if (text !== '') {
                    event.clipboardData
                      .setData(
                        'text/plain',
                        text);
                  }
                } else if (item === 'Copy Image') {
                  _this.getActionManager().execute('Copy Image', {event: event});
                } else {
                  console.log(item + ' unknown.');
                }
              });

          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });
    heatmap.appendTo(this.$parent);
    this.heatmap = heatmap;
    var rowDendrogramSortKey = null;
    if (rowDendrogram != undefined) {
      var tree = rowDendrogram;
      if (tree.leafNodes.length !== this.project.getFullDataset()
          .getRowCount()) {
        throw '# leaf nodes in row dendrogram ' + tree.leafNodes.length
        + ' != ' + this.project.getFullDataset().getRowCount();
      }
      var rowIndices = null;
      if (this.options.rowDendrogramField != null) {
        var vector = dataset.getRowMetadata().getByName(
          this.options.rowDendrogramField);
        rowIndices = [];
        var map = new morpheus.Map();
        var re = /[,:]/g;
        for (var j = 0, size = vector.size(); j < size; j++) {
          var key = vector.getValue(j);
          map.set(key.replace(re, ''), j);
        }
        // need to replace special characters to match ids in newick
        // file

        for (var i = 0, length = tree.leafNodes.length; i < length; i++) {
          var index = map.get(tree.leafNodes[i].name);
          if (index === undefined) {
            throw 'Unable to find row dendrogram id '
            + tree.leafNodes[i].name
            + ' in row annotations';
          }
          rowIndices.push(index);
        }
      } else {
        // see if leaf node ids are indices
        // for (var i = 0, length = tree.leafNodes.length; i < length; i++) {
        //   var newickId = tree.leafNodes[i].name;
        //   newickId = parseInt(newickId);
        //   if (!isNaN(newickId)) {
        //     rowIndices.push(newickId);
        //   } else {
        //     break;
        //   }
        // }
        // if (rowIndices.length !== tree.leafNodes.length) {
        //   rowIndices = [];
        //   for (var i = 0, length = tree.leafNodes.length; i < length; i++) {
        //     rowIndices.push(i);
        //   }
        // }
      }
      this.rowDendrogram = new morpheus.RowDendrogram(this, tree, heatmap
        .getRowPositions(), this.project, true);
      this.rowDendrogram.appendTo(this.$parent);
      this.rowDendrogram.$label.appendTo(this.$parent);
      this.rowDendrogram.$squishedLabel.appendTo(this.$parent);
      if (rowIndices != null) {
        rowDendrogramSortKey = new morpheus.SpecifiedModelSortOrder(
          rowIndices, rowIndices.length, 'dendrogram');
      }
    }
    var columnDendrogramSortKey = null;
    if (columnDendrogram !== undefined) {
      var tree = columnDendrogram;

      if (tree.leafNodes.length !== this.project.getFullDataset()
          .getColumnCount()) {
        throw '# leaf nodes ' + tree.leafNodes.length + ' != '
        + this.project.getFullDataset().getColumnCount();
      }
      var columnIndices = null;
      if (this.options.columnDendrogramField != null) {
        columnIndices = [];
        var vector = dataset.getColumnMetadata().getByName(
          this.options.columnDendrogramField);
        var map = new morpheus.Map();
        var re = /[,:]/g;
        for (var j = 0, size = vector.size(); j < size; j++) {
          var key = vector.getValue(j);
          map.set(key.replace(re, ''), j);
        }

        for (var i = 0, length = tree.leafNodes.length; i < length; i++) {
          var index = map.get(tree.leafNodes[i].name);
          if (index === undefined) {
            throw 'Unable to find column dendrogram id '
            + tree.leafNodes[i].name
            + ' in column annotations';
          }
          columnIndices.push(index);
        }
      } else {
        // for (var i = 0, length = tree.leafNodes.length; i < length; i++) {
        //   var newickId = tree.leafNodes[i].name;
        //   newickId = parseInt(newickId);
        //   if (!isNaN(newickId)) {
        //     columnIndices.push(newickId);
        //   } else {
        //     break;
        //   }
        // }
        // if (columnIndices.length !== tree.leafNodes.length) {
        //   columnIndices = [];
        //   for (var i = 0, length = tree.leafNodes.length; i < length; i++) {
        //     columnIndices.push(i);
        //   }
        // }
      }
      this.columnDendrogram = new morpheus.ColumnDendrogram(this, tree,
        heatmap.getColumnPositions(), this.project, true);
      this.columnDendrogram.appendTo(this.$parent);
      this.columnDendrogram.$label.appendTo(this.$parent);
      this.columnDendrogram.$squishedLabel.appendTo(this.$parent);
      if (columnIndices != null) {
        columnDendrogramSortKey = new morpheus.SpecifiedModelSortOrder(
          columnIndices, columnIndices.length, 'dendrogram');
      }
    }

    if (this.options.drawGrid != null) {
      this.heatmap.setDrawGrid(this.options.drawGrid);
    }
    if (this.options.gridColor != null) {
      this.heatmap.setGridColor(this.options.gridColor);
    }
    if (this.options.gridThickness != null) {
      this.heatmap.setGridThickness(this.options.gridThickness);
    }
    if (this.options.drawValues != null) {
      this.heatmap.setDrawValues(this.options.drawValues);
    }

    if (rowDendrogramSortKey !== null) {
      this.project.setRowSortKeys([rowDendrogramSortKey]);
    }
    if (columnDendrogramSortKey !== null) {
      this.project.setColumnSortKeys([columnDendrogramSortKey]);
    }
    if (this.options.rowSortBy && this.options.rowSortBy.length > 0) {
      this.project.setRowSortKeys(morpheus.SortKey.fromJSON(this.project, this.options.rowSortBy), false);
    }
    if (this.options.columnSortBy && this.options.columnSortBy.length > 0) {
      this.project.setColumnSortKeys(morpheus.SortKey.fromJSON(this.project, this.options.columnSortBy), false);
    }
    if (this.options.rowGroupBy != null && this.options.rowGroupBy.length > 0) {
      var keys = morpheus.SortKey.fromJSON(this.project, this.options.rowGroupBy);
      for (var i = 0; i < keys.length; i++) {
        this.project.groupRows.push(keys[i]);
      }
    }
    if (this.options.columnGroupBy != null && this.options.columnGroupBy.length > 0) {
      var keys = morpheus.SortKey.fromJSON(this.project, this.options.columnGroupBy);
      for (var i = 0; i < keys.length; i++) {
        this.project.groupColumns.push(keys[i]);
      }
    }
    if (this.options.rowSelection != null && this.options.rowSelection.length > 0) {
      var indices = new morpheus.Set();
      for (var i = 0, length = this.options.rowSelection.length; i < length; i++) {
        indices.add(this.project.convertModelRowIndexToView(this.options.rowSelection[i]));
      }
      this.project.getRowSelectionModel().setViewIndices(indices, false);
    }
    if (this.options.columnSelection != null && this.options.columnSelection.length > 0) {
      var indices = new morpheus.Set();
      for (var i = 0, length = this.options.columnSelection.length; i < length; i++) {
        indices.add(this.project.convertModelColumnIndexToView(this.options.columnSelection[i]));
      }
      this.project.getColumnSelectionModel().setViewIndices(indices, false);
    }
    // if (this.options.rowSearchTerm != null && this.options.rowSearchTerm !== '') {
    //   this.toolbar.getSearchField(morpheus.HeatMapToolBar.ROW_SEARCH_FIELD).val(this.options.rowSearchTerm);
    // }
    // if (this.options.columnSearchTerm != null && this.options.columnSearchTerm !== '') {
    //   this.toolbar.getSearchField(morpheus.HeatMapToolBar.COLUMN_SEARCH_FIELD).val(this.options.columnSearchTerm);
    // }

    this.vSortByValuesIndicator = new morpheus.SortByValuesIndicator(
      this.project, true, heatmap.getRowPositions());
    this.vSortByValuesIndicator.appendTo(this.$parent);
    this.hSortByValuesIndicator = new morpheus.SortByValuesIndicator(
      this.project, false, heatmap.getColumnPositions());
    this.hSortByValuesIndicator.appendTo(this.$parent);
    this.verticalSearchBar = new morpheus.ScentedSearch(this.project
        .getRowSelectionModel(), heatmap.getRowPositions(), true,
      this.vscroll, this);
    this.horizontalSearchBar = new morpheus.ScentedSearch(this.project
        .getColumnSelectionModel(), heatmap.getColumnPositions(),
      false, this.hscroll, this);
    this.rowTracks = [];
    this.rowTrackHeaders = [];
    this.columnTracks = [];
    this.columnTrackHeaders = [];
    var setInitialDisplay = function (isColumns, options) {
      var nameToOption = new morpheus.Map();
      // at
      // least
      // one
      // display option
      // supplied
      var displaySpecified = (_this.options.parent != null && _this.options.inheritFromParent);
      _.each(options, function (option) {
        if (!displaySpecified) {
          displaySpecified = option.display != null;
        }
        nameToOption.set(option.renameTo != null ? option.renameTo
          : option.field, option);
      });
      var displayMetadata = isColumns ? dataset.getColumnMetadata()
        : dataset.getRowMetadata();
      // see if default fields found
      if (!displaySpecified) {
        var defaultFieldsToShow = new morpheus.Set();
        //['pert_iname', 'moa', 'target', 'description', 'cell_id', 'pert_type'
        ['pert_iname', 'moa', 'target', 'cell_id', 'pert_type']
          .forEach(function (field) {
            defaultFieldsToShow.add(field);
          });
        for (var i = 0, metadataCount = displayMetadata
          .getMetadataCount(); i < metadataCount; i++) {
          var v = displayMetadata.get(i);
          if (defaultFieldsToShow.has(v.getName())) {
            nameToOption.set(v.getName(), {
              display: 'text'
            });
            displaySpecified = true;
          }
        }

      }
      var isFirst = true;
      console.log("heat_map ::", displayMetadata, displaySpecified);
      for (var i = 0, metadataCount = displayMetadata.getMetadataCount(); i < metadataCount; i++) {
        var display = displaySpecified ? 'None' : undefined;
        var v = displayMetadata.get(i);
        var name = v.getName();
        var option = nameToOption.get(name);
        if (morpheus.MetadataUtil.DEFAULT_HIDDEN_FIELDS.has(name)
          && option == null) {
          continue;
        }
        var count = isColumns ? dataset.getColumnCount() : dataset
          .getRowCount();
        if (!option && !displaySpecified && count > 1
          && !morpheus.VectorUtil.containsMoreThanOneValue(v)) {
          continue;
        }
        if (option == null) {
          option = {};
        }
        if (option.title) {
          v.getProperties().set(morpheus.VectorKeys.TITLE,
            option.title);
        }
        if (option.display) {
          if (typeof option.display == 'function') {
            display = option.display(name);
          } else {
            display = option.display;
          }
        }

        var add = display !== 'None';
        if (add) {
          if (display == null) {
            if (name === 'pert_iname' || name === 'id' || isFirst) {
              display = 'text,tooltip';
            } else {
              display = isColumns ? 'color,highlight' : 'text';
            }
          }
          isFirst = false;
          var track = _this.addTrack(name, isColumns, display);
          if (track.isRenderAs(morpheus.VectorTrack.RENDER.COLOR)
            && option.color) {
            var m = isColumns ? _this.project.getColumnColorModel()
              : _this.project.getRowColorModel();
            if (track.isDiscrete()) {
              _.each(options.color, function (p) {
                m.setMappedValue(v, p.value, p.color);
              });
            } else {
              var cs = m.createContinuousColorMap(v);
              var min = Number.MAX_VALUE;
              var max = -Number.MAX_VALUE;
              _.each(options.color, function (p) {
                min = Math.min(min, p.value);
                max = Math.max(max, p.value);
              });

              cs.setMin(min);
              cs.setMax(max);
              var valueToFraction = d3.scale.linear().domain(
                [cs.getMin(), cs.getMax()]).range(
                [0, 1]).clamp(true);
              var fractions = [];
              var colors = [];
              _.each(options.color, function (p) {
                fractions.push(valueToFraction(p.value));
                colors.push(p.color);
              });

              cs.setFractions({
                fractions: fractions,
                colors: colors
              });
            }
          }
          if (track.isRenderAs(morpheus.VectorTrack.RENDER.SHAPE)
            && option.shape) {
            var m = isColumns ? _this.project.getColumnShapeModel()
              : _this.project.getRowShapeModel();
            _.each(options.shape, function (p) {
              m.setMappedValue(v, p.value, p.shape);
            });

          }
        }
      }
    };
    setInitialDisplay(false, this.options.rows);
    setInitialDisplay(true, this.options.columns);
    function reorderTracks(array, isColumns) {
      if (array == null || array.length <= 1) {
        return;
      }
      var nameOrderPairs = [];
      var found = false;
      array.forEach(function (item, index) {
        var name = item.renameTo || item.field;
        var order = index;
        if (item.order != null) {
          order = item.order;
          found = true;
        }
        nameOrderPairs.push({
          name: name,
          order: order
        });
      });
      if (!found) {
        array.forEach(function (item, index) {
          var name = item.renameTo || item.field;
          nameOrderPairs.push({
            name: name,
            order: index
          });
        });
      }

      nameOrderPairs.sort(function (a, b) {
        return (a.order === b.order ? 0 : (a.order < b.order ? -1
          : 1));
      });
      for (var i = 0, counter = 0; i < nameOrderPairs.length; i++) {
        var index = _this.getTrackIndex(nameOrderPairs[i].name,
          isColumns);
        if (index !== -1) {
          _this.moveTrack(index, counter, isColumns);
          counter++;
        }
      }

    }

    reorderTracks(this.options.rows, false);
    reorderTracks(this.options.columns, true);
    var colorSchemeSpecified = this.options.colorScheme != null;
    if (this.options.colorScheme == null) {
      var ext = '';
      if (this.options.dataSource) {
        ext = morpheus.Util.getExtension(morpheus.Util
          .getFileName(this.options.dataSource));
      }

      var colorScheme = this.autoDisplay({
        filename: morpheus.Util.getBaseFileName(morpheus.Util.getFileName(this.options.dataset)),
        extension: ext
      });
      if (colorScheme == null) {
        colorScheme = {
          type: 'relative'
        };
      }
      this.options.colorScheme = colorScheme;
      var name = this.project.getFullDataset().getName();
      if (ext === 'maf' && !this.options.rowSortBy) {
        var sortKeys = [];
        if (this.project.getFullDataset().getRowMetadata().getByName(
            'order')) {
          sortKeys.push(new morpheus.SortKey('order',
            morpheus.SortKey.SortOrder.ASCENDING));
        }
        sortKeys.push(new morpheus.SortKey('id',
          morpheus.SortKey.SortOrder.ASCENDING));
        this.project.setRowSortKeys(sortKeys, false);

      }
      if (morpheus.DatasetUtil.getSeriesIndex(this.project
          .getFullDataset(), 'allelic_fraction') !== -1) {
        this.options.sizeBy = {
          seriesName: 'allelic_fraction',
          min: 0,
          max: 1
        };
      }

    }
    if (this.options.parent && this.options.inheritFromParent) {
      this.heatmap.setPropertiesFromParent(this.options.parent.heatmap);
    }
    if (this.options.parent && this.options.inheritFromParent
      && !colorSchemeSpecified) {
      heatmap.setColorScheme(this.options.parent.heatmap.getColorScheme()
        .copy(this.project));
    } else {
      heatmap.setColorScheme(new morpheus.HeatMapColorScheme(
        this.project, this.options.colorScheme));
      if (this.options.dataset.getRowMetadata().getByName('Source') != null) {
        // separate color scheme for each source file
        var sourcesSet = morpheus.VectorUtil
          .getSet(this.options.dataset.getRowMetadata()
            .getByName('Source'));
        this.heatmap.getColorScheme()
          .setSeparateColorSchemeForRowMetadataField('Source');
        sourcesSet.forEach(function (source) {
          _this.autoDisplay({
            extension: morpheus.Util.getExtension(source),
            filename: '' + source
          });
        });
      }
    }

    if (this.options.sizeBy) {
      heatmap.getColorScheme().getSizer().setSeriesName(
        this.options.sizeBy.seriesName);
      heatmap.getColorScheme().getSizer().setMin(
        this.options.sizeBy.min);
      heatmap.getColorScheme().getSizer().setMax(
        this.options.sizeBy.max);
    }
    this.updateDataset();

    // tabOpened is inherited by child heat maps
    if (this.options.tabOpened) {
      this.options.tabOpened(this);
      this.updateDataset();
    }
    // renderReady is only called once for the parent heat map
    if (this.options.renderReady) {
      this.options.renderReady(this);
      this.updateDataset();
    }

    if (this.options.rowSize != null) {
      if (this.options.rowSize === 'fit') {
        this.heatmap.getRowPositions().setSize(this.getFitRowSize());
      } else {
        this.heatmap.getRowPositions().setSize(this.options.rowSize);
      }
      this.revalidate({
        paint: false
      });

    }
    if (this.options.columnSize != null) {
      if (this.options.columnSize === 'fit') {
        this.heatmap.getColumnPositions().setSize(
          this.getFitColumnSize());
      } else {
        this.heatmap.getColumnPositions().setSize(
          this.options.columnSize);
      }
      this.revalidate({
        paint: false
      });
    }
    if (this.options.rowSize != null && this.options.columnSize != null) {
      // note that we have to revalidate twice because column sizes are
      // dependent on row sizes and vice versa
      if (this.options.columnSize === 'fit') {
        this.heatmap.getColumnPositions().setSize(
          this.getFitColumnSize());
        this.revalidate({
          paint: false
        });
      }
      if (this.options.rowColorModel) {
        this.getProject().getRowColorModel().fromJSON(this.options.rowColorModel);
      }
      if (this.options.columnColorModel) {
        this.getProject().getColumnColorModel().fromJSON(this.options.columnColorModel);
      }
      if (this.options.rowSize === 'fit') {
        this.heatmap.getRowPositions().setSize(this.getFitRowSize());
        this.revalidate({
          paint: false
        });
      }
      this.paintAll({
        paintRows: true,
        paintColumns: true,
        invalidateRows: true,
        invalidateColumns: true
      });
    }

    this.options.parent = null; // avoid memory leak
    this.$tipFollow = $('<div style="display:none;"' +
      ' class="morpheus-tip-inline"></div>');
    this.$tipFollow.appendTo(this.$parent);

    this.$tipInfoWindow = $('<div class="morpheus-tip-dialog"></div>');
    this.$tipInfoWindow.appendTo(this.$parent);

    this.$tipInfoWindow.dialog({
      close: function (event, ui) {
        if (!_this._togglingInfoWindow) {
          _this.toggleInfoWindow();
        }
      },
      autoOpen: false,
      width: 220,
      height: 280,
      minHeight: 38,
      minWidth: 10,
      collision: 'fit',
      position: {
        my: 'right-30 bottom',
        at: 'right top',
        of: this.$parent
      },
      title: 'Info'
    });
    this.setTooltipMode(this.options.tooltipMode);
    this
      .getProject()
      .on(
        'rowFilterChanged columnFilterChanged rowGroupByChanged columnGroupByChanged rowSortOrderChanged columnSortOrderChanged datasetChanged',
        function (e) {
          if (e.type === 'datasetChanged') { // remove
            // tracks
            // that are no
            // longer in the
            // dataset

            var dataset = _this.getProject()
              .getFullDataset();
            for (var i = 0; i < _this.rowTracks.length; i++) {
              var track = _this.rowTracks[i];
              if (!dataset.getRowMetadata().getByName(
                  track.getName())) {
                _this.removeTrack(track.getName(),
                  false);
                i--;
              }
            }
            for (var i = 0; i < _this.columnTracks.length; i++) {
              var track = _this.columnTracks[i];
              if (!dataset.getColumnMetadata().getByName(
                  track.getName())) {
                _this
                  .removeTrack(track.getName(),
                    true);
                i--;
              }
            }

          }

          _this.updateDataset();
          _this.revalidate();
        });

    this.getProject().on('trackChanged', function (e) {
      var columns = e.columns;
      _.each(e.vectors, function (v, i) {
        var index = _this.getTrackIndex(v.getName(), columns);
        if (index === -1) {
          _this.addTrack(v.getName(), columns, e.render[i]);
        } else {
          // repaint
          var track = _this.getTrackByIndex(index, columns);
          var render = e.render[i];
          if (render) {
            track.settingFromConfig(render);
          }
          track.setInvalid(true);
        }
      });
      _this.revalidate();
    });
    this.getProject().on('rowTrackRemoved', function (e) {
      _this.removeTrack(e.vector.getName(), false);
      _this.revalidate();
    });
    this.getProject().on('columnTrackRemoved', function (e) {
      _this.removeTrack(e.vector.getName(), true);
      _this.revalidate();
    });
    this
      .getProject()
      .getRowSelectionModel()
      .on(
        'selectionChanged',
        function () {
          // repaint tracks that indicate selection
          for (var i = 0; i < _this.columnTracks.length; i++) {
            var track = _this.columnTracks[i];
            if (track.getFullVector().getProperties().get(morpheus.VectorKeys.RECOMPUTE_FUNCTION_SELECTION)) {
              var selectedDataset = _this.getProject().getSelectedDataset({
                selectedRows: true,
                selectedColumns: false,
                emptyToAll: false
              });
              var vector = selectedDataset.getColumnMetadata().getByName(track.getName());
              var f = morpheus.VectorUtil.jsonToFunction(vector, morpheus.VectorKeys.FUNCTION);
              if (typeof f === 'function') {
                // iterate over each column
                var view = new morpheus.DatasetColumnView(selectedDataset);
                // TODO only set values that are currently visible
                for (var j = 0, size = vector.size(); j < size; j++) {
                  view.setIndex(j);
                  vector.setValue(j, f(view, selectedDataset, j));
                }
                track.setInvalid(true);
                track.repaint();
              }
            }
          }
          _this.verticalSearchBar.update();
          _this.heatmap.updateRowSelectionCache();
          _this.paintAll({
            paintRows: true,
            paintColumns: false,
            invalidateRows: false,
            invalidateColumns: false
          });
        });
    this.getProject().getColumnSelectionModel().on('selectionChanged',
      function () {
        _this.horizontalSearchBar.update();
        _this.heatmap.updateColumnSelectionCache();
        _this.paintAll({
          paintRows: false,
          paintColumns: true,
          invalidateRows: false,
          invalidateColumns: false
        });
      });

    this.pasteListener = function (e) {
      if (_this.isActiveComponent()) {
        var text = e.originalEvent.clipboardData
          .getData('text/plain');
        if (text != null && text.length > 0) {
          e.preventDefault();
          e.stopPropagation();
          // open a file from clipboard
          var url;
          if (text.indexOf('http') === 0) {
            url = text;
          } else {
            var blob = new Blob([text], {type: 'text/plain'});
            url = URL.createObjectURL(blob);
          }
          morpheus.HeatMap.showTool(
            new morpheus.OpenFileTool({
              file: url
            }), _this);
        }
      }
    };
    this.beforeCopyListener = function (e) {
      if (_this.isActiveComponent()) {
        e.preventDefault();
      }

    };
    this.copyListener = function (ev) {
      if (_this.isActiveComponent()) {
        var activeComponent = _this
          .getActiveComponent();
        var project = _this.project;
        if (activeComponent === 'heatMap' || ev.shiftKey) {
          // copy selected text or image
          // var text = _this.getSelectedElementsText();
          // if (text !== '') {
          // 	ev.originalEvent.clipboardData.setData(
          // 		'text/plain', text);
          // 	return;
          // }
          var bounds = _this.getTotalSize();
          var height = bounds.height;
          var width = bounds.width;
          var canvas = $('<canvas></canvas>')[0];
          canvas.height = height;
          canvas.width = width;
          var context = canvas.getContext('2d');
          _this.snapshot(context);
          var url = canvas.toDataURL();
          ev.originalEvent.clipboardData
            .setData(
              'text/html',
              '<img src="' + url + '">');
          ev.preventDefault();
          ev.stopImmediatePropagation();
          return;
        }
        // copy all selected rows and columns
        var dataset = project.getSelectedDataset({
          emptyToAll: false
        });
        var rowsSelected = dataset.getRowCount() > 0;
        var columnsSelected = dataset.getColumnCount() > 0;
        var columnMetadata = dataset
          .getColumnMetadata();
        var rowMetadata = dataset.getRowMetadata();
        // only copy visible tracks
        var visibleColumnFields = _this
          .getVisibleTrackNames(true);
        var columnFieldIndices = [];
        _.each(visibleColumnFields, function (name) {
          var index = morpheus.MetadataUtil.indexOf(
            columnMetadata, name);
          if (index !== -1) {
            columnFieldIndices.push(index);
          }
        });
        columnMetadata = new morpheus.MetadataModelColumnView(
          columnMetadata, columnFieldIndices);
        var rowMetadata = dataset.getRowMetadata();
        // only copy visible tracks
        var visibleRowFields = _this
          .getVisibleTrackNames(false);
        var rowFieldIndices = [];
        _.each(visibleRowFields, function (name) {
          var index = morpheus.MetadataUtil.indexOf(
            rowMetadata, name);
          if (index !== -1) {
            rowFieldIndices.push(index);
          }
        });
        rowMetadata = new morpheus.MetadataModelColumnView(
          rowMetadata, rowFieldIndices);
        var text = [];

        if (rowsSelected && columnsSelected) { // copy
          // as
          // gct
          // 1.3
          text = new morpheus.GctWriter()
            .write(dataset);
        } else {
          var text = [];
          var model = rowsSelected ? rowMetadata
            : columnMetadata;
          for (var i = 0, count = model
            .getItemCount(); i < count; i++) {
            for (var j = 0, nfields = model
              .getMetadataCount(); j < nfields; j++) {
              var v = model.get(j);
              if (j > 0) {
                text.push('\t');
              }
              text.push(morpheus.Util.toString(v
                .getValue(i)));
            }
            text.push('\n');
          }
          text = text.join('');
        }
        ev.originalEvent.clipboardData.setData(
          'text/plain', text);
        ev.preventDefault();
        ev.stopImmediatePropagation();

      }
    };

    if (typeof window !== 'undefined') {
      $(window)
        .on('paste.morpheus', this.pasteListener)
        .on('beforecopy.morpheus', this.beforeCopyListener)
        .on('copy.morpheus', this.copyListener);
    }
    if (this.options.keyboard) {
      new morpheus.HeatMapKeyListener(this);
    }
    if (this.options.symmetric) {
      this.getProject().setSymmetric(this);
    }
    var dragStartScrollTop;
    var dragStartScrollLeft;
    this.hammer = morpheus.Util
      .hammer(_this.heatmap.canvas, ['pan', 'pinch', 'tap'])
      .on('panmove', this.panmove = function (event) {
        _this.updatingScroll = true;
        var rows = false;
        var columns = false;
        if (event.deltaY !== 0) {
          var pos = dragStartScrollTop + event.deltaY;
          _this.scrollTop(pos);
          rows = true;
        }
        if (event.deltaX !== 0) {
          var pos = dragStartScrollLeft + event.deltaX;
          _this.scrollLeft(pos);
          columns = true;
        }
        _this.updatingScroll = false;
        _this.paintAll({
          paintRows: rows,
          paintColumns: rows,
          invalidateRows: rows,
          invalidateColumns: columns
        });
        event.preventDefault();
      })
      .on('panstart', this.panstart = function (event) {
        dragStartScrollTop = _this.scrollTop();
        dragStartScrollLeft = _this.scrollLeft();
      })
      .on(
        'tap',
        this.tap = function (event) {
          var commandKey = morpheus.Util.IS_MAC ? event.srcEvent.metaKey
            : event.srcEvent.ctrlKey;
          if (morpheus.Util.IS_MAC && event.srcEvent.ctrlKey) { // right-click
            // on
            // Mac
            return;
          }
          var position = morpheus.CanvasUtil
            .getMousePosWithScroll(event.target, event,
              _this.scrollLeft(), _this
                .scrollTop());
          var rowIndex = _this.heatmap.getRowPositions()
            .getIndex(position.y, false);
          var columnIndex = _this.heatmap
            .getColumnPositions().getIndex(position.x,
              false);
          _this.project.getElementSelectionModel().click(
            rowIndex, columnIndex,
            event.srcEvent.shiftKey || commandKey);
        })
      .on(
        'pinch',
        this.pinch = function (event) {
          var scale = event.scale;
          _this.heatmap.getRowPositions().setSize(13 * scale);
          _this.heatmap.getColumnPositions().setSize(
            13 * scale);
          var reval = {};
          if (_this.project.getHoverRowIndex() !== -1) {
            reval.scrollTop = this.heatmap
              .getRowPositions()
              .getPosition(
                this.project.getHoverRowIndex());
          }
          if (_this.project.getHoverColumnIndex() !== -1) {
            reval.scrollLeft = this.heatmap
              .getColumnPositions().getPosition(
                this.project
                  .getHoverColumnIndex());
          }

          _this.revalidate(reval);
          event.preventDefault();
        });
    var heatMapMouseMoved = function (event) {
      var mouseI, mouseJ;
      if (event.type === 'mouseout') {
        mouseI = -1;
        mouseJ = -1;
      } else {
        var position = morpheus.CanvasUtil.getMousePosWithScroll(
          event.target, event, _this.scrollLeft(), _this
            .scrollTop());
        mouseI = _this.heatmap.getRowPositions().getIndex(position.y,
          false);
        mouseJ = _this.heatmap.getColumnPositions().getIndex(
          position.x, false);
      }
      _this.setMousePosition(mouseI, mouseJ, {
        event: event
      });
    };
    $(_this.heatmap.canvas).on('mouseout', heatMapMouseMoved).on(
      'mousemove', heatMapMouseMoved);
    // tools to run at load time
    _.each(this.options.tools, function (item) {
      var action = _this.getActionManager().getAction(item.name);
      if (action == null) {
        console.log(item.name + ' not found.');
      } else {

        var actionGui = action.gui();
        var gui = actionGui.gui(_this.getProject());
        var formBuilder = new morpheus.FormBuilder();
        _.each(gui, function (item) {
          formBuilder.append(item);
        });
        var input = {};
        _.each(gui, function (item) {
          input[item.name] = formBuilder.getValue(item.name);
        });
        if (item.params) {
          // overide default values
          for (var key in item.params) {
            input[key] = item.params[key];
          }
        }

        actionGui.execute({
          heatMap: _this,
          project: _this.getProject(),
          input: input
        });

      }

    });
  },
  setMousePosition: function (i, j, options) {
    this.mousePositionOptions = options;
    var updateColumns = this.project.getHoverColumnIndex() !== j;
    var updateRows = this.project.getHoverRowIndex() !== i;
    if (updateColumns || updateRows) {
      this.project.setHoverRowIndex(i);
      this.project.setHoverColumnIndex(j);
      this.setToolTip(i, j, options);
      this.paintAll({
        paintRows: updateRows,
        paintColumns: updateColumns,
        invalidateRows: false,
        invalidateColumns: false
      });
    } else {
      this._updateTipFollowPosition(options);

    }
    // else if (this.options.tooltipMode === 2 &&
    // (this.project.getHoverColumnIndex() !== -1 || this.project
    // .getHoverRowIndex() !== -1)) {
    //
    // }
    this.trigger('change', {
      name: 'setMousePosition',
      source: this,
      arguments: arguments
    });
  },
  getContentEl: function () {
    return this.$content;
  },
  focus: function () {
    this.$tabPanel.focus();
  },
  getFocusEl: function () {
    return this.$tabPanel;
  },
  /**
   Set where the tooltip is shown
   @param mode 0 is formula bar, 1 is dialog, -1 is no tooltip
   */

  setTooltipMode: function (mode) {
    this._togglingInfoWindow = true;
    this.options.tooltipMode = mode;
    this.$tipInfoWindow.html('');
    this.toolbar.$tip.html('');
    this.$tipFollow.html('').css({
      display: 'none'
    });
    this.toolbar.$tip.css('display', mode === 0 ? '' : 'none');
    this.setToolTip(-1, -1);
    if (this.options.tooltipMode === 1) {
      this.$tipInfoWindow.dialog('open');
    } else {
      this.$tipInfoWindow.dialog('close');
    }
    this._togglingInfoWindow = false;
  },
  toggleInfoWindow: function () {
    this.setTooltipMode(this.options.tooltipMode == 1 ? 0 : 1);
  },
  _setTipText: function (tipText, tipFollowText, options) {
    if (this.options.tooltipMode === 0) {
      this.toolbar.$tip.html(tipText.join(''));
    } else if (this.options.tooltipMode === 1) {
      this.$tipInfoWindow.html(tipText.join(''));
    }

    if (tipFollowText != null) {
      this.tipFollowHidden = false;
      this.$tipFollow.html(tipFollowText);
      this._updateTipFollowPosition(options);
    } else {
      this.tipFollowHidden = true;
      this.$tipFollow.empty().css({
        display: 'none'
      });
    }
    this.trigger('change', {
      name: 'setToolTip',
      source: this,
      arguments: arguments
    });
  },
  setToolTip: function (rowIndex, columnIndex, options) {
    options = options || {};
    if (this.options.showSeriesNameInTooltip) {
      options.showSeriesNameInTooltip = true;
    }
    if (this.options.tooltipSeriesIndices) {
      options.tooltipSeriesIndices = this.options.tooltipSeriesIndices;
    }
    if (options.heatMapLens) {
      // don't draw lens if currently visible
      // row lens
      var $wrapper = $('<div></div>');
      var wrapperHeight = 0;
      var wrapperWidth = 0;
      var found = false;
      var inline = [];
      if (rowIndex != null && rowIndex.length > 0) {
        for (var hoverIndex = 0; hoverIndex < rowIndex.length; hoverIndex++) {
          var row = rowIndex[hoverIndex];
          if (row >= 0 && (row >= this.heatmap.lastPosition.bottom || row < this.heatmap.lastPosition.top)) {
            found = true;
            var heatMapWidth = this.heatmap.getUnscaledWidth();
            var top = row; // Math.max(0, rowIndex - 1);
            var bottom = row + 1; //Math.min(rowIndex + 1, this.heatmap.rowPositions.getLength());
            var startPix = this.heatmap.rowPositions.getPosition(top);
            var endPix = startPix + this.heatmap.rowPositions.getItemSize(top);
            var heatMapHeight = endPix - startPix;
            var canvas = morpheus.CanvasUtil.createCanvas();
            var trackWidth = 0;
            for (var i = 0, ntracks = this.rowTracks.length; i < ntracks; i++) {
              var track = this.rowTracks[i];
              if (track.isVisible()) {
                trackWidth += track.getUnscaledWidth();
              }
            }

            var canvasWidth = trackWidth + heatMapWidth + morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS;
            canvas.width = canvasWidth * morpheus.CanvasUtil.BACKING_SCALE;
            canvas.style.width = canvasWidth + 'px';
            canvas.height = heatMapHeight * morpheus.CanvasUtil.BACKING_SCALE;
            canvas.style.height = heatMapHeight + 'px';
            var context = canvas.getContext('2d');
            morpheus.CanvasUtil.resetTransform(context);
            context.save();
            context.translate(-this.heatmap.lastClip.x, -startPix);
            context.rect(this.heatmap.lastClip.x, startPix, this.heatmap.lastClip.width, this.heatmap.lastClip.height);
            context.clip();
            this.heatmap._draw({
              left: this.heatmap.lastPosition.left,
              right: this.heatmap.lastPosition.right,
              top: top,
              bottom: bottom,
              context: context
            });
            context.restore();
            context.translate(heatMapWidth + morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS, -startPix);
            trackWidth = 0;
            for (var i = 0, ntracks = this.rowTracks.length; i < ntracks; i++) {
              var track = this.rowTracks[i];
              if (track.isVisible()) {
                context.save();
                context.translate(trackWidth, 0);
                context.rect(0, startPix, track.getUnscaledWidth(), track.lastClip.height);
                context.clip();
                track._draw({
                  start: top,
                  end: bottom,
                  vector: track.getVector(),
                  context: context,
                  availableSpace: track.getUnscaledWidth()
                });
                context.restore();
                trackWidth += track.getUnscaledWidth();
              }
            }
            $(canvas).appendTo($wrapper);
            canvas.style.top = wrapperHeight + 'px';
            wrapperHeight += parseFloat(canvas.style.height);
            wrapperWidth = parseFloat(canvas.style.width);
          } else {
            inline.push(row);
          }

        }
        if (found) {
          $wrapper.css({
            height: wrapperHeight,
            width: wrapperWidth
          });

          var rect = this.$parent[0].getBoundingClientRect();
          this.$tipFollow.html($wrapper).css({
            display: '',
            left: Math.round(parseFloat(this.heatmap.canvas.style.left) - 1) + 'px',
            top: (options.event.clientY - rect.top - wrapperHeight / 2) + 'px'
          });
          return;
        } else {
          var tipText = [];
          var tipFollowText = [];
          for (var hoverIndex = 0; hoverIndex < inline.length; hoverIndex++) {
            this.tooltipProvider(this, inline[hoverIndex], -1,
              options, this.options.tooltipMode === 0 ? '&nbsp;&nbsp;&nbsp;'
                : '<br />', false, tipText);
            if (this.options.inlineTooltip) {
              this.tooltipProvider(this, inline[hoverIndex], -1,
                options, '<br />', true, tipFollowText);

            }
          }
          var text = tipFollowText.join('');
          this._setTipText(tipText, text.length === 0 ? null : '<span style="max-width:400px;">' + text + '</span>', options);
        }
      }
      if (columnIndex != null && columnIndex.length > 0) {

        for (var hoverIndex = 0; hoverIndex < columnIndex.length; hoverIndex++) {
          var column = columnIndex[hoverIndex];
          if (column >= 0 && (column >= this.heatmap.lastPosition.right || column < this.heatmap.lastPosition.left)) {
            found = true;
            var heatMapHeight = this.heatmap.getUnscaledHeight();
            var left = column; // Math.max(0, rowIndex - 1);
            var right = column + 1; //Math.min(rowIndex + 1, this.heatmap.rowPositions.getLength());
            var startPix = this.heatmap.columnPositions.getPosition(left);
            var endPix = startPix + this.heatmap.columnPositions.getItemSize(left);
            var heatMapWidth = endPix - startPix;
            var canvas = morpheus.CanvasUtil.createCanvas();
            var trackHeight = 0;
            for (var i = 0, ntracks = this.columnTracks.length; i < ntracks; i++) {
              var track = this.columnTracks[i];
              if (track.isVisible()) {
                trackHeight += track.getUnscaledHeight();
              }
            }
            var canvasHeight = trackHeight + heatMapHeight + morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS;
            canvas.width = heatMapWidth * morpheus.CanvasUtil.BACKING_SCALE;
            canvas.style.width = heatMapWidth + 'px';
            canvas.height = canvasHeight * morpheus.CanvasUtil.BACKING_SCALE;
            canvas.style.height = canvasHeight + 'px';
            var context = canvas.getContext('2d');
            morpheus.CanvasUtil.resetTransform(context);
            context.translate(-startPix, 0);
            context.save();
            context.rect(startPix, trackHeight + morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS, this.heatmap.lastClip.width, this.heatmap.lastClip.height + trackHeight + morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS);
            context.clip();
            context.translate(0, trackHeight + morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS - this.heatmap.lastClip.y);

            this.heatmap._draw({
              top: this.heatmap.lastPosition.top,
              bottom: this.heatmap.lastPosition.bottom,
              left: left,
              right: right,
              context: context
            });
            context.restore();
            trackHeight = 0;
            for (var i = 0, ntracks = this.columnTracks.length; i < ntracks; i++) {
              var track = this.columnTracks[i];
              if (track.isVisible()) {
                context.save();
                context.translate(0, trackHeight);
                context.rect(startPix, 0, track.lastClip.width, track.getUnscaledHeight());
                context.clip();
                track._draw({
                  start: left,
                  end: right,
                  vector: track.getVector(),
                  context: context,
                  availableSpace: track.getUnscaledHeight(),
                  clip: {
                    x: track.lastClip.x,
                    y: track.lastClip.y
                  }
                });
                context.restore();
                trackHeight += track.getUnscaledHeight();
              }
            }
            canvas.style.left = wrapperWidth + 'px';
            wrapperWidth += parseFloat(canvas.style.width);
            wrapperHeight = parseFloat(canvas.style.height);
            $(canvas).appendTo($wrapper);
          } else {
            inline.push(column);
          }
        }

        if (found) {
          $wrapper.css({
            height: wrapperHeight,
            width: wrapperWidth
          });

          var rect = this.$parent[0].getBoundingClientRect();
          this.$tipFollow.html($wrapper).css({
            top: parseFloat(this.heatmap.canvas.style.top) - trackHeight - morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS - 1,
            left: (options.event.clientX - rect.left) - (wrapperWidth / 2),
            display: ''
          });
          return;
        } else {
          var tipText = [];
          var tipFollowText = [];
          for (var hoverIndex = 0; hoverIndex < inline.length; hoverIndex++) {
            this.tooltipProvider(this, -1, inline[hoverIndex],
              options, this.options.tooltipMode === 0 ? '&nbsp;&nbsp;&nbsp;'
                : '<br />', false, tipText);
            if (this.options.inlineTooltip) {
              this.tooltipProvider(this, -1, inline[hoverIndex],
                options, '<br />', true, tipFollowText);
            }
          }
          var text = tipFollowText.join('');
          this._setTipText(tipText, text === '' ? null : '<span style="max-width:400px;">' + text + '</span>', options);
        }
      }

      // column lens

    }

    // tooltipMode=0 top, 1=window, 2=inline
    var tipText = [];
    this.tooltipProvider(this, rowIndex, columnIndex,
      options, this.options.tooltipMode === 0 ? '&nbsp;&nbsp;&nbsp;'
        : '<br />', false, tipText);

    var tipFollowText = [];
    if (this.options.inlineTooltip) {
      this.tooltipProvider(this, rowIndex, columnIndex,
        options, '<br />', true, tipFollowText);

      if (this.options.tooltip && rowIndex !== -1 && columnIndex !== -1) {
        tipFollowText.push('<div data-name="tip"></div>');
      }
    }

    var text = tipFollowText.join('');
    var $tipFollowText = $('<span style="max-width:400px;">' + text + '</span>');
    var customToolTip = false;
    if (this.options.tooltip && rowIndex !== -1 && columnIndex !== -1) {
      this.options.tooltip(this, rowIndex, columnIndex, $tipFollowText.find('[data-name=tip]'));
      customToolTip = true;
    }
    this._setTipText(tipText, text.length > 0 || customToolTip ? $tipFollowText : null, options);

  }
  ,
  _updateTipFollowPosition: function (options) {
    if (this.tipFollowHidden) {
      return;
    }
    // top, bottom are negative when scrolled
    var parentRect = this.$parent[0].getBoundingClientRect();
    var tipRect = this.$tipFollow[0].getBoundingClientRect();
    var tipWidth = tipRect.width;
    var tipHeight = tipRect.height;
    var offset = 10;
    var left = options.event.clientX - parentRect.left + offset;
    var top = options.event.clientY - parentRect.top + offset;
    // default is bottom-right
    var scrollBarSize = 18;
    if ((left + tipWidth) >= ( parentRect.right - parentRect.left - scrollBarSize)) { // offscreen
      // right, place tip on
      // left
      left = options.event.clientX - parentRect.left - offset - tipWidth;
    }
    if ((top + tipHeight) >= (parentRect.bottom - parentRect.top - scrollBarSize)) { // offscreen
      // bottom,
      // place tip
      // on top
      top = options.event.clientY - parentRect.top - offset - tipHeight;
    }
    this.$tipFollow.css({
      left: left + 'px',
      top: top + 'px',
      display: ''
    });

  }
  ,
  setTrackVisibility: function (tracks) {
    var _this = this;
    _.each(tracks, function (track) {
      var existingTrack = _this.getTrack(track.name, track.isColumns);
      if (track.visible && existingTrack != null
        && _.keys(existingTrack.settings).length === 0) {
        existingTrack.settingFromConfig('Text');
      }
      _this.setTrackVisible(track.name, track.visible, track.isColumns);
    });
    this.revalidate();
    this.trigger('change', {
      name: 'setTrackVisibility',
      source: this,
      arguments: arguments
    });
  }
  ,
  setTrackVisible: function (name, visible, isColumns) {
    var trackIndex = this.getTrackIndex(name, isColumns);
    if (trackIndex === -1) { // not currently visible
      if (!visible) {
        return;
      }
      this.addTrack(name, isColumns);
    } else {
      var track = isColumns ? this.columnTracks[trackIndex]
        : this.rowTracks[trackIndex];
      var header = isColumns ? this.columnTrackHeaders[trackIndex]
        : this.rowTrackHeaders[trackIndex];
      if (track.isVisible() !== visible) {
        track.setVisible(visible);
        header.setVisible(visible);
      } else {
        return;
      }
    }
    this.trigger('change', {
      name: 'setTrackVisible',
      source: this,
      arguments: arguments
    });
  },
  addTrack: function (name, isColumns, renderSettings) {
    if (name === undefined) {
      throw 'Name not specified';
    }
    if ('None' === renderSettings) {
      return;
    }
    var tracks = isColumns ? this.columnTracks : this.rowTracks;
    var headers = isColumns ? this.columnTrackHeaders : this.rowTrackHeaders;
    // see if already visible
    var existingIndex = this.getTrackIndex(name, isColumns);
    if (existingIndex !== -1) {
      return tracks[existingIndex];
    }
    if (renderSettings == null) {
      var metadata = isColumns ? this.project.getFullDataset().getColumnMetadata() : this.project.getFullDataset().getRowMetadata()
      renderSettings = morpheus.VectorUtil.getDataType(metadata.getByName(name)) === '[number]' ? 'bar'
        : morpheus.VectorTrack.RENDER.TEXT;
    }

    var positions = isColumns ? this.heatmap.getColumnPositions() : this.heatmap.getRowPositions();
    var track = new morpheus.VectorTrack(this.project, name, positions, isColumns, this);
    track.settingFromConfig(renderSettings);
    tracks.push(track);
    track.appendTo(this.$parent);
    var header = new morpheus.VectorTrackHeader(this.project, name, isColumns,
      this);
    headers.push(header);
    header.appendTo(this.$parent);
    track._selection = new morpheus.TrackSelection(track, positions, isColumns ? this.project.getColumnSelectionModel() : this.project.getRowSelectionModel(),
      isColumns, this);
    return track;
  }
  ,
  addPopup: function (item) {
    if (!this.popupItems) {
      this.popupItems = [];
    }
    this.popupItems.push(item);
  }
  ,
  getPopupItems: function () {
    return this.popupItems || [];
  }
  ,
  removeTrack: function (name, isColumns) {
    var index = this.getTrackIndex(name, isColumns);
    var tracks = isColumns ? this.columnTracks : this.rowTracks;
    if (isNaN(index) || index < 0 || index >= tracks.length) {
      console.log('removeTrack: ' + name + ' not found.');
      return;
    }

    var headers = isColumns ? this.columnTrackHeaders
      : this.rowTrackHeaders;
    var track = tracks[index];
    var header = headers[index];
    track.dispose();
    header.dispose();
    tracks.splice(index, 1);
    headers.splice(index, 1);
    this.trigger('change', {
      name: 'removeTrack',
      source: this,
      arguments: arguments
    });
  }
  ,
  updateDataset: function () {
    var dataset = this.project.getSortedFilteredDataset();
    this.verticalSearchBar.update();
    this.horizontalSearchBar.update();

    this.heatmap.setDataset(dataset);
    this.heatmap.getRowPositions().spaces = morpheus.HeatMap
      .createGroupBySpaces(dataset, this.project.getGroupRows(),
        this.gapSize, false);
    this.heatmap.getColumnPositions().spaces = morpheus.HeatMap
      .createGroupBySpaces(
        dataset, this.project.getGroupColumns(), this.gapSize, true);
    this.trigger('change', {
      name: 'updateDataset',
      source: this,
      arguments: arguments
    });
  }
  ,
  zoom: function (isZoomIn, options) {
    options = $.extend({}, {
      rows: true,
      columns: true
    }, options);
    if (isZoomIn) {
      if (options.rows) {
        this.heatmap.getRowPositions().setSize(
          this.heatmap.getRowPositions().getSize() * 1.5);
      }
      if (options.columns) {
        this.heatmap.getColumnPositions().setSize(
          this.heatmap.getColumnPositions().getSize() * 1.5);
      }
    } else {
      if (options.rows) {
        this.heatmap.getRowPositions().setSize(
          this.heatmap.getRowPositions().getSize() / 1.5);
      }
      if (options.columns) {
        this.heatmap.getColumnPositions().setSize(
          this.heatmap.getColumnPositions().getSize() / 1.5);
      }
    }
    var reval = {};
    if (options.rows && this.project.getHoverRowIndex() !== -1) {
      reval.scrollTop = this.heatmap.getRowPositions().getPosition(
        this.project.getHoverRowIndex());
    }
    if (options.columns && this.project.getHoverColumnIndex() !== -1) {
      reval.scrollLeft = this.heatmap.getColumnPositions().getPosition(
        this.project.getHoverColumnIndex());
    }
    this.revalidate(reval);
    this.trigger('change', {
      name: 'zoom',
      source: this,
      arguments: arguments
    });
  }
  ,
  getTrackIndex: function (name, isColumns) {
    var tracks = isColumns ? this.columnTracks : this.rowTracks;
    for (var i = 0, length = tracks.length; i < length; i++) {
      if (tracks[i].name !== undefined && tracks[i].name === name) {
        return i;
      }
    }
    return -1;
  }
  ,
  getNumTracks: function (isColumns) {
    return isColumns ? this.columnTracks.length : this.rowTracks.length;
  }
  ,
  moveTrack: function (index, newIndex, isColumns) {
    var tracks = isColumns ? this.columnTracks : this.rowTracks;
    var headers = isColumns ? this.columnTrackHeaders
      : this.rowTrackHeaders;
    var track = tracks[index];
    tracks.splice(index, 1);
    var header = headers[index];
    headers.splice(index, 1);
    tracks.splice(newIndex, 0, track);
    headers.splice(newIndex, 0, header);
    this.trigger('change', {
      name: 'moveTrack',
      source: this,
      arguments: arguments
    });
  }
  ,
  getTrackByIndex: function (index, isColumns) {
    return isColumns ? this.columnTracks[index] : this.rowTracks[index];
  }
  ,
  getTrackHeaderByIndex: function (index, isColumns) {
    return isColumns ? this.columnTrackHeaders[index]
      : this.rowTrackHeaders[index];
  }
  ,
  getTrack: function (name, isColumns) {
    var index = this.getTrackIndex(name, isColumns);
    if (index === -1) {
      return undefined;
    }
    return isColumns ? this.columnTracks[index] : this.rowTracks[index];
  }
  ,
  /**
   * @return true if active element is an ancestor of this heat map.
   */
  isActiveComponent: function () {
    var active = document.activeElement;
    var tagName = active.tagName;
    if (tagName == 'INPUT' || tagName == 'SELECT' || tagName == 'TEXTAREA') {
      return false;
    }
    return this.$tabPanel[0].contains(active);
  }
  ,
  /**
   *
   * @return {string} 'rowTrack' if row track is active, 'columnTrack' if column track is active,
   * 'heatMap' if heat map is active.
   */
  getActiveComponent: function () {
    var active = document.activeElement;
    if (active.tagName === 'CANVAS') {
      for (var i = 0, ntracks = this.columnTracks.length; i < ntracks; i++) {
        if (this.columnTracks[i].canvas === active) {
          return 'columnTrack';
        }
      }
      for (var i = 0, ntracks = this.rowTracks.length; i < ntracks; i++) {
        if (this.rowTracks[i].canvas === active) {
          return 'rowTrack';
        }
      }
      if (this.heatmap.canvas === active) {
        return 'heatMap';
      }
    }
    return '';
  },
  dispose: function () {
    //this.$content.remove();
    if (this.project == null) {
      return; // failed to initialize
    }
    this.project.off();
    this.$tipInfoWindow.dialog('destroy');
    this.rowTrackHeaders.forEach(function (header) {
      header.dispose();
    });
    this.columnTrackHeaders.forEach(function (header) {
      header.dispose();
    });
    this.rowTracks.forEach(function (track) {
      track.dispose();
    });
    this.columnTracks.forEach(function (track) {
      track.dispose();
    });
    if (this.rowDendrogram != null) {
      this.rowDendrogram.dispose();
    }
    if (this.columnDendrogram != null) {
      this.columnDendrogram.dispose();
    }
    this.beforeColumnTrackDivider.dispose();
    this.afterRowDendrogramDivider.dispose();
    this.afterVerticalScrollBarDivider.dispose();
    this.hscroll.dispose();
    this.vscroll.dispose();
    this.hammer.off('panmove', this.panmove).off('panstart', this.panstart).off('tap',
      this.tap).off('pinch', this.pinch);
    this.hammer.destroy();
    if (typeof window !== 'undefined') {
      $(window)
        .off('paste.morpheus', this.pasteListener)
        .off('beforecopy.morpheus', this.beforeCopyListener)
        .off('copy.morpheus', this.copyListener).off('orientationchange.morpheus resize.morpheus', this.resizeListener);
    }
  }
  ,
  getVisibleTrackNames: function (isColumns) {
    var names = [];
    var tracks = isColumns ? this.columnTracks : this.rowTracks;
    for (var i = 0, length = tracks.length; i < length; i++) {
      if (tracks[i].isVisible()) {
        names.push(tracks[i].name);
      }
    }
    return names;
  }
  ,
  resizeTrack: function (name, width, height, isColumns) {
    var index = this.getTrackIndex(name, isColumns);
    if (index === -1) {
      throw name + ' not found in resize track';
    }
    if (!isColumns) {
      var track = this.rowTracks[index];
      var header = this.rowTrackHeaders[index];
      track.setPrefWidth(width); // can only set width
      header.setPrefWidth(width);
    } else {
      var track = this.columnTracks[index];
      var header = this.columnTrackHeaders[index];
      if (height) {
        track.setPrefHeight(height);
        header.setPrefHeight(height);
      }
      if (width) {
        for (var i = 0; i < this.columnTracks.length; i++) {
          this.columnTracks[i].setPrefWidth(width);
          this.columnTrackHeaders[i].setPrefWidth(width);
        }
        // set width for all tracks
      }
    }
    this.revalidate();
    this.trigger('change', {
      name: 'resizeTrack',
      source: this,
      arguments: arguments
    });
  }
  ,
  isDendrogramVisible: function (isColumns) {
    var dendrogram = isColumns ? this.columnDendrogram : this.rowDendrogram;
    if (dendrogram !== undefined) {
      return morpheus.HeatMap
        .isDendrogramVisible(this.project, isColumns);
    }
  }
  ,
  /**
   *
   * Paint all the components
   *
   * @param options.paintRows
   * @param options.paintColumns
   * @param options.invalidateRows
   * @param options.invalidateColumns
   */
  paintAll: function (options) {
    var unscaledHeight = this.heatmap.getUnscaledHeight();
    var unscaledWidth = this.heatmap.getUnscaledWidth();
    var y = this.scrollTop();
    var x = this.scrollLeft();
    this.hscroll.paint();
    this.vscroll.paint(); // FIXME
    var rows = options.paintRows;
    var columns = options.paintColumns;
    var invalidateRows = options.invalidateRows;
    var invalidateColumns = options.invalidateColumns;
    // FIXME double buffer search bars
    this.hSortByValuesIndicator.setInvalid(invalidateRows
      || invalidateColumns);
    this.hSortByValuesIndicator.paint({
      x: x,
      y: 0,
      width: unscaledWidth,
      height: this.hSortByValuesIndicator.getUnscaledHeight()
    });
    this.vSortByValuesIndicator.setInvalid(invalidateRows
      || invalidateColumns);
    this.vSortByValuesIndicator.paint({
      x: 0,
      y: y,
      width: this.vSortByValuesIndicator.getUnscaledWidth(),
      height: unscaledHeight
    });
    if (rows) {
      for (var i = 0, length = this.rowTracks.length; i < length; i++) {
        var track = this.rowTracks[i];
        track.setInvalid(invalidateRows);
        if (track.isVisible()) {
          track.paint({
            x: 0,
            y: y,
            height: unscaledHeight,
            width: unscaledWidth
          });
          this.rowTrackHeaders[i].paint();
        }
      }
      if (this.rowDendrogram != null) {
        this.rowDendrogram.setInvalid(invalidateRows);
        if (this.isDendrogramVisible(false)) {
          this.rowDendrogram.setVisible(true);
          this.rowDendrogram.paint({
            x: 0,
            y: y,
            height: unscaledHeight,
            width: this.rowDendrogram.getUnscaledWidth()
          });
        } else {
          this.rowDendrogram.setVisible(false);
        }
      }
    }
    if (columns) {
      for (var i = 0, length = this.columnTracks.length; i < length; i++) {
        var track = this.columnTracks[i];
        track.setInvalid(invalidateColumns);
        track.paint({
          x: x,
          y: 0,
          width: unscaledWidth,
          height: track.getUnscaledHeight()
        });
        this.columnTrackHeaders[i].paint();
      }
      if (this.columnDendrogram != null) {
        this.columnDendrogram.setInvalid(invalidateColumns);
        if (this.isDendrogramVisible(true)) {
          this.columnDendrogram.setVisible(true);
          this.columnDendrogram.paint({
            x: x,
            y: 0,
            width: unscaledWidth,
            height: this.columnDendrogram.getUnscaledHeight()
          });
        } else {
          this.columnDendrogram.setVisible(false);
        }
      }
    }
    if (invalidateRows || invalidateColumns) {
      this.heatmap.setInvalid(true);
    }
    this.heatmap.paint({
      x: x,
      y: y,
      width: unscaledWidth,
      height: unscaledHeight
    });
    this.trigger('change', {
      name: 'paintAll',
      source: this,
      arguments: arguments
    });
  }
  ,
  scrollTop: function (pos) {
    if (pos === undefined) {
      return this.vscroll.getValue();
    }
    if (isNaN(pos)) {
      pos = 0;
    }
    if (this.vscroll.getVisibleExtent() === this.vscroll.getTotalExtent()) {
      pos = 0;
    }
    pos = Math.max(pos, 0);
    pos = Math.min(this.vscroll.getMaxValue(), pos);
    if (pos !== this.vscroll.getValue()) {
      this.vscroll.setValue(pos, true);
      this.trigger('change', {
        name: 'scrollTop',
        source: this,
        arguments: arguments
      });
    }
    return pos;
  }
  ,
  scrollLeft: function (pos) {
    if (pos === undefined) {
      return this.hscroll.getValue();
    }
    if (isNaN(pos)) {
      pos = 0;
    }
    if (this.hscroll.getVisibleExtent() === this.hscroll.getTotalExtent()) {
      pos = 0;
    }
    pos = Math.max(pos, 0);
    pos = Math.min(this.hscroll.getMaxValue(), pos);
    if (pos !== this.hscroll.getValue()) {
      this.trigger('change', {
        name: 'scrollLeft',
        source: this,
        arguments: arguments
      });
      this.hscroll.setValue(pos, true);
    }
    return pos;
  }
  ,
  getSelectedTrackName: function (isColumns) {
    return isColumns ? this.selectedColumnTrackName : this.selectedRowTrackName;
  },
  setSelectedTrack: function (name, isColumns) {
    var previousName = isColumns ? this.selectedColumnTrackName : this.selectedRowTrackName;
    if (name !== previousName) {
      var index = this.getTrackIndex(previousName, isColumns); // de-select previous
      if (index !== -1) {
        this.getTrackHeaderByIndex(index, isColumns)
          .setSelected(false);
      }
      if (isColumns) {
        this.selectedColumnTrackName = name;
      } else {
        this.selectedRowTrackName = name;
      }

      var index = this.getTrackIndex(name, isColumns);
      if (index !== -1) {
        this.getTrackHeaderByIndex(index, isColumns)
          .setSelected(true);
      }
      this.trigger('change', {
        name: 'setSelected',
        source: this,
        arguments: arguments
      });
    }
  }
  ,
  saveImage: function (file, format) {
    var _this = this;
    var bounds = this.getTotalSize();
    if (format === 'pdf') {
      // var context = new morpheus.PdfGraphics();
      // this.snapshot(context);
      // context.toBlob(function (blob) {
      // 	saveAs(blob, file, true);
      // });
      // var context = new C2S(bounds.width, bounds.height);
      // this.snapshot(context);
      // var svg = context.getSerializedSvg();
      // var doc = new jsPDF();
      // doc.addHTML(svg, 0, 0, bounds.width, bounds.height);
      // doc.save(file);

    } else if (format === 'svg') {
      var context = new C2S(bounds.width, bounds.height);
      this.snapshot(context);
      var svg = context.getSerializedSvg();
      var blob = new Blob([svg], {
        type: 'text/plain;charset=utf-8'
      });
      saveAs(blob, file, true);
    } else {
      var canvas = $('<canvas></canvas>')[0];
      var height = bounds.height;
      var width = bounds.width;
      var backingScale = morpheus.CanvasUtil.BACKING_SCALE;
      canvas.height = backingScale * height;
      canvas.style.height = height + 'px';
      canvas.width = backingScale * width;
      canvas.style.width = width + 'px';
      var context = canvas.getContext('2d');
      morpheus.CanvasUtil.resetTransform(context);
      this.snapshot(context);
      // var stack = context.stack();
      // var s = [];
      // for (var i = 0; i < stack.length; i++) {
      // 	var arg = stack[i];
      // 	if (arg.attr) {
      // 		if (_.isString(arg.val)) {
      // 			s.push('context.' + arg.attr + ' = \'' + arg.val + '\';');
      // 		} else {
      // 			s.push('context.' + arg.attr + ' = ' + arg.val + ';');
      // 		}
      // 		s.push('\n');
      // 	} else {
      // 		var arguments = arg.arguments;
      // 		s.push('context.' + arg.method + '(');
      // 		if (arguments) {
      // 			for (var j = 0; j < arguments.length; j++) {
      // 				if (j > 0) {
      // 					s.push(', ');
      // 				}
      // 				var val = arguments[j];
      // 				if (_.isString()) {
      // 					s.push("'");
      // 					s.push(val);
      // 					s.push("'");
      // 				} else {
      // 					s.push(val);
      // 				}
      //
      // 			}
      // 		}
      // 		s.push(');\n');
      // 	}
      //
      // }
      // saveAs(new Blob([s.join('')], {
      // 	type: 'text/plain;charset=utf-8'
      // }), 'canvas.txt', true);
      canvas.toBlob(function (blob) {
        if (blob == null || blob.size === 0) {
          morpheus.FormBuilder.showInModal({
            title: 'Save Image',
            html: 'Image is too large to save.',
            appendTo: _this.getContentEl()
          });
          return;
        }

        saveAs(blob, file, true);
      });
    }
  }
  ,
  getTotalSize: function (options) {
    options = $.extend({}, {
      legend: true
    }, options);
    var _this = this;
    var heatmapPrefSize = this.heatmap.getPreferredSize();
    var totalSize = {
      width: heatmapPrefSize.width,
      height: heatmapPrefSize.height
    };
    if (this.isDendrogramVisible(false)) { // row dendrogram
      totalSize.width += this.rowDendrogram.getUnscaledWidth() + morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS;
    }
    if (this.isDendrogramVisible(true)) {
      totalSize.height += this.columnDendrogram.getUnscaledHeight() + morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS;
    }
    var maxRowHeaderHeight = 0;
    for (var i = 0, length = this.rowTracks.length; i < length; i++) {
      var track = this.rowTracks[i];
      if (track.isVisible()) {
        var headerSize = this.rowTrackHeaders[i].getPrintSize();
        totalSize.width += Math.max(headerSize.width, track
          .getPrintSize().width);
        maxRowHeaderHeight = Math.max(maxRowHeaderHeight, headerSize.height);
      }
    }
    var maxColumnHeaderWidth = 0;
    var columnTrackHeightSum = 0;
    for (var i = 0, length = this.columnTracks.length; i < length; i++) {
      var track = this.columnTracks[i];
      if (track.isVisible()) {
        columnTrackHeightSum += track.getPrintSize().height;
        maxColumnHeaderWidth = Math.max(maxColumnHeaderWidth,
          this.columnTrackHeaders[i].getPrintSize().width);
      }
    }
    totalSize.height += Math.max(columnTrackHeightSum, maxRowHeaderHeight) + morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS;
    totalSize.width += maxColumnHeaderWidth + morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS;
    // color legend
    if (options.legend) {
      var totalLegendWidth = 15;
      var maxLegendHeight = 0;
      var colorByValues = this.heatmap.getColorScheme().getColorByValues();
      var ntracks = colorByValues.length;
      for (var i = 0; i < ntracks; i++) {
        var value = colorByValues[i];
        if (value != null || ntracks === 1) {
          // if (value != 'null') { // values are stored as string
          //
          // }

          this.heatmap.getColorScheme().setCurrentValue(value);
          var names = this.heatmap.getColorScheme().getNames();
          maxLegendHeight = Math.max(maxLegendHeight, names != null ? names.length * 14 : 30);
          totalLegendWidth += 250;
        }
      }
      maxLegendHeight += 10; // spacer
      totalSize.height = totalSize.height + maxLegendHeight;
      totalSize.width = Math.max(totalSize.width, totalLegendWidth);
    }
    var trackLegendSize = new morpheus.HeatMapTrackColorLegend(
      _
        .filter(
          this.columnTracks,
          function (track) {
            return track.isVisible()
              && (track
                .isRenderAs(morpheus.VectorTrack.RENDER.COLOR) || track
                .isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_COLOR));
          }), this.getProject().getColumnColorModel())
      .getPreferredSize();
    totalSize.height += trackLegendSize.height;
    totalSize.width = Math.max(totalSize.width, trackLegendSize.width);
    trackLegendSize = new morpheus.HeatMapTrackColorLegend(
      _
        .filter(
          this.rowTracks,
          function (track) {
            return track.isVisible()
              && (track
                .isRenderAs(morpheus.VectorTrack.RENDER.COLOR) || track
                .isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_COLOR));
          }), this.getProject().getRowColorModel())
      .getPreferredSize();
    totalSize.height += morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS + trackLegendSize.height;
    totalSize.width = morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS + Math.max(totalSize.width, trackLegendSize.width);
    return totalSize;
  }
  ,
  getHeatMapElementComponent: function () {
    return this.heatmap;
  }
  ,
  snapshot: function (context, options) {
    options = $.extend({}, {
      legend: true
    }, options);
    var heatmapPrefSize = this.heatmap.getPreferredSize();
    var totalSize = this.getTotalSize(options);
    var legendHeight = 0;
    if (options.legend) {
      var colorByValues = this.heatmap.getColorScheme().getColorByValues();
      context.save();
      context.translate(15, 0);
      var ntracks = colorByValues.length;
      for (var i = 0, ntracks = colorByValues.length; i < ntracks; i++) {
        var value = colorByValues[i];
        if (value != null || ntracks === 1) {
          if (value != 'null') { // values are stored as string
            // var $label = $('<div style="overflow:hidden;text-overflow:' +
            //   ' ellipsis;width:250px;max-width:250px;">'
            //   + value + '</div>');
            // $keyContent.append($label);
            // totalHeight += $label.height();
          }
          var trackLegend = new morpheus.ColorSupplierLegend(
            this.heatmap.getColorScheme(), value);
          trackLegend.draw({}, context);
          legendHeight = Math.max(legendHeight, trackLegend.getUnscaledHeight());
          var legendWidth = trackLegend.getUnscaledWidth();
          context.translate(legendWidth, 0);
        }
      }
      legendHeight += 10; // spacer

      // morpheus.HeatMapColorSchemeLegend.drawColorScheme(context,
      //   this.heatmap.getColorScheme(), 200, true);
      context.restore();
      // legendHeight = this.heatmap.getColorScheme().getNames() != null ? this.heatmap
      //   .getColorScheme().getNames().length * 14
      //   : 40;
    }
    context.save();
    context.translate(4, legendHeight);
    // column color legend
    var columnTrackLegend = new morpheus.HeatMapTrackColorLegend(
      _
        .filter(
          this.columnTracks,
          function (track) {
            return track.isVisible()
              && (track
                .isRenderAs(morpheus.VectorTrack.RENDER.COLOR) || track
                .isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_COLOR));
          }), this.getProject().getColumnColorModel());
    columnTrackLegend.draw({}, context);
    context.restore();
    // row color legend to the right of column color legend
    var columnTrackLegendSize = columnTrackLegend.getPreferredSize();
    context.save();
    context.translate(4 + columnTrackLegendSize.width, legendHeight);
    var rowTrackLegend = new morpheus.HeatMapTrackColorLegend(
      _
        .filter(
          this.rowTracks,
          function (track) {
            return track.isVisible()
              && (track
                .isRenderAs(morpheus.VectorTrack.RENDER.COLOR) || track
                .isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_COLOR));
          }), this.getProject().getRowColorModel());
    rowTrackLegend.draw({}, context);
    context.restore();
    legendHeight += Math.max(rowTrackLegend.getPreferredSize().height,
      columnTrackLegendSize.height);

    var heatmapY = this.isDendrogramVisible(true) ? (this.columnDendrogram
      .getUnscaledHeight() + morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS) : 0;
    heatmapY += legendHeight;
    var columnTrackY = heatmapY;
    var heatmapX = this.isDendrogramVisible(false) ? (this.rowDendrogram
      .getUnscaledWidth() + morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS) : 0;
    var isColumnTrackVisible = false;
    for (var i = 0, length = this.columnTracks.length; i < length; i++) {
      var track = this.columnTracks[i];
      if (track.isVisible()) {
        var header = this.columnTrackHeaders[i];
        heatmapX = Math.max(heatmapX, header.getPrintSize().width);
        heatmapY += track.getPrintSize().height;
        isColumnTrackVisible = true;
      }
    }
    if (isColumnTrackVisible) {
      heatmapY += morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS;
    }

    // check if row headers are taller than column tracks
    for (var i = 0, length = this.rowTracks.length; i < length; i++) {
      var track = this.rowTracks[i];
      if (track.isVisible()) {
        var header = this.rowTrackHeaders[i];
        heatmapY = Math.max(heatmapY, header.getPrintSize().height);
      }
    }
    if (this.isDendrogramVisible(true)) {
      var columnDendrogramClip = {
        x: 0,
        y: 0,
        height: this.columnDendrogram.getUnscaledHeight(),
        width: heatmapPrefSize.width
      };
      context.save();
      context.translate(heatmapX, legendHeight);
      this.columnDendrogram.prePaint(columnDendrogramClip, context);
      this.columnDendrogram.draw(columnDendrogramClip, context);
      context.restore();
    }
    if (this.isDendrogramVisible(false)) {
      var rowDendrogramClip = {
        x: 0,
        y: 0,
        width: this.rowDendrogram.getUnscaledWidth(),
        height: heatmapPrefSize.height
      };
      context.save();
      context.translate(0, heatmapY);
      this.rowDendrogram.prePaint(rowDendrogramClip, context);
      this.rowDendrogram.draw(rowDendrogramClip, context);
      context.restore();
    }

    for (var i = 0, length = this.columnTracks.length; i < length; i++) {
      var track = this.columnTracks[i];
      if (track.isVisible()) {
        context.save();
        context.translate(heatmapX, columnTrackY);
        var trackClip = {
          x: 0,
          y: 0,
          width: heatmapPrefSize.width,
          height: track.getPrintSize().height
        };
        track.print(trackClip, context);
        context.restore();
        // draw header
        var header = this.columnTrackHeaders[i];
        context.save();
        var headerSize = header.getPrintSize();
        var headerClip = {
          x: 0,
          y: 0,
          width: headerSize.width,
          height: trackClip.height
        };
        context.translate(heatmapX - 2, columnTrackY + trackClip.height);
        header.print(headerClip, context);
        context.restore();
        columnTrackY += Math.max(headerClip.height, trackClip.height);
      }
    }
    context.save();
    context.translate(heatmapX, heatmapY);
    this.heatmap.draw({
      x: 0,
      y: 0,
      width: heatmapPrefSize.width,
      height: heatmapPrefSize.height
    }, context);
    context.restore();
    var rowTrackWidthSum = 0;
    for (var i = 0, length = this.rowTracks.length; i < length; i++) {
      var track = this.rowTracks[i];
      if (track.isVisible()) {
        context.save();
        var tx = morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS + heatmapX + heatmapPrefSize.width + rowTrackWidthSum;
        var ty = heatmapY;
        var trackClip = {
          x: 0,
          y: 0,
          width: track.getPrintSize().width,
          height: heatmapPrefSize.height
        };
        context.translate(tx, ty);
        context.strokeStyle = 'white';
        context.rect(0, 0, trackClip.width, trackClip.height);
        // stroke is needed for clip to work for svg export
        context.stroke();
        context.clip();

        track.print(trackClip, context);
        context.restore();
        // draw header
        var header = this.rowTrackHeaders[i];
        context.save();
        var headerSize = header.getPrintSize();
        var headerClip = {
          x: 0,
          y: 0,
          width: headerSize.width,
          height: headerSize.height
        };
        context.translate(tx, ty - 4);
        header.print(headerClip, context);
        context.restore();
        rowTrackWidthSum += Math.max(headerSize.width, trackClip.width);
      }
    }
  }
  ,
  resetZoom: function () {
    var heatmap = this.heatmap;
    var rowSizes = heatmap.getRowPositions();
    var columnSizes = heatmap.getColumnPositions();
    rowSizes.setSize(13);
    columnSizes.setSize(13);
    var reval = {};
    if (this.project.getHoverRowIndex() !== -1) {
      reval.scrollTop = this.heatmap.getRowPositions().getPosition(
        this.project.getHoverRowIndex());
    }
    if (this.project.getHoverColumnIndex() !== -1) {
      reval.scrollLeft = this.heatmap.getColumnPositions().getPosition(
        this.project.getHoverColumnIndex());
    }
    this.revalidate(reval);
  }
  ,
  getFitColumnSize: function () {
    var heatmap = this.heatmap;
    var availablePixels = this.getAvailableWidth();
    if (this.rowDendrogram) {
      availablePixels -= this.rowDendrogram.getUnscaledWidth();
    }
    var trackPixels = 12; // spacer
    for (var i = 0, length = this.rowTracks.length; i < length; i++) {
      var track = this.rowTracks[i];
      if (track.isVisible()) {
        trackPixels += track.getUnscaledWidth();
      }
    }
    for (var i = 0, length = this.columnTracks.length; i < length; i++) {
      var track = this.columnTracks[i];
      if (track.isVisible()) { // all column track headers have the
        // same width
        trackPixels += this.columnTrackHeaders[i].getUnscaledWidth();
        break;
      }
    }

    availablePixels -= trackPixels;

    var positions = heatmap.getColumnPositions();
    var totalCurrent = positions.getItemSize(positions.getLength() - 1)
      + positions.getPosition(positions.getLength() - 1);
    var size = positions.getSize();
    size = size * (availablePixels / totalCurrent);
    size = Math.min(13, size);
    return size;
  }
  ,
  getFitRowSize: function () {
    var heatmap = this.heatmap;
    var availablePixels = this.getAvailableHeight();

    if (this.columnDendrogram) {
      availablePixels -= this.columnDendrogram.getUnscaledHeight();
    }
    var trackPixels = 12;
    for (var i = 0, length = this.columnTracks.length; i < length; i++) {
      var track = this.columnTracks[i];
      if (track.isVisible()) {
        trackPixels += track.getUnscaledHeight();
      }
    }
    availablePixels -= trackPixels;
    var positions = heatmap.getRowPositions();
    var totalCurrent = positions.getItemSize(positions.getLength() - 1)
      + positions.getPosition(positions.getLength() - 1);

    var size = positions.getSize();
    size = size * (availablePixels / totalCurrent);
    size = Math.min(13, size);
    return size;
  }
  ,
  fitToWindow: function (repaint) {
    this.heatmap.getRowPositions().setSize(this.getFitRowSize());
    this.heatmap.getColumnPositions().setSize(this.getFitColumnSize());
    if (repaint) {
      var reval = {};
      if (this.project.getHoverRowIndex() !== -1) {
        reval.scrollTop = this.heatmap.getRowPositions().getPosition(
          this.project.getHoverRowIndex());
      }
      if (this.project.getHoverColumnIndex() !== -1) {
        reval.scrollLeft = this.heatmap.getColumnPositions()
          .getPosition(this.project.getHoverColumnIndex());
      }
      this.revalidate(reval);
    }
  }
  ,
  getAvailableHeight: function () {
    if (_.isNumber(this.options.height)) {
      return this.options.height;
    }
    var height = $(window).height() - this.$parent.offset().top - 24;
    if (this.options.height === 'window') {
      return height;
    }
    return Math.max(Math.round(screen.height * 0.7), height);
  }
  ,
  getAvailableWidth: function () {
    if (this.options.width) {
      return this.options.width;
    }
    // (this.$el.parent().outerWidth() - 30);
    // return this.$el.width() - 30;

    return this.tabManager.getWidth() - 30;
  }
  ,
  /**
   * Layout all the components
   */
  revalidate: function (options) {
    options = $.extend({}, {
      paint: true
    }, options);
    this.updatingScroll = true;
    var availableHeight = this.getAvailableHeight();
    var availableWidth = this.getAvailableWidth();
    var heatmapPrefSize = this.heatmap.getPreferredSize();

    var columnDendrogramHeight = 0;
    var rowDendrogramWidth = 0;
    if (this.columnDendrogram) {
      columnDendrogramHeight = morpheus.CanvasUtil
        .getPreferredSize(this.columnDendrogram).height;
    }
    if (this.rowDendrogram) {
      rowDendrogramWidth = morpheus.CanvasUtil
        .getPreferredSize(this.rowDendrogram).width;
    }
    var rowTrackWidthSum = 0;
    for (var i = 0, length = this.rowTracks.length; i < length; i++) {
      if (this.rowTracks[i].isVisible()) {
        rowTrackWidthSum += Math
          .max(
            morpheus.CanvasUtil
              .getPreferredSize(this.rowTrackHeaders[i]).width,
            morpheus.CanvasUtil
              .getPreferredSize(this.rowTracks[i]).width);
      }
    }
    var ypos = columnDendrogramHeight;
    var maxHeaderWidth = 0;
    for (var i = 0, length = this.columnTracks.length; i < length; i++) {
      if (this.columnTracks[i].isVisible()) {
        var width = morpheus.CanvasUtil
          .getPreferredSize(this.columnTrackHeaders[i]).width;
        maxHeaderWidth = Math.max(maxHeaderWidth, width);
      }
    }
    var xpos = Math.max(rowDendrogramWidth, maxHeaderWidth);
    var heatMapWidth = heatmapPrefSize.width;
    var maxHeatMapWidth = Math.max(50, availableWidth - rowTrackWidthSum
      - xpos
      - morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS);
    if (maxHeatMapWidth > 0 && heatMapWidth > maxHeatMapWidth) {
      heatMapWidth = maxHeatMapWidth;
      heatMapWidth = Math.min(heatMapWidth, heatmapPrefSize.width); // can't
      // go
      // bigger
      // than
      // pref
      // width
    }
    if (this.heatmap.prefWidth !== undefined) { // heat map was manually
      // resized
      heatMapWidth = Math.min(heatmapPrefSize.width,
        this.heatmap.prefWidth);
    }
    if (this.columnDendrogram !== undefined) {
      this.columnDendrogram.setBounds({
        width: heatMapWidth,
        height: columnDendrogramHeight,
        left: xpos,
        top: 0
      });
      this.columnDendrogram.$label.css('left',
        xpos + this.columnDendrogram.getUnscaledWidth() + 10).css(
        'top', 2);
      this.columnDendrogram.$squishedLabel.css('left',
        xpos + this.columnDendrogram.getUnscaledWidth() + 10).css(
        'top', 18);

      this.beforeColumnTrackDivider.setVisible(true);
      this.beforeColumnTrackDivider.setBounds({
        left: xpos - maxHeaderWidth,
        top: ypos,
        width: maxHeaderWidth
      });
      ypos++;
    } else {
      this.beforeColumnTrackDivider.setVisible(false);
    }

    for (var i = 0, length = this.columnTracks.length; i < length; i++) {
      var track = this.columnTracks[i];
      if (track.isVisible()) {
        var size = morpheus.CanvasUtil.getPreferredSize(track);
        var headerSize = morpheus.CanvasUtil
          .getPreferredSize(this.columnTrackHeaders[i]);
        size.height = Math.max(size.height, headerSize.height);
        track.setBounds({
          width: heatMapWidth,
          height: size.height,
          left: xpos,
          top: ypos
        });
        this.columnTrackHeaders[i].setBounds({
          width: maxHeaderWidth,
          height: size.height,
          left: xpos - maxHeaderWidth,
          top: ypos
        });
        ypos += size.height;
      }
    }
    this.$whitespace[0].style.left = Math.ceil(xpos + heatMapWidth + 10) + 'px';
    this.$whitespace[0].style.top = '0px';
    ypos += morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS;
    var heatMapHeight = heatmapPrefSize.height;
    if (heatMapHeight > (availableHeight - ypos)) {
      heatMapHeight = Math.max(100, Math.min(heatmapPrefSize.height,
        availableHeight - ypos));
    }
    if (ypos < 0) {
      ypos = 0;
    }
    if (this.rowDendrogram) {
      this.rowDendrogram.setBounds({
        width: Math.max(rowDendrogramWidth, maxHeaderWidth),
        height: heatMapHeight,
        left: 0,
        top: ypos
      });
      this.rowDendrogram.$label.css('left', 0).css('top', 2);
      this.afterRowDendrogramDivider.setVisible(true);
      this.afterRowDendrogramDivider.setBounds({
        height: heatMapHeight,
        left: this.rowDendrogram.getUnscaledWidth(),
        top: ypos
      });
      xpos++;
    } else {
      this.afterRowDendrogramDivider.setVisible(false);
    }
    this.heatmap.setBounds({
      width: heatMapWidth,
      height: heatMapHeight,
      left: xpos,
      top: ypos
    });
    this.hSortByValuesIndicator.setBounds({
      height: 4,
      width: heatMapWidth,
      left: xpos,
      top: ypos - 4
    });
    this.hscroll.setVisible(heatMapWidth < heatmapPrefSize.width);
    this.hscroll.setExtent(heatMapWidth, heatmapPrefSize.width,
      options.scrollLeft !== undefined ? options.scrollLeft
        : (heatmapPrefSize.width === this.hscroll
        .getTotalExtent() ? this.hscroll.getValue()
        : heatmapPrefSize.width
      * this.hscroll.getValue()
      / this.hscroll.getMaxValue()));
    this.hscroll.setBounds({
      left: xpos,
      top: ypos + heatMapHeight + 2
    });
    xpos += heatMapWidth;
    var nvisibleRowTracks = 0;
    for (var i = 0, length = this.rowTracks.length; i < length; i++) {
      var track = this.rowTracks[i];
      if (track.isVisible()) {
        nvisibleRowTracks++;
        break;
      }
    }
    this.vSortByValuesIndicator.setBounds({
      width: 4,
      height: heatMapHeight,
      left: xpos,
      top: ypos
    });
    if (nvisibleRowTracks > 0) {
      xpos = xpos
        + morpheus.HeatMap.SPACE_BETWEEN_HEAT_MAP_AND_ANNOTATIONS; // leave
      // space
      // after
      // afterVerticalScrollBarDivider
    }
    var rowAnnotationXStart = xpos;
    for (var i = 0, length = this.rowTracks.length; i < length; i++) {
      var track = this.rowTracks[i];
      if (track.isVisible()) {
        var size = morpheus.CanvasUtil.getPreferredSize(track);
        var headerSize = morpheus.CanvasUtil
          .getPreferredSize(this.rowTrackHeaders[i]);
        size.width = Math.max(headerSize.width, size.width);
        size.height = heatMapHeight;
        track.setBounds({
          width: size.width,
          height: size.height,
          left: xpos,
          top: ypos
        });

        this.rowTrackHeaders[i].setBounds({
          width: size.width,
          left: xpos,
          top: ypos - headerSize.height - 5,
          height: headerSize.height
        });
        xpos += size.width;
      }
    }
    this.afterVerticalScrollBarDivider
      .setVisible(nvisibleRowTracks > 0 ? true : false);
    this.afterVerticalScrollBarDivider.setBounds({
      left: rowAnnotationXStart - 2,
      top: ypos - 18
    });
    this.vscroll.setVisible(heatMapHeight < heatmapPrefSize.height);
    this.vscroll.setExtent(heatMapHeight, heatmapPrefSize.height,
      options.scrollTop !== undefined ? options.scrollTop
        : (heatmapPrefSize.height === this.vscroll
        .getTotalExtent() ? this.vscroll.getValue()
        : heatmapPrefSize.height
      * this.vscroll.getValue()
      / this.vscroll.getMaxValue()));
    xpos += 2;
    this.vscroll.setBounds({
      left: xpos,
      top: ypos
    });
    xpos += this.vscroll.getUnscaledWidth();
    if (this.hscroll.isVisible()) {
      ypos += this.hscroll.getUnscaledHeight() + 2;
    }
    var totalHeight = 2 + ypos + heatMapHeight;
    if (options.paint) {
      this.paintAll({
        paintRows: true,
        paintColumns: true,
        invalidateRows: true,
        invalidateColumns: true
      });
    }

    this.$parent.css({
      height: Math.ceil(totalHeight) + 'px'
    });
    //
    // if (this.options.setWidth) {
    //   this.$parent.css({
    //     width: Math.ceil(xpos + 2) + 'px'
    //   });
    // }

    this.updatingScroll = false;
    this.trigger('change', {
      name: 'revalidate',
      source: this,
      arguments: arguments
    });
  }
};
morpheus.HeatMap.copyFromParent = function (project, options) {
  // TODO persist sort order, grouping, dendrogram

  project.rowColorModel = options.parent.getProject().getRowColorModel()
    .copy();
  project.columnColorModel = options.parent.getProject()
    .getColumnColorModel().copy();

  project.rowShapeModel = options.parent.getProject().getRowShapeModel()
    .copy();
  project.columnShapeModel = options.parent.getProject()
    .getColumnShapeModel().copy();

  var parentRowTracks = options.parent.rowTracks || [];
  var parentColumnTracks = options.parent.columnTracks || [];
  if (options.inheritFromParentOptions.rows) { // row similarity matrix
    project.columnShapeModel = project.rowShapeModel;
    project.columnColorModel = project.rowColorModel;
    parentColumnTracks = parentRowTracks.slice().reverse();
  }
  if (options.inheritFromParentOptions.columns) { // column similarity matrix
    project.rowShapeModel = project.columnShapeModel;
    project.rowColorModel = project.columnColorModel;
    parentRowTracks = parentColumnTracks.slice().reverse();
  }

  if (options.inheritFromParentOptions.transpose) {
    var tmp = project.rowShapeModel;
    project.rowShapeModel = project.columnShapeModel;
    project.columnShapeModel = tmp;

    tmp = project.rowColorModel;
    project.rowColorModel = project.columnColorModel;
    project.columnColorModel = tmp;

    tmp = parentRowTracks.slice().reverse();
    // swap tracks
    parentRowTracks = parentColumnTracks.slice().reverse();
    parentColumnTracks = tmp;
  }
  // copy track rendering options and order
  // from parent
  options.rows = options.rows || [];

  for (var i = 0; i < parentRowTracks.length; i++) {
    var track = parentRowTracks[i];
    if (track.isVisible()) {
      options.rows.push({
        order: options.rows.length,
        field: track.getName(),
        display: $.extend(true, {}, track.settings),
        force: true
      });
    }
  }
  options.columns = options.columns || [];
  for (var i = 0; i < parentColumnTracks.length; i++) {
    var track = parentColumnTracks[i];
    if (track.isVisible()) {
      options.columns.push({
        order: options.columns.length,
        field: track.getName(),
        display: $.extend(true, {}, track.settings),
        force: true
      });
    }
  }
};
morpheus.Util.extend(morpheus.HeatMap, morpheus.Events);

morpheus.HelpMenu = function () {
  var html = [];
  html.push('<div class="btn-group">');
  html.push('<button type="button" class="btn btn-default btn-xxs' +
    ' dropdown-toggle"' +
    ' data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">');
  html.push('<svg width="14px" height="14px" style="inline-block;vertical-align:middle;"><g><rect x="0" y="0" width="14" height="6" style="fill:#ca0020;stroke:none"></rect><rect x="0" y="7" width="14" height="6" style="fill:#0571b0;stroke:none"></rect></g></svg>');
  html.push(' <span class="fa fa-caret-down"></span>');
  html.push('</button>');
  html
    .push('<ul class="dropdown-menu dropdown-menu-right" role="menu">');
  html.push('<li><a data-name="contact" href="#">Contact</a></li>');

  html.push('<li><a data-name="linking" href="#">Linking</a></li>');
  html.push('<li><a data-name="tutorial" href="#">Tutorial</a></li>');
  html.push('<li><a data-name="source" href="#">Source Code</a></li>');
  html.push('<li role="presentation" class="divider"></li>');
  html.push('<li><a data-name="keymap" href="#">Keymap Reference</a></li>');

  html.push('</ul>');
  html.push('</div>');
  this.$el = $(html.join(''));

};

morpheus.HistogramLegend = function (dataset, colorScheme, metadataValue) {
  morpheus.AbstractCanvas.call(this, true);
  this.colorScheme = colorScheme;
  this.metadataValue = metadataValue;
  this.dataset = dataset;
  this.binNumberToOccurences = null;
  this.setBounds({
    width: 250,
    height: 70
  });
  this.name = null;
  this.canvas.style.position = '';
  this.canvas.style.border = '1px solid LightGrey';
};

morpheus.HistogramLegend.prototype = {
  binSize: 0,
  maxCount: 0,
  total: 0,
  setName: function (name) {
    this.name = name;
  },
  setBinSize: function (binSize) {
    this.binSize = binSize;
  },
  buildHistogram: function () {
    var binSize = this.binSize;
    var dataset = this.dataset;
    var metadataValue = this.metadataValue;
    var colorScheme = this.colorScheme;
    var min = colorScheme.getMin();
    var max = colorScheme.getMax();
    if (min === max) {
      min -= 0.5;
      max += 0.5;
    }
    var vector =
      dataset.getRowMetadata().getByName(colorScheme.getSeparateColorSchemeForRowMetadataField());
    // var numberOfBins = Math.ceil(morpheus.Log2(dataset.getRowCount() * dataset.getColumnCount()) + 1);
    // var binSize = (max - min) / numberOfBins;
    var numberOfBins = Math.ceil((max - min) / binSize);
    var binNumberToOccurences = new Uint32Array(numberOfBins);
    this.binNumberToOccurences = binNumberToOccurences;
    //var values = new Float32Array(dataset.getRowCount() * dataset.getColumnCount()); // for
    // boxplot
    var index = 0;
    for (var i = 0, nrows = dataset.getRowCount(); i < nrows; i++) {
      if (vector == null || vector.getValue(i) === metadataValue) {
        for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
          var value = dataset.getValue(i, j);
          if (isNaN(value)) {
            continue;
          }
          //    values[index++] = value;
          var bin = Math.floor(((value - min) / binSize));
          if (bin < 0) {
            bin = 0;
          } else if (bin >= numberOfBins) {
            bin = numberOfBins - 1;
          }
          binNumberToOccurences[bin]++;
        }
      }
    }
    // values = values.slice(0, index);
    // values.sort();

    var maxCount = 0;
    var total = 0;
    for (var i = 0; i < numberOfBins; i++) {
      var count = binNumberToOccurences[i];
      maxCount = count >= maxCount ? count : maxCount;
      total += count;
    }
    this.maxCount = maxCount;
    this.total = total;
  },
  draw: function (clip, context) {
    this.buildHistogram();
    var colorScheme = this.colorScheme;
    var canvasWidth = this.getUnscaledWidth() - 50;
    var valueToPosition = d3.scale.linear().domain([colorScheme.getMin(), colorScheme.getMax()]).range([0, canvasWidth]).clamp(
      true);
    var histogramHeight = 30;
    var countToPosition = d3.scale.linear().domain([0, this.maxCount / this.total]).range([histogramHeight, 0]).clamp(
      true);
    var binNumberToOccurences = this.binNumberToOccurences;
    var min = colorScheme.getMin();
    var binSize = this.binSize;
    var y0 = countToPosition(0);

    if (this.name != null) {
      context.font = '11px ' + morpheus.CanvasUtil.FONT_NAME;
      context.fillStyle = 'black';
      context.lineWidth = 1;
      //  context.textBaseline = 'top';
      context.fillText(this.name, 0.5, 12);
      context.translate(0, 14);
    }
    context.lineWidth = 0.2;
    context.strokeStyle = '#D3D2C2';
    context.fillStyle = '#D3D2C2'; //'#d9d9d9';
    context.translate(25, 0);
    context.beginPath();
    context.moveTo(0, y0);
    context.lineTo(canvasWidth, y0);
    context.stroke();
    context.lineWidth = 1;
    context.strokeStyle = 'white';
    for (var i = 0, numberOfBins = binNumberToOccurences.length; i < numberOfBins; i++) {
      var count = binNumberToOccurences[i];
      if (count > 0) {
        count /= this.total;
        var start = min + (i * binSize);
        var end = start + binSize;
        var x = valueToPosition(start);
        var width = valueToPosition(end) - x;
        var y = countToPosition(count);
        context.rect(x, y0, width, y - y0);
        context.fill();
        context.stroke();
      }
    }
    // boxplot
    // var q25 = valueToPosition(this.q25);
    // var q75 = valueToPosition(this.q75);
    // var median = valueToPosition(this.median);
    // var lav = valueToPosition(this.lowerAdjacentValue);
    // var uav = valueToPosition(this.upperAdjacentValue);
    // context.translate(0, histogramHeight + 1);
    // context.fillStyle = 'black';
    //  var boxPlotHeight = 8;
    // context.fillRect(q25, 0, q75 - q25, boxPlotHeight);
    //
    // context.fillRect(lav, boxPlotHeight / 2 - 1, q25 - lav, 2);
    //
    // context.fillRect(q75, boxPlotHeight / 2 - 1, uav - q75, 2);
    //
    // context.fillStyle = 'white';
    // context.fillRect(median - 1, 0.5, 2, boxPlotHeight - 0.5);
    //
    context.translate(0, histogramHeight + 1);
    context.fillStyle = 'black';
    morpheus.HeatMapColorSchemeLegend.drawColorScheme(context,
      this.colorScheme, canvasWidth, false, false, 6);
  }
}
;

morpheus.Util.extend(morpheus.HistogramLegend, morpheus.AbstractCanvas);

morpheus.LegendWithStops = function () {
  morpheus.AbstractCanvas.call(this, false);
  this.setBounds({
    width: 300,
    height: 40
  });
  var that = this;
  this.hammer = morpheus.Util.hammer(this.canvas, ['pan', 'tap', 'press'])
    .on(
      'panmove',
      this.panmove = function (event) {
        if (that.panStartSelectedIndex !== -1) {
          var position = morpheus.CanvasUtil.getMousePos(
            event.target, event);
          var fraction = that.fractionToStopPix
            .invert(position.x);
          fraction = Math.max(0, fraction);
          fraction = Math.min(1, fraction);
          that.trigger('moved', {
            fraction: fraction
          });
        }
      }).on(
      'panstart',
      this.panstart = function (event) {
        that.panStartSelectedIndex = that
          .findIndexForPosition(morpheus.CanvasUtil
            .getMousePos(event.target, event, true));
      }).on('panend', this.panend = function (event) {
      that.panStartSelectedIndex = -1;
    }).on(
      'tap',
      this.tap = function (event) {
        var position = morpheus.CanvasUtil.getMousePos(
          event.target, event);
        if (event.tapCount > 1) {
          // don't add on double-click
          // var fraction = that.fractionToStopPix
          // .invert(position.x);
          // that.trigger('added', {
          //   fraction: fraction
          // });
        } else {
          that.selectedIndex = that
            .findIndexForPosition(position);
          that.trigger('selectedIndex', {
            selectedIndex: that.selectedIndex
          });
        }
      });
  $(this.canvas).on('keydown', function (e) {
    // 8=backspace, 46=delete
    if ((e.which == 8 || e.which == 46) && that.selectedIndex !== -1) {
      that.trigger('delete');
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
    }
  });
};
morpheus.LegendWithStops.prototype = {
  selectedIndex: -1,
  border: 7,
  stopHalfSize: 5,
  panStartSelectedIndex: -1,
  destroy: function () {
    $(this.canvas).off('keyup');
    this.hammer.off('panstart',
      this.panstart).off('panmove', this.panmove).off('tap', this.tap);
    this.hammer.destroy();
  },
  setSelectedIndex: function (index) {
    this.panStartSelectedIndex = -1;
  },
  findIndexForPosition: function (position) {
    // pix - stopHalfSize to pix + stopHalfSize
    if (position.y >= 22) {
      for (var i = 0, length = this.fractions.length; i < length; i++) {
        var pix = this.fractionToStopPix(this.fractions[i]);
        var start = pix - this.stopHalfSize;
        var end = pix + this.stopHalfSize;
        if (position.x >= start && position.x <= end) {
          return i;
        }
      }
    }
    return -1;
  },
  draw: function (fractions, colors, stepped, fractionToStopPix) {
    this.fractions = fractions;
    this.colors = colors;
    this.stepped = stepped;
    this.fractionToStopPix = fractionToStopPix;
    var context = this.canvas.getContext('2d');
    morpheus.CanvasUtil.resetTransform(context);
    context.clearRect(0, 0, this.getUnscaledWidth(), this
      .getUnscaledHeight());
    context.translate(this.border, 0);
    morpheus.HeatMapColorSchemeLegend.draw(context, fractions, colors, this
        .getUnscaledWidth()
      - 2 * this.border, this.getUnscaledHeight() - 20, stepped);
    context.translate(-this.border, 0);
    context.lineWidth = 1;
    context.strokeStyle = 'Grey';
    context.strokeRect(this.border, 0, this.getUnscaledWidth() - 2
      * this.border, this.getUnscaledHeight() - 20);
    for (var i = 0; i < fractions.length; i++) {
      if (i > 0 && fractions[i] === fractions[i - 1]) {
        continue;
      }
      context.fillStyle = colors[i];
      var pix = fractionToStopPix(fractions[i]);
      context.fillRect(pix - this.stopHalfSize, 22,
        this.stopHalfSize * 2, this.stopHalfSize * 2);
      if (this.selectedIndex === i) {
        context.lineWidth = 2;
        context.strokeStyle = 'black';
      } else {
        context.lineWidth = 1;
        context.strokeStyle = 'Grey';
      }
      context.strokeRect(pix - this.stopHalfSize, 22,
        this.stopHalfSize * 2, this.stopHalfSize * 2);
    }
  }
};
morpheus.Util.extend(morpheus.LegendWithStops, morpheus.AbstractCanvas);
morpheus.Util.extend(morpheus.LegendWithStops, morpheus.Events);

morpheus.Popup = {};
morpheus.Popup.initted = false;
morpheus.Popup.init = function () {
  if (morpheus.Popup.initted) {
    return;
  }

  morpheus.Popup.initted = true;
  morpheus.Popup.$popupDiv = $(document.createElement('div'));
  morpheus.Popup.$popupDiv.css('position', 'absolute').css('zIndex', 1050).css('overflow', 'auto').addClass('dropdown clearfix');
  morpheus.Popup.$contextMenu = $(document.createElement('ul'));
  morpheus.Popup.$contextMenu.addClass('dropdown-menu').css('display',
    'block').css('position', 'static').css('margin-bottom', '5px');
  morpheus.Popup.$contextMenu.appendTo(morpheus.Popup.$popupDiv);
  morpheus.Popup.$contextMenu.on('click', 'a', function (e) {
    e.preventDefault();
    var $this = $(this);
    // if (!$this.hasClass('copy')) {
    morpheus.Popup.popupCallback(e, $this.data('name'));
    morpheus.Popup.hide();
    // }

  });
};

morpheus.Popup.popupInDom = false;
morpheus.Popup.hidePopupMenu = function (e) {
  if (morpheus.Popup.component == e.target) {
    e.preventDefault();
    e.stopPropagation();
  }
  morpheus.Popup.hide();
};
morpheus.Popup.hide = function () {
  morpheus.Popup.$popupDiv.hide();
  $(document.body).off('mousedown', morpheus.Popup.hidePopupMenu);
  morpheus.Popup.popupCallback = null;
  morpheus.Popup.component = null;
};

morpheus.Popup.showPopup = function (menuItems, position, component, callback) {
  morpheus.Popup.init();
  if (morpheus.Popup.component == component) {
    morpheus.Popup.hide();
    return;
  }
  morpheus.Popup.popupCallback = callback;
  morpheus.Popup.component = component;
  var html = [];
  for (var i = 0, length = menuItems.length; i < length; i++) {
    var item = menuItems[i];
    if (item.header) {
      html.push('<li role="presentation" class="dropdown-header">'
        + item.name + '</li>');
    } else if (item.separator) {
      html.push('<li class="divider"></li>');
    } else {
      html.push('<li role="presentation"');
      if (item.disabled) {
        html.push('class="disabled"');
      }
      html.push('><a data-name="' + item.name
        + '" data-type="popup-item" tabindex="-1" href="#"');
      if (item.class) {
        html.push(' class="' + item.class + '"');
      }
      html.push('>');
      if (item.checked) {
        html
          .push('<span class="dropdown-checkbox fa fa-check"></span>');
      }

      html.push(item.name);
      if (item.icon) {
        html.push('<span class="pull-right ' + item.icon + '"></span>');
      }
      html.push('</a>');

      html.push('</li>');
    }
  }
  morpheus.Popup.$contextMenu.html(html.join(''));
  if (!morpheus.Popup.popupInDom) {
    morpheus.Popup.popupInDom = true;
    morpheus.Popup.$popupDiv.appendTo($(document.body));
  }
  var $body = $(document.body);
  var $window = $(window);
  var windowWidth = $window.width();
  var windowHeight = $window.height();
  var popupWidth = morpheus.Popup.$popupDiv.width();
  var popupHeight = morpheus.Popup.$popupDiv.height();
  var left = position.x;
  var top = position.y;
  // default is bottom-right
  if ((left + popupWidth) >= windowWidth) { // offscreen right
    left -= popupWidth;
    left = Math.max(4, left);
  }
  if ((top + popupHeight) >= (windowHeight)) { // offscreen bottom
    top -= popupHeight;
    top = Math.max(4, top);
  }

  morpheus.Popup.$popupDiv.css({
    height: popupHeight + 'px',
    display: 'block',
    left: left,
    top: top
  });

  morpheus.Popup.$popupDiv.show();

  $body.off('mousedown', morpheus.Popup.hidePopupMenu);
  window.setTimeout(function () {
    $body.on('mousedown', function (e) {
      var $target = $(e.target);
      if ($target[0] !== morpheus.Popup.$popupDiv[0] && $target.data('type') !== 'popup-item') {
        morpheus.Popup.hidePopupMenu(e);
      }
    });
  }, 1);
};

morpheus.RowDendrogram = function (heatMap, tree, positions, project) {
  morpheus.AbstractDendrogram.call(this, heatMap, tree, positions,
    project, morpheus.AbstractDendrogram.Type.ROW);
};
morpheus.RowDendrogram.prototype = {
  drawNode: function (context, node) {
    var radius = this.getNodeRadius(node);
    var pix = this.toPix(node);
    context.beginPath();
    context.arc(pix[0], pix[1], radius, Math.PI * 2, false);
    context.fill();
  },
  isDragHotSpot: function (p) {
    return Math.abs(this.scale(this.cutHeight) - p.x) <= 2;
  },
  drawCutSlider: function (clip, context) {
    if (context.setLineDash) {
      context.setLineDash([5]);
    }
    context.strokeStyle = 'black';
    var nx = this.scale(this.cutHeight);
    context.beginPath();
    context.moveTo(nx, clip.y);
    context.lineTo(nx, this.getUnscaledHeight());
    context.stroke();
    if (context.setLineDash) {
      context.setLineDash([]);
    }
  },
  getPreferredSize: function () {
    return {
      width: 100,
      height: Math.ceil(this.positions.getPosition(this.positions
            .getLength() - 1)
        + this.positions
          .getItemSize(this.positions.getLength() - 1))
    };
  },
  paintMouseOver: function (clip, context) {
    if (this.project.getHoverRowIndex() !== -1) {
      morpheus.CanvasUtil.resetTransform(context);
      context.translate(0, -clip.y);
      this.drawRowBorder(context, this.positions, this.project
        .getHoverRowIndex(), this.getUnscaledWidth());
    }
  },
  drawRowBorder: function (context, positions, index, gridSize) {
    var size = positions.getItemSize(index);
    var pix = positions.getPosition(index);
    // top and bottom lines
    context.beginPath();
    context.moveTo(0, pix + size);
    context.lineTo(gridSize, pix + size);
    context.stroke();
    context.beginPath();
    context.moveTo(0, pix);
    context.lineTo(gridSize, pix);
    context.stroke();
  },
  createScale: function () {
    return d3.scale.linear().domain([0, this.tree.maxHeight]).range(
      [this.getUnscaledWidth(), 0]);
  },
  getMaxIndex: function (clip) {
    return morpheus.Positions.getBottom(clip, this.positions);
  },
  getMinIndex: function (clip) {
    return morpheus.Positions.getTop(clip, this.positions);
  },
  toPix: function (node) {
    var min = this.positions.getPosition(node.minIndex)
      + this.positions.getItemSize(node.minIndex) / 2;
    var max = this.positions.getPosition(node.maxIndex)
      + this.positions.getItemSize(node.maxIndex) / 2;
    return [this.scale(node.height), (min + max) / 2];
  },
  drawPathFromNodeToParent: function (context, node) {
    var pix = this.toPix(node);
    var parentPix = this.toPix(node.parent);
    context.beginPath();
    context.moveTo(pix[0], pix[1]);
    context.lineTo(parentPix[0], pix[1]);
    context.lineTo(parentPix[0], parentPix[1]);
    context.stroke();
  },
  drawNodePath: function (context, node, minIndex, maxIndex) {
    var children = node.children;
    var left = children[0];
    var right = children[1];
    // set up points for poly line
    var ry = this.toPix(right)[1];
    var rx = this.scale(right.height);
    var ly = this.toPix(left)[1];
    var lx = this.scale(left.height);
    var nx = this.scale(node.height);
    var x;
    var y;
    if (!this.drawLeafNodes) {
      var leftIsLeaf = left.children !== undefined;
      var rightIsLeaf = right.children !== undefined;
      if (leftIsLeaf) {
        lx = nx + 4;
      }
      if (rightIsLeaf) {
        rx = nx + 4;
      }
      x = [rx, nx, nx, lx];
      y = [ry, ry, ly, ly];
    } else {
      x = [rx, nx, nx, lx];
      y = [ry, ry, ly, ly];
    }
    context.beginPath();
    context.moveTo(x[0], y[0]);
    for (var i = 1, length = x.length; i < length; i++) {
      context.lineTo(x[i], y[i]);
    }
    context.stroke();
  }
};
morpheus.Util.extend(morpheus.RowDendrogram, morpheus.AbstractDendrogram);

/**
 * @param model{morpheus.SelectionModel}
 */
morpheus.ScentedSearch = function (model, positions, isVertical, scrollbar,
                                   heatMap) {
  morpheus.AbstractCanvas.call(this, false);
  this.model = model;
  this.positions = positions;
  this.isVertical = isVertical;
  this.scrollbar = scrollbar;
  this.heatMap = heatMap;
  this.searchIndices = [];
  scrollbar.decorator = this;
  var _this = this;
  var mouseMove = function (e) {
    var indices = _this.getSearchIndices(e);

    document.body.style.cursor = indices.length === 0 ? 'default' : 'pointer';
    scrollbar.canvas.style.cursor = indices.length === 0 ? 'default' : 'pointer';
    var tipOptions = {
      event: e,
      heatMapLens: indices.length >= 0
    };
    if (isVertical) {
      heatMap.setToolTip(indices.length >= 0 ? indices : null,
        -1, tipOptions);
    } else {
      heatMap.setToolTip(-1, indices.length >= 0 ? indices
        : null, tipOptions);
    }

  };
  var mouseExit = function (e) {
    // need to set body cursor b/c mouse can be partially on the scroll bar,
    // but the canvas cursor has no effect
    document.body.style.cursor = 'default';
    scrollbar.canvas.style.cursor = 'default';
    heatMap.setToolTip(-1, -1, {event: e});
  };
  var showPopup = function (e) {
    e.preventDefault();
    if (e.stopPropagation) {
      e.stopPropagation();
    }
    if (e.stopImmediatePropagation) {
      e.stopImmediatePropagation();
    }
    morpheus.Popup
      .showPopup(
        [

          {
            name: 'Selection To Top',
            checked: heatMap.getToolbar().isSelectionOnTop(!isVertical),
            disabled: isVertical ? heatMap.getProject().getRowSelectionModel()
              .count() === 0 : heatMap.getProject().getColumnSelectionModel()
              .count() === 0
          },
          {
            name: 'New Heat Map (' + morpheus.Util.COMMAND_KEY + 'X)'
          }],
        {
          x: e.pageX,
          y: e.pageY
        },
        e.target,
        function (event, item) {
          if (item === 'Selection To Top') {
            heatMap.getToolbar().setSelectionOnTop({
              isColumns: !isVertical,
              isOnTop: !heatMap.getToolbar().isSelectionOnTop(!isVertical),
              updateButtonStatus: true
            });
          } else {
            morpheus.HeatMap.showTool(new morpheus.NewHeatMapTool(),
              heatMap);
          }
        });
    return false;
  };
  $(scrollbar.canvas).on('mousemove.morpheus', mouseMove).on('mouseout.morpheus', mouseExit).on('contextmenu.morpheus', showPopup);

};

morpheus.ScentedSearch.LINE_HEIGHT = 3.5;
morpheus.ScentedSearch.prototype = {
  mouseMovedIndex: -1,
  getIndex: function (event) {
    var pix = morpheus.CanvasUtil.getMousePos(event.target, event);
    var val = pix[this.isVertical ? 'y' : 'x'];
    return this.getIndexForPix(val);
  },
  getSearchIndices: function (event) {
    var pix = morpheus.CanvasUtil.getMousePos(event.target, event);
    var val = pix[this.isVertical ? 'y' : 'x'];
    return this.getSearchIndicesForPix(val);
  },
  getSearchIndicesForPix: function (pix) {
    var indices = this.searchIndices;
    if (indices == null) {
      return [];
    }
    var scale = this.scale;
    var tolerance = morpheus.ScentedSearch.LINE_HEIGHT;
    var matches = [];
    for (var i = 0, length = indices.length; i < length; i++) {
      var midVal = this.positions.getPosition(indices[i]) * scale;
      if (Math.abs(midVal - pix) <= tolerance) {
        matches.push(indices[i]);
      }
    }
    return matches;
  },
  getIndexForPix: function (pix) {
    var indices = this.searchIndices;
    if (indices == null) {
      return -1;
    }
    var tolerance = morpheus.ScentedSearch.LINE_HEIGHT;
    if (this.mouseMovedIndex > 0) {
      var midVal = this.positions
          .getPosition(indices[this.mouseMovedIndex])
        * scale;
      if (Math.abs(midVal - pix) <= tolerance) {
        return this.mouseMovedIndex;
      }
    }
    var low = 0;
    var scale = this.scale;
    var high = indices.length - 1;

    while (low <= high) {
      var mid = (low + high) >> 1;
      var midVal = this.positions.getPosition(indices[mid]) * scale;
      var cmp = 0;
      if (Math.abs(midVal - pix) <= tolerance) {
        cmp = 0;
      } else if (midVal < pix) {
        cmp = -1; // Neither val is NaN, thisVal is smaller
      } else if (midVal > pix) {
        cmp = 1; // Neither val is NaN, thisVal is larger
      }
      if (cmp < 0)
        low = mid + 1;
      else if (cmp > 0)
        high = mid - 1;
      else
        return mid; // key found
    }
    return -1; // -(low + 1); // key not found.

  },
  tap: function (position) {
    var val = position[this.isVertical ? 'y' : 'x'];
    var index = this.getIndexForPix(val);
    this.scrollbar.canvas.style.cursor = index < 0 ? 'default' : 'pointer';
    if (index >= 0) {
      if (this.isVertical) {
        this.heatMap.scrollTop(this.positions
          .getPosition(this.searchIndices[index]));
      } else {
        this.heatMap.scrollLeft(this.positions
          .getPosition(this.searchIndices[index]));
      }
      return true;
    }
    return false;
  },
  update: function () {
    this.searchIndices = this.model.getViewIndices().values().sort(
      function (a, b) {
        return a < b ? -1 : 1;
      });
  },
  draw: function (clip, context) {
    var width = this.scrollbar.getUnscaledWidth();
    var height = this.scrollbar.getUnscaledHeight();
    var availableLength = ((this.isVertical ? height : width))
      - morpheus.ScentedSearch.LINE_HEIGHT;
    this.scale = availableLength
      / (this.positions.getPosition(this.positions.getLength() - 1) + this.positions
        .getItemSize(this.positions.getLength() - 1));
    context.fillStyle = morpheus.ScentedSearch.TICK_COLOR;
    context.lineWidth = 1;
    this.drawIndices(context, this.searchIndices);
    this.drawHoverMatchingValues(context);
  },
  drawHoverMatchingValues: function (context) {
    var heatmap = this.heatMap;
    context.fillStyle = morpheus.ScentedSearch.MATCHING_VALUES_TICK_COLOR;
    if (heatmap.mousePositionOptions
      && heatmap.mousePositionOptions.name != null) {
      var isColumns = !this.isVertical;
      var track = heatmap.getTrack(heatmap.mousePositionOptions.name,
        isColumns);
      if (track == null) {
        return;
      }
      if (track.settings.highlightMatchingValues) {
        var hoverIndex = isColumns ? heatmap.getProject()
          .getHoverColumnIndex() : heatmap.getProject()
          .getHoverRowIndex();
        if (hoverIndex === -1) {
          return;
        }
        var vector = track.getVector();
        var value = vector.getValue(hoverIndex);
        var valueToModelIndices = track.getFullVector().getProperties()
          .get(morpheus.VectorKeys.VALUE_TO_INDICES);
        if (!valueToModelIndices) {
          var fullVector = track.getFullVector();
          valueToModelIndices = morpheus.VectorUtil
            .createValueToIndicesMap(fullVector);
          fullVector.getProperties().set(
            morpheus.VectorKeys.VALUE_TO_INDICES,
            valueToModelIndices);

        }
        var modelIndices = valueToModelIndices.get(value);
        if (modelIndices == null) {
          console.log('valueToModelIndices error');
          return;
        }
        var scale = this.scale;
        var lineLength = !this.isVertical ? this.scrollbar
          .getUnscaledHeight() : this.scrollbar
          .getUnscaledWidth();
        var isVertical = this.isVertical;
        var positions = this.positions;
        var project = heatmap.getProject();
        for (var i = 0, length = modelIndices.length; i < length; i++) {
          var modelIndex = modelIndices[i];
          var index = isVertical ? project
            .convertModelRowIndexToView(modelIndex) : project
            .convertModelColumnIndexToView(modelIndex);
          if (index === -1) {
            continue;
          }
          var pix = positions.getPosition(index) * scale;
          if (isVertical) {
            context.fillRect(0, pix, lineLength,
              morpheus.ScentedSearch.LINE_HEIGHT);
          } else {
            context.fillRect(pix, 0,
              morpheus.ScentedSearch.LINE_HEIGHT, lineLength);

          }
        }
      }

    }
  },
  drawIndices: function (context, highlightedIndices) {
    var scale = this.scale;
    var lineLength = !this.isVertical ? this.scrollbar.getUnscaledHeight()
      : this.scrollbar.getUnscaledWidth();

    var isVertical = this.isVertical;
    var positions = this.positions;
    for (var i = 0, length = highlightedIndices.length; i < length; i++) {
      var index = highlightedIndices[i];
      var pix = positions.getPosition(index) * scale;
      if (isVertical) {
        context.beginPath();
        context.rect(0, pix, lineLength,
          morpheus.ScentedSearch.LINE_HEIGHT);
        context.fill();
        //  context.stroke();

      } else {
        context.beginPath();
        context.rect(pix, 0, morpheus.ScentedSearch.LINE_HEIGHT,
          lineLength);
        context.fill();
        //context.stroke();
      }
    }

  }
};
morpheus.Util.extend(morpheus.ScentedSearch, morpheus.AbstractCanvas);
morpheus.ScentedSearch.MATCHING_VALUES_TICK_COLOR = 'black';
morpheus.ScentedSearch.TICK_COLOR = '#3182bd';

morpheus.ScrollBar = function (isVertical) {
  morpheus.AbstractCanvas.call(this);
  this.isVertical = isVertical;
  $(this.canvas).css('border', '1px solid #d8d8d8');
  if (isVertical) {
    this.setBounds({
      width: 12
    });
  } else {
    this.setBounds({
      height: 12
    });
  }
  this.field = this.isVertical ? 'y' : 'x';
  var that = this;
  var mouseMove = function (event) {
    if (!morpheus.CanvasUtil.dragging) {
      var position = morpheus.CanvasUtil.getMousePos(event.target, event,
        true);
      var mouseOver = (position[that.field] >= that.thumbPos && position[that.field] <= (that.thumbPos + that.thumbExtent));
      if (that.thumbMouseOver !== mouseOver) {
        that.thumbMouseOver = mouseOver;
        that.repaint();
      }
    }
  };
  var mouseExit = function (e) {
    if (!morpheus.CanvasUtil.dragging && that.thumbMouseOver) {
      that.thumbMouseOver = false;
      that.repaint();
    }
  };
  $(this.canvas).on('mousemove', mouseMove).on('mouseout', mouseExit).on(
    'mouseenter', mouseMove);
  this.hammer = morpheus.Util
    .hammer(this.canvas, [this.isVertical ? 'panv' : 'panh', 'tap'])
    .on(
      'panstart',
      this.panstart = function (event) {
        var position = morpheus.CanvasUtil.getMousePos(
          event.target, event, true);
        if (position[that.field] >= that.thumbPos
          && position[that.field] <= (that.thumbPos + that.thumbExtent)) {
          that.draggingThumb = true;
          that.dragStartThumbPos = that.thumbPos;
        } else {
          that.draggingThumb = false;
        }
      })
    .on('panend', this.panend = function (event) {
      that.draggingThumb = false;
    })
    .on(
      'panmove',
      this.panmove = function (event) {
        if (that.draggingThumb) {
          var position = morpheus.CanvasUtil.getMousePos(
            event.target, event);
          var thumbPosPix = that.dragStartThumbPos
            + (that.isVertical ? event.deltaY
              : event.deltaX);
          var f = thumbPosPix
            / (that.visibleExtent - that.thumbExtent);
          var value = f * that.maxValue;
          // convert pix to value
          that.setValue(value, true);
          event.preventDefault();
          event.srcEvent.stopPropagation();
          event.srcEvent.stopImmediatePropagation();
        }
      })
    .on(
      'tap doubletap',
      this.tap = function (event) {
        // ensure not clicked on the thumb
        if (!that.draggingThumb) {
          var position = morpheus.CanvasUtil.getMousePos(
            event.target, event);
          if (!that.decorator.tap(position)) {
            // scroll up or down by thumbExtent
            var thumbExtentToValue = (that.thumbExtent / that.totalExtent)
              * that.totalExtent;
            that.scrollToTop = position[that.field] < that.thumbPos;
            that.setValue(that.scrollToTop ? that.value
            - thumbExtentToValue : that.value
            + thumbExtentToValue, true);
          }
        }
      });
};
morpheus.ScrollBar.prototype = {
  thumbPos: 0, // the top of the thumb, from 0 to visibleExtent-thumbExtent
  thumbExtent: 0,
  extent: 0,
  value: 0, // from 0 to totalExtent-extent
  maxValue: 0, // totalExtent-extent
  totalExtent: 0,
  visibleExtent: 0,
  dragStartThumbPos: 0,
  draggingThumb: false,
  thumbMouseOver: false,
  dispose: function () {
    morpheus.AbstractCanvas.prototype.dispose.call(this);
    this.hammer.off('panend', this.panend).off('panstart',
      this.panstart).off('panmove', this.panmove).off('tap', this.tap).off('doubletap', this.tap);
    this.hammer.destroy();
  },
  draw: function (clip, context) {
    var width = this.getUnscaledWidth();
    var height = this.getUnscaledHeight();
    if (this.visibleExtent === this.totalExtent) {
      context.clearRect(0, 0, width, height);
    } else {
      context.fillStyle = 'rgb(241,241,241)';
      context.fillRect(0, 0, width, height);
      context.fillStyle = !this.thumbMouseOver ? 'rgb(137,137,137)'
        : 'rgb(100,100,100)';
      if (this.isVertical) {
        context.fillRect(0, this.thumbPos, width, this.thumbExtent);
      } else {
        context.fillRect(this.thumbPos, 0, this.thumbExtent, height);
      }
    }
    this.decorator.draw(clip, context);
  },
  setThumbPosFromValue: function () {
    // value is thumb top position
    var f = this.maxValue == 0 ? 0 : this.value / this.maxValue;
    this.thumbPos = f * (this.visibleExtent - this.thumbExtent);
    this.thumbPos = Math.max(0, this.thumbPos);
  },
  getValue: function () {
    return this.value;
  },
  getMaxValue: function () {
    return this.maxValue;
  },
  setValue: function (value, trigger) {
    if (isNaN(value)) {
      value = 0;
    }
    if (this.visibleExtent === this.totalExtent) {
      value = 0;
    }
    value = Math.max(value, 0);
    value = Math.min(this.maxValue, value);
    this.value = value;
    this.setThumbPosFromValue();
    if (trigger) {
      this.trigger('scroll', {value: this.value});
      this.repaint();
    }
    return this.value;
  },
  setTotalExtent: function (totalExtent) {
    this.totalExtent = totalExtent;
    this._setRange();
  },
  getTotalExtent: function () {
    return this.totalExtent;
  },
  getVisibleExtent: function () {
    return this.visibleExtent;
  },
  _setRange: function () {
    this.thumbExtent = Math.max(10, this.visibleExtent
      * (this.visibleExtent / this.totalExtent));
    this.maxValue = this.totalExtent - this.visibleExtent;
    this.maxValue = Math.max(0, this.maxValue);
    if (this.isVertical) {
      this.setBounds({
        height: this.visibleExtent
      });
    } else {
      this.setBounds({
        width: this.visibleExtent
      });
    }
  },
  setExtent: function (visibleExtent, totalExtent, value) {
    this.visibleExtent = visibleExtent;
    this.totalExtent = totalExtent;
    this._setRange();
    this.setValue(value, false);
  }
};
morpheus.Util.extend(morpheus.ScrollBar, morpheus.AbstractCanvas);
morpheus.Util.extend(morpheus.ScrollBar, morpheus.Events);

morpheus.ShapeChooser = function (options) {
  var formBuilder = new morpheus.FormBuilder();
  var map = options.map;
  var html = ['<select name="valuePicker" class="selectpicker" data-live-search="true">'];
  map.forEach(function (val, key) {
    html.push('<option');
    html.push(' value="');
    html.push(key);
    html.push('">');
    html.push(key);
    html.push('</option>');
  });
  html.push('</select>');
  formBuilder.append({
    name: 'selected_value',
    type: 'custom',
    value: html.join('')
  });

  var shapeField = new morpheus.ShapeField();

  formBuilder.append({
    col: 'col-xs-2',
    name: 'selected_shape',
    type: 'custom',
    value: '<div data-name="shape"></div>'
  });
  shapeField.$el.appendTo(formBuilder.$form.find('[data-name=shape]'));

  var $valuePicker = formBuilder.$form.find('[name=valuePicker]');
  var selectedVal = $valuePicker.val();
  var _this = this;

  shapeField.setShapeValue(map.get(selectedVal));
  shapeField.on('change', function (e) {
    map.set(selectedVal, e.shape);
    _this.trigger('change', {
      value: selectedVal,
      shape: e.shape
    });

  });
  $valuePicker.selectpicker().change(function () {
    selectedVal = $valuePicker.val();
    shapeField.setShapeValue(map.get(selectedVal));
  });
  this.$div = formBuilder.$form;
};

morpheus.ShapeChooser.prototype = {};

morpheus.Util.extend(morpheus.ShapeChooser, morpheus.Events);

morpheus.ShapeField = function (shapes) {
  shapes = shapes || morpheus.VectorShapeModel.SHAPES;
  var _this = this;
  var html = [];
  var size2 = 8;
  var x = 4;
  var y = 4;
  html
    .push('<div style="margin-bottom:1em;" class="btn-group">');
  html
    .push('<button type="button" class="btn btn-default dropdown-toggle" data-toggle="dropdown" aria-expanded="false"><span data-name="selection"></span> <span class="fa fa-caret-down"></span></button>');
  html.push('<ul class="dropdown-menu" role="menu">');
  for (var i = 0; i < shapes.length; i++) {
    var context = new C2S(size2 * 2, size2 * 2);
    context.translate(4, 4);
    morpheus.CanvasUtil.drawShape(context, shapes[i], x, y, size2);
    var svg = context.getSerializedSvg();
    html.push('<li><a data-name="' + shapes[i] + '" href="#">' + svg
      + '</a></li>');
  }
  html.push('<li><a data-name="none" href="#">(None)</a></li>');
  html.push('</ul></div>');
  var $el = $(html.join(''));
  var $header = $el.find('[data-name=selection]');
  $el.on('click', 'li > a', function (e) {
    var shape = $(this).data('name');
    setShapeValue(shape);
    _this.trigger('change', {
      shape: shape
    });
  });
  var setShapeValue = function (val) {
    if (val === 'none') {
      $header.html('(None)');
    } else {
      var context = new C2S(size2 * 2, size2 * 2);
      context.translate(4, 4);
      morpheus.CanvasUtil.drawShape(context, val, x, y, size2);
      $header.html(context.getSerializedSvg());
    }
  };
  this.setShapeValue = setShapeValue;
  this.$el = $el;
};
morpheus.ShapeField.prototype = {};
morpheus.Util.extend(morpheus.ShapeField, morpheus.Events);

morpheus.SortByValuesIndicator = function (project, isVertical, positions) {
  morpheus.AbstractCanvas.call(this, true);
  this.project = project;
  this.isVertical = isVertical;
  this.positions = positions;
  this.lastPosition = {
    start: -1,
    end: -1
  };
};
morpheus.SortByValuesIndicator.prototype = {
  prePaint: function (clip, context) {
    var positions = this.positions;
    var start = 0;
    var end = positions.getLength();
    if (!this.isVertical) {
      start = morpheus.Positions.getLeft(clip, positions);
      end = morpheus.Positions.getRight(clip, positions);
    } else {
      start = morpheus.Positions.getTop(clip, positions);
      end = morpheus.Positions.getBottom(clip, positions);
    }
    if (this.invalid || start !== this.lastPosition.start
      || end !== this.lastPosition.end) {
      this.lastPosition.start = start;
      this.lastPosition.end = end;
      this.invalid = true;
    }
  },
  draw: function (clip, context) {
    var project = this.project;
    var isVertical = this.isVertical;
    var positions = this.positions;
    var sortKeys = isVertical ? project.getColumnSortKeys() : project
      .getRowSortKeys();
    context.translate(-clip.x, -clip.y);
    context.fillStyle = 'black';
    context.textBaseline = 'top';
    context.textAlign = 'left';
    context.font = '8px ' + morpheus.CanvasUtil.FONT_NAME;
    var start = 0;
    var end = positions.getLength();
    if (!isVertical) {
      start = morpheus.Positions.getLeft(clip, positions);
      end = morpheus.Positions.getRight(clip, positions);
    } else {
      start = morpheus.Positions.getTop(clip, positions);
      end = morpheus.Positions.getBottom(clip, positions);
    }
    var arrowWidth = 3;
    var arrowHeight = 4;
    for (var i = 0; i < sortKeys.length; i++) {
      var key = sortKeys[i];
      if (key instanceof morpheus.SortByValuesKey) { // are we sorting
        // columns by the
        // values in a row?

        var modelIndices = key.modelIndices;
        for (var j = 0; j < modelIndices.length; j++) {
          var modelIndex = modelIndices[j];
          var view = isVertical ? project
            .convertModelRowIndexToView(modelIndex) : project
            .convertModelColumnIndexToView(modelIndex);
          if (view !== -1 && view >= start && view < end) {
            context.save();
            var pix = positions.getPosition(view);
            var size = positions.getItemSize(view);
            if (!isVertical) {
              context.translate(pix + size / 2, 0);
            } else {
              context.translate(2, pix + size / 2);
            }
            context.beginPath();
            // if (!isVertical) {
            if (key.getSortOrder() === morpheus.SortKey.SortOrder.ASCENDING) {
              // up arrow
              context.moveTo(0, 0);
              context.lineTo(arrowWidth, arrowHeight);
              context.lineTo(-arrowWidth, arrowHeight);
            } else if (key.getSortOrder() === morpheus.SortKey.SortOrder.DESCENDING) { // down
              // arrow
              context.moveTo(0, arrowHeight);
              context.lineTo(arrowWidth, 0);
              context.lineTo(-arrowWidth, 0);
            } else { // diamond
              context.moveTo(0, 0);
              context.lineTo(arrowWidth, arrowHeight / 2);
              context.lineTo(0, arrowHeight);
              context.lineTo(-arrowWidth, arrowHeight / 2);

            }
            // } else {
            // if (!ascending) { // left arrow
            // context.moveTo(0, 0);
            // context.lineTo(arrowWidth, arrowHeight);
            // context.lineTo(arrowWidth, -arrowHeight);
            // } else {
            // context.moveTo(arrowWidth, 0); // right arrow
            // context.lineTo(0, arrowHeight);
            // context.lineTo(0, -arrowHeight);
            // }
            // }
            context.fill();

            // don't indicate sort priority b/c of limited space
//						if (sortKeys.length > 1) {
//							context.fillText('' + (i + 1), 0, 0);
//						}
            context.restore();
          }
        }
      }
    }
  }
};
morpheus.Util.extend(morpheus.SortByValuesIndicator, morpheus.AbstractCanvas);

morpheus.SortDialog = function (project) {
  var _this = this;
  // choose rows or columns
  var $chooserDiv = $('<div class="container-fluid"></div>');
  var $div = $('<div class="container-fluid"></div>');
  var html = [];
  html
    .push('<div style="border-bottom:1px solid LightGrey;margin-bottom:20px;" class="row">');
  html.push('<form class="form-horizontal" role="form">');
  html
    .push('<div class="col-xs-2"><label class="control-label">Sort</label></div>');
  html.push('<div class="col-xs-5">');
  html
    .push('<div class="radio"><label><input type="radio" name="rowsOrColumns" value="rows" checked>Rows</label></div>');
  html
    .push('<div class="radio"><label><input type="radio" name="rowsOrColumns" value="columns">Columns</label></div>');
  html.push('</div>');
  html.push('</form>');
  html.push('</div>');
  $chooserDiv.html(html.join(''));
  function toggle(isColumns) {
    _this.isColumns = isColumns;
    var $element = _this.build(project, isColumns);
    $div.empty().html($element);
    $div.on('click', '[data-name=delete]', function (e) {
      var $this = $(this);
      e.preventDefault();
      $this.closest('div.row').remove();
    });
    $div.on('click', '[data-name=add]', function (e) {
      var $this = $(this);
      var level = [];
      var $sibling = $this.closest('div.row');
      _this.createLevel(level, new morpheus.SortKey('',
        morpheus.SortKey.SortOrder.ASCENDING), _this.fields);
      $sibling.after($(level.join('')));
      e.preventDefault();
    });
  }

  $chooserDiv.on('change', '[name=rowsOrColumns]', function (e) {
    var $this = $(this);
    toggle($this.val() === 'columns');
  });
  toggle(false);
  var $outer = $('<div></div>');
  $chooserDiv.appendTo($outer);
  $div.appendTo($outer);
  morpheus.FormBuilder
    .showOkCancel({
      title: 'Sort',
      content: $outer,
      okCallback: function () {
        var $forms = $div.find('form');
        var sortBy = $forms.find('[name=sortBy]').map(function () {
          return $(this).val();
        });
        var sortOrder = $forms.find('[name=sortOrder]:checked')
          .map(function () {
            return $(this).val();
          });
        var groupBy = $div.find('[name=groupBy]').val();
        var newSortKeys = [];
        var modelIndices = _this.isColumns ? project
          .getRowSelectionModel().toModelIndices() : project
          .getColumnSelectionModel().toModelIndices();
        var existingSortKeys = _this.isColumns ? project
          .getColumnSortKeys() : project.getRowSortKeys();
        // keep MatchesOnTopSortKey and dendrogram
        var keysToKeep = _
          .filter(
            existingSortKeys,
            function (key) {
              return key instanceof morpheus.MatchesOnTopSortKey
                || (key instanceof morpheus.SpecifiedModelSortOrder && key.name === 'dendrogram');
            });
        if (keysToKeep.length > 0) {
          _.each(keysToKeep, function (key) {
            newSortKeys.push(key);
          });
        }
        var newSortKeyFields = new morpheus.Set();
        for (var i = 0; i < sortBy.length; i++) {
          if (!newSortKeyFields.has(sortBy[i])) {
            newSortKeyFields.add(sortBy[i]);
            if (sortBy[i] === 'selection') {
              newSortKeys.push(new morpheus.SortByValuesKey(
                modelIndices, sortOrder[i],
                _this.isColumns));
            } else if (sortBy[i] !== '') {
              newSortKeys.push(new morpheus.SortKey(
                sortBy[i], sortOrder[i]));
            }
          }
        }
        var newGroupKeys = [];
        if (groupBy != null) {
          for (var i = 0; i < groupBy.length; i++) {
            newGroupKeys.push(new morpheus.SortKey(groupBy[i],
              morpheus.SortKey.SortOrder.UNSORTED));
          }
        }

        if (_this.isColumns) {
          project.setGroupColumns(newGroupKeys, true);
          project.setColumnSortKeys(morpheus.SortKey
            .keepExistingSortKeys(newSortKeys, project
              .getColumnSortKeys()), true);
        } else {
          project.setGroupRows(newGroupKeys, true);
          project.setRowSortKeys(morpheus.SortKey
            .keepExistingSortKeys(newSortKeys, project
              .getRowSortKeys()), true);
        }
      }
    });
};
morpheus.SortDialog.prototype = {
  isColumns: false,
  build: function (project, isColumns) {
    var fields = morpheus.MetadataUtil.getMetadataNames(isColumns ? project
      .getFullDataset().getColumnMetadata() : project
      .getFullDataset().getRowMetadata());
    this.fields = fields;
    var html = [];
    var sortKeys = isColumns ? project.getColumnSortKeys() : project
      .getRowSortKeys();
    this.createLevel0(html);
    for (var i = 0; i < sortKeys.length; i++) { // add existing keys
      // ignoring
      // MatchesOnTopSortKey and
      // dendrogram
      if (!(sortKeys[i] instanceof morpheus.MatchesOnTopSortKey)
        && !(sortKeys[i] instanceof morpheus.SpecifiedModelSortOrder && sortKeys[i].name === 'dendrogram')) {
        this.createLevel(html, sortKeys[i], fields);
      }
    }
    // group by
    html.push('<div class="row">');
    html
      .push('<form class="form-horizontal" role="form">');
    html.push('<div class="col-xs-2"><label>Group by</label></div>');
    html.push('<div class="col-xs-4">');
    var groupByKeys = (isColumns ? project.getGroupColumns() : project
      .getGroupRows()).map(function (key) {
      return key.field;
    });

    html.push('<select multiple name="groupBy" class="selectpicker form-control">');
    _.each(fields, function (field) {
      html.push('<option value="' + field + '"');
      if (_.indexOf(groupByKeys, field) !== -1) {
        html.push(' selected');
      }
      html.push('>');
      html.push(field);
      html.push('</option>');
    });
    html.push('</select>');
    html.push('</div>');
    html.push('</div>');
    var $div = $(html.join(''));
    $div.find('.selectpicker').selectpicker({
      iconBase: 'fa',
      tickIcon: 'fa-check',
      style: 'btn-default btn-sm'
    });
    return $div;
  },
  createLevel0: function (html) {
    html
      .push('<div style="border-bottom:1px solid LightGrey;margin-bottom:20px;" class="row">');
    html.push('<form class="form-horizontal" role="form">');
    html.push('<div class="col-xs-8">');
    html.push('<a data-name="add" href="#">Add sort level</a>');
    html.push('</div>');
    html.push('</form>');
    html.push('</div>');
  },
  createLevel: function (html, key, fields) {
    html
      .push('<div style="border-bottom:1px solid LightGrey;margin-bottom:20px;" class="row">');
    html.push('<form class="form-horizontal" role="form">');
    html
      .push('<div class="col-xs-2"><label class="control-label">Sort by</label></div>');
    html.push('<div class="col-xs-4">');
    html.push('<select name="sortBy" class="form-control">');
    html.push('<option value=""></option>');
    html.push('<option value="selection"'
      + (key instanceof morpheus.SortByValuesKey ? ' selected' : '')
      + '>selection</option>');
    _.each(fields, function (field) {
      html.push('<option value="' + field + '"');
      if (field == key.field) {
        html.push(' selected');
      }
      html.push('>');
      html.push(field);
      html.push('</option>');
    });
    html.push('</select>');
    html.push('</div>');
    html.push('<div class="col-xs-5">');
    html
      .push('<div class="radio"><label><input type="radio" name="sortOrder" value="ascending"'
        + (morpheus.SortKey.SortOrder.ASCENDING == key
          .getSortOrder() ? ' checked' : '')
        + '>Ascending</label></div>');
    html
      .push('<div class="radio"><label><input type="radio" name="sortOrder" value="descending"'
        + (morpheus.SortKey.SortOrder.DESCENDING == key
          .getSortOrder() ? ' checked' : '')
        + '>Descending</label></div>');
    html.push('</div>');
    html.push('<div class="col-xs-1">');
    html.push('<a data-name="delete" class="pull-right">Delete</a>');
    html.push('</div>');
    html.push('<div class="col-xs-8">');
    html.push('<a data-name="add" href="#">Add sort level</a>');
    html.push('</div>');
    html.push('</form>');
    html.push('</div>');
  }
};

morpheus.Spacer = function (width, height) {
  this.width = width;
  this.height = height;
};
morpheus.Spacer.prototype = {
  prefWidth: undefined,
  prefHeight: undefined,
  visible: true,
  dispose: function () {
  },
  getPrefWidth: function () {
    return this.prefWidth;
  },
  draw: function (clip) {
  },
  getPreferredSize: function () {
    return {
      width: this.width,
      height: this.height
    };
  },
  setBounds: function () {
  },
  getPrefHeight: function () {
    return this.prefHeight;
  },
  setPrefWidth: function (prefWidth) {
    this.prefWidth = prefWidth;
  },
  setPrefHeight: function (prefHeight) {
    this.prefHeight = prefHeight;
  },
  isVisible: function () {
    return this.visible;
  },
  setVisible: function (visible) {
    this.visible = visible;
  },
  getWidth: function () {
    return this.width;
  },
  getHeight: function () {
    return this.height;
  }
};

morpheus.SteppedColorSupplier = function () {
  morpheus.AbstractColorSupplier.call(this);
  this.hiddenValue = 0;
  this.hiddenValues = new morpheus.Set();
  this.stepped = true;
};
/**
 * Convert value from input data range of input0 to input1 to pixel range of
 * pix0, pix1.
 *
 * @return The converted value.
 */
morpheus.SteppedColorSupplier.linearScale = function (value, input0, input1,
                                                      pix0, pix1) {
  return (value - input0) / (input1 - input0) * (pix1 - pix0) + pix0;
};
morpheus.SteppedColorSupplier.prototype = {
  createInstance: function () {
    return new morpheus.SteppedColorSupplier();
  },
  isStepped: function () {
    return true;
  },
  getHiddenValues: function () {
    return this.hiddenValues;
  },
  getIndexForFraction: function (f) {
    var fractions = this.fractions;
    if (f <= fractions[0]) {
      return 0;
    }
    if (f >= fractions[fractions.length - 1]) {
      return fractions.length - 1;
    }
    // Intervals exclude right end point and include left end point except
    // for the highest interval which includes everything > min
    for (var i = 0; i < fractions.length - 1; i++) {
      var left = fractions[i];
      var right = fractions[i + 1];
      if (f >= left && f < right) {
        return i;
      }
    }
    return fractions.length - 1;
  },
  getColor: function (row, column, value) {
    if (this.hiddenValues.has(value)) {
      value = this.hiddenValue;
    }
    if (isNaN(value)) {
      return this.missingColor;
    }
    var min = this.min;
    var max = this.max;
    var colors = this.colors;
    if (value <= min) {
      return colors[0];
    } else if (value >= max) {
      return colors[colors.length - 1];
    }
    var fraction = morpheus.SteppedColorSupplier.linearScale(value, min,
        max, 0, 100) / 100;
    return colors[this.getIndexForFraction(fraction)];
  }
};
morpheus.Util.extend(morpheus.SteppedColorSupplier,
  morpheus.AbstractColorSupplier);

/**
 * @param options.autohideTabBar
 *            Whether to autohide the tab bar when only 1 tab showing
 * @param options.landingPage Landing page to show when all tabs are closed
 */
morpheus.TabManager = function (options) {
  this.options = $.extend({}, {
    autohideTabBar: false,
    rename: true
  }, options);
  var _this = this;
  this.activeTabObject = null;
  this.activeTabId = null;
  this.idToTabObject = new morpheus.Map();
  this.$nav = $('<ul class="nav nav-tabs compact morpheus-nav"></ul>');
  this.$nav.sortable({
    containment: 'parent',
    axis: 'x',
    helper: 'clone',
    cancel: 'li:not(.morpheus-sortable)',
    items: 'li.morpheus-sortable'
  });
  this.$nav.sortable('disable');
  this.$nav.on('click', 'li > a', function (e) {
    var tabId = $(this).data('link');
    if (tabId != null) {
      e.preventDefault();
      if (_this.activeTabId !== tabId) {
        $(this).tab('show');
      }
    }
  });
  if (this.options.autohideTabBar) {
    this.$nav.css('display', 'none');
  }
  if (options.dropTab) {
    var html = [];
    html.push('<li class="morpheus-tab-addon dropdown pull-right tabdrop">');
    html.push('<div class="btn-group">');
    html.push('<button type="button" class="morpheus-drop-tab-toggle btn btn-link' +
      ' dropdown-toggle"' +
      ' data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">');
    html.push(' <span class="fa fa-angle-double-down"></span>');
    html.push('</button>');
    html
      .push('<ul class="dropdown-menu dropdown-menu-right" role="menu">');
    html.push('</ul>');
    html.push('</div>');
    html.push('</li>');
    var $tabDrop = $(html.join(''));
    // $tabDrop.css('display', 'none');
    var $tabDropMenu = $tabDrop.find('.dropdown-menu');
    $tabDrop.appendTo(this.$nav);
    var updateDropTab = function () {
      var totalWith = _this.$nav.width() - 17; // 17=width of dropdown
      var sum = 0;
      var tabDropItems = [];
      _this.$nav.find('> li').each(function () {
        var $li = $(this);
        var $a = $li.find('a');
        if (!$li.hasClass('morpheus-tab-addon')) {
          var title = $a.contents().first().text();
          var isActive = $li.hasClass('active');
          var href = $a.attr('href');
          tabDropItems.push('<li class="' + (isActive ? 'active' : '') + '"><a data-link="' + href.substring(1) + '" data-toggle="tab"' +
            ' href="' + href + '">' + title + '</a></li>');
          sum += $li.outerWidth();
          if (sum >= totalWith) {
            $li.css('display', 'none');
          } else {
            $li.css('display', '');
          }
        }
      });
      $tabDrop.css('display', tabDropItems.length > 0 ? '' : 'none');
      $tabDropMenu.html(tabDropItems.join(''));
    };
    $tabDrop.css('display', 'none');
    this.$nav.on('sortstop', function (event, ui) {
      updateDropTab();
    });
    $(window).on('resize', updateDropTab);
    this.$nav.on('remove', function () {
      $(window).off('resize', updateDropTab);
    });
    this.on('add remove rename reorder change', function () {
      updateDropTab();

    });
  }

  this.$nav.on('dblclick', 'li > a', function (e) {
    e.preventDefault();
    var $a = $(this);
    var $li = $a.parent('li');
    if ($li.hasClass('morpheus-tab-addon')) {
      return;
    }
    _this.rename($a.data('link'));

  });
  this.$nav.on('contextmenu.morpheus', 'li > a', function (e) {
    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();
    var $a = $(this);
    var $li = $a.parent('li');
    if ($li.hasClass('morpheus-tab-addon')) {
      return;
    }
    var menuItems = [];
    if ($a.data('morpheus-rename') && _this.options.rename) {
      menuItems.push({name: 'Rename'});
    }
    if ($a.data('morpheus-pin')) { // pinned
      menuItems.push({name: 'Unpin tab'});
    } else {
      menuItems.push({name: 'Pin tab'});
    }

    if (menuItems.length > 0) {
      morpheus.Popup.showPopup(menuItems, {
        x: e.pageX,
        y: e.pageY
      }, e.target, function (event, item) {
        if (item === 'Rename') {
          _this.rename($a.data('link'));
        } else if (item === 'Pin tab') {
          $a.data('morpheus-pin', true);
          $li.removeClass('morpheus-sortable');
          $li.detach();
          _this.$nav.prepend($li);
          $a.find('.close').hide();    // hide close button
          _this.$nav.sortable('option', 'items', 'li.morpheus-sortable');
          _this.$nav.sortable('refresh');
        } else if (item === 'Unpin tab') {
          $a.data('morpheus-pin', false);
          $li.addClass('morpheus-sortable');
          $a.find('.close').show(); // show close button
          _this.$nav.sortable('option', 'items', 'li.morpheus-sortable');
          _this.$nav.sortable('refresh');

        }
      });
    }
    return false;

  });

  this.$nav.on('click', 'button', function (e) { // close a tab
    // remove the link and tab content
    e.preventDefault();
    var target = $(this).attr('data-target');

    if (target != null) {
      target = target.substring(1); // remove #
      _this.remove(target);
    }
  });

  this.$tabContent = $('<div class="tab-content"></div>');
  this.$nav.on('shown.bs.tab', 'a[data-toggle="tab"]', function (e) {
    // triggered when clicking tab
    var previous = _this.activeTabId;
    _this.activeTabId = $(e.target).data('link');
    _this.activeTabObject = _this.idToTabObject.get(_this.activeTabId);
    _this.$nav.find('li').removeClass('active');
    _this.$nav.find('[data-link=' + _this.activeTabId + ']').each(function () {
      $(this).parent().addClass('active');// not added via droptab
    });
    $('#' + _this.activeTabId).focus();
    if (_this.adding) {
      return;
    }

    _this.trigger('change', {
      tab: _this.activeTabId,
      previous: previous
    });
  });

};
morpheus.TabManager.prototype = {
  getTabText: function (id) {
    return this.$nav.find('> li > a').filter('a[data-link=' + id + ']').contents().first().text();
  },
  getTabCount: function () {
    return this.idToTabObject.size();
  },
  setTabText: function (id, text) {
    this.$nav.find('> li > a').filter('[data-link=' + id + ']').contents().first()
      .replaceWith(text + '&nbsp;');
    this.idToTabObject.get(id).setName(name);
  },
  /**
   * @param id
   *            Tab id
   * @param task
   * @param task.worker
   *            Optional worker that the task is run in.
   * @param task.name
   * @param task.tabId
   *            Tab id for task
   */
  addTask: function (task) {

  },
  removeTask: function (task) {

  },
  getWidth: function () {
    return this.$tabContent.outerWidth() || $(window).width();
  },
  getActiveTab: function () {
    return this.activeTabObject;
  },
  getActiveTabId: function () {
    return this.activeTabId;
  },

  /**
   *
   * @param options.object The object that stores the tab content state and has a setName if
   * function if rename is true.
   * @param options.$el
   *            the tab element
   * @param options.title
   *            the tab title
   * @param options.closeable
   *            Whether tab can be closed
   * @param options.rename
   *            Whether tab can be renamed
   * @param options.focus
   *            Whether new tab should be focused-note the change event is not
   *            triggered when true
   * @param options.enabled
   *            Whether new tab is enabled
   *
   */
  add: function (options) {
    this.adding = true;
    var id = _.uniqueId('morpheus-tab');
    this.idToTabObject.set(id, options.object);
    var li = [];
    li.push('<li class="morpheus-sortable" role="presentation">');
    li.push('<a data-morpheus-rename="' + options.rename
      + '" data-toggle="tab" data-link="' + id + '" href="#' + id + '">');
    li.push(options.title);
    li.push('&nbsp;<i style="color:black;"></i>');
    if (options.closeable) {
      li
        .push('&nbsp<button style="font-size: 18px;" type="button" class="close"' +
          ' aria-label="Close"' +
          ' data-target="#'
          + id
          + '"><span aria-hidden="true">×</span></button>');

    }
    li.push('</a></li>');
    var $link = $(li.join(''));
    $link.appendTo(this.$nav);
    var $panel = $('<div tabIndex="0" style="outline:0;cursor:default;" role="tabpanel"' +
      ' class="tab-pane" id="'
      + id + '"></div>');
    options.$el.appendTo($panel);
    $panel.appendTo(this.$tabContent);
    if (options.enabled === false) {
      $link.addClass('disabled');
      $link.find('a').addClass('btn disabled');
    }
    if (options.focus) {
      // update active tab, but don't fire event
      this.$nav.find('> li > a[data-toggle="tab"]:last').tab('show');
      this.activeTabId = id;
      this.activeTabObject = options.object;
      $panel.focus();
    }

    if (this.options.autohideTabBar) {
      this.$nav.css('display', this.idToTabObject.size() > 1 ? ''
        : 'none');
    }
    this.getTabCount() <= 1 ? this.$nav.sortable('disable') : this.$nav.sortable('enable');
    this.adding = false;
    this.trigger('add');
    return {
      $panel: $panel,
      id: id
    };
  },
  appendTo: function ($target) {
    this.$nav.appendTo($target);
    this.$tabContent.appendTo($target);
  },
  remove: function (target) {
    if (target === undefined) {
      target = this.activeTabId;
    }
    var obj = this.idToTabObject.remove(target);
    $('#' + target).remove(); // remove tab-pane
    this.activeTabObject = null;
    this._getA(target).parent().remove();
    this.$tabContent.find(target).remove();
    var $a = this.$nav.find('> li > a[data-toggle="tab"]:last');
    if ($a.length === 0) {
      // no content
      if (this.options.landingPage) {
        this.options.landingPage.show();
      }
    }

    $a.tab('show');
    if (this.options.autohideTabBar) {
      this.$nav.css('display', this.idToTabObject.size() > 1 ? ''
        : 'none');
    }
    this.getTabCount() <= 1 ? this.$nav.sortable('disable') : this.$nav.sortable('enable');
    if (this.idToTabObject.size() > 0) {
      $($a.attr('href')).focus();
    }
    if (obj != null && obj.onRemove) {
      obj.onRemove();
    }
    this.trigger('remove', {
      tab: target
    });
  },
  setOptions: function (options) {
    this.options = options;
    if (this.options.autohideTabBar) {
      this.$nav.css('display', this.idToTabObject.size() > 1 ? ''
        : 'none');
    }
  },
  getOptions: function () {
    return this.options;
  },
  setActiveTab: function (id) {
    if (id !== this.activeTabId) {
      var $a = this._getA(id);
      // make sure it's enabled
      $a.parent().removeClass('disabled');
      $a.removeClass('btn disabled');
      $a.tab('show');
      var previous = this.activeTabId;
      this.activeTabId = id;
      this.activeTabObject = this.idToTabObject.get(this.activeTabId);
      this.trigger('change', {
        tab: this.activeTabId,
        previous: previous
      });
    }

  },
  /**
   *
   * @param id
   *            The tab id
   * @param title
   *            The title (used to show tooltip)
   */
  setTabTitle: function (id, title) {
    this._getA(id).attr('title', title);
  },
  _getA: function (id) {
    if (id[0] === '#') {
      id = id.substring(1);
    }
    return this.$nav.find('> li > a[data-link=' + id + ']:first');
  },
  setTabEnabled: function (id, enabled) {
    var $a = this._getA(id);
    if (enabled) {
      $a.parent().removeClass('disabled');
      $a.removeClass('btn disabled');
    } else {
      $a.parent().addClass('disabled');
      $a.addClass('btn disabled');
    }

  },
  getIdToTabObject: function () {
    return this.idToTabObject;
  },
  getTabObject: function (id) {
    return this.idToTabObject.get(id);
  },
  rename: function (id) {
    var $a = this._getA(id);
    var $li = $a.parent();
    if ($li.hasClass('morpheus-tab-addon')) {
      return;
    }
    if (!$a.data('morpheus-rename') || !this.options.rename) {
      return;
    }
    var _this = this;
    var builder = new morpheus.FormBuilder();
    builder.append({
      name: 'name',
      type: 'text',
      value: $.trim($a.contents().first().text())
    });
    morpheus.FormBuilder.showOkCancel({
      title: 'Rename Tab',
      content: builder.$form,
      okCallback: function () {
        var name = $.trim(builder.getValue('name'));
        if (name !== '') {
          if (_this.activeTabObject != null && _this.activeTabObject.setName) {
            _this.activeTabObject.setName(name);
          }
          $a.contents().first().replaceWith(name + '&nbsp;');
          _this.trigger('rename');
        }
      }
    });
    // edit tab name
  }
};
morpheus.Util.extend(morpheus.TabManager, morpheus.Events);

/**
 * @param options.$el The jQuery element to render to. Must be in the DOM.
 * @param options.items An array of items to display in the table
 * @param options.search Whether to create a search widget
 * @param options.rowHeader Renderer to call for each row in the table
 * @param options.rowHeight Table row height
 * @param height: Height in pixels of table. '564px',
 * @param options.collapseBreakpoint: 500
 * @param options.showHeader: true
 * @param options.select: true
 * @param options.responsive: true
 * @param options.fixedWidth: Fixed table with when responsive is false. '320px'
 * @param options.columns An array of column descriptors. Each column can have the properties:
 * visible, name, field, renderer
 */



morpheus.Table = function (options) {
  options = morpheus.Table.createOptions(options);
  this.options = options;
  if (!options.width) {
    options.width = options.$el.attr('class');
  }
  var _this = this;

  var height = options.height;
  var $gridDiv = $('<div class="slick-table'
    + (options.tableClass ? (' ' + options.tableClass) : '')
    + '" style="width:' + options.fixedWidth + ';height:' + height
    + '"></div>');

  this.$gridDiv = $gridDiv;
  $gridDiv.appendTo(options.$el);
  // all columns (including those that are currently not visible */
  var columns = options.columns;
  this.columns = columns;
  var visibleColumns = columns.filter(function (c) {
    return c.visible;
  });
  var grid = new morpheus.Grid({
    gridOptions: {
      select: options.select,
      rowHeight: options.rowHeight,
      autoEdit: false,
      editable: false,
      autoHeight: options.height === 'auto',
      enableTextSelectionOnCells: true,
    },
    $el: $gridDiv,
    items: options.items,
    columns: visibleColumns
  });
  this.grid = grid;
  this.searchFunction = null;
  var searchFilter = {
    isEmpty: function () {
      return _this.searchFunction == null;
    },
    init: function () {
    },
    accept: function (item) {
      return _this.searchFunction(item);
    }
  };
  // add empty search filter
  this.grid
    .getFilter().add(searchFilter);
  var $header = $('<div class="slick-table-header"><div name="top"></div><div style="display: inline-block;" name="left" class="pad-bottom-8 pad-top-8"></div><div name="right" class="pull-right pad-bottom-8' +
    ' pad-top-8"></div></div>');
  this.$header = $header;
  var $right = $header.find('.pull-right');
  if (options.search) {
    var tableSearch = new morpheus.TableSearchUI({
      $el: $header.find('[name=top]'),
      $right: $right
    });
    tableSearch.setTable(this);
    this.tableSearch = tableSearch;
  }
  if (options.columnPicker && visibleColumns.length !== this.columns.length) {
    var select = [];
    select
      .push('<select data-width="90px" data-selected-text-format="static" title="Columns..." multiple class="pad-left-4 selectpicker show-tick">');
    // sort column names
    var sortedColumns = this.columns.slice().sort(function (a, b) {
      a = a.name.toLowerCase();
      b = b.name.toLowerCase();
      return (a === b ? 0 : (a < b ? -1 : 1));
    });
    sortedColumns.forEach(function (c, i) {
      select.push('<option value="' + i + '"');
      if (c.visible) {
        select.push(' selected');
      }
      select.push('>');
      select.push(c.name);
      select.push('</option>');
    });
    select.push('</select>');
    var $select = $(select.join(''));
    $select.appendTo($right);
    $select.selectpicker({
      iconBase: 'fa',
      tickIcon: 'fa-check',
      style: 'btn-default btn-xs'
    });
    $select.on('change', function () {
      var oldColumns = grid.getColumns().map(function (c) {
        return c.id;
      });
      var selectedColumnIndices = $select.val();
      visibleColumns = [];
      for (var i = 0; i < selectedColumnIndices.length; i++) {
        visibleColumns.push(sortedColumns[parseInt(selectedColumnIndices[i])]);
      }
      var newColumns = visibleColumns.map(function (c) {
        return c.id;
      });

      grid.setColumns(visibleColumns);

      if (newColumns.length > oldColumns.length) {
        var set = new morpheus.Set();
        for (var i = 0; i < newColumns.length; i++) {
          set.add(newColumns[i]);
        }
        for (var i = 0; i < oldColumns.length; i++) {
          set.remove(oldColumns[i]);
        }
        var added = set.values();

        grid.setSortColumns([{
          columnId: added[0],
          sortAsc: true
        }]);
      }
      // if column added, sort by added column
      _this.resize();
      _this.redraw();

    });
  }
  $header.prependTo(options.$el);
  var collapsed = false;
  var lastWidth = -1;
  var resize = function () {
    if (!_this.options.responsive) {
      return;
    }

    var gridWidth = options.$el.width();
    if (gridWidth === lastWidth) {
      return;
    }
    lastWidth = gridWidth;

    $gridDiv.css('width', gridWidth + 'px');
    // if (options.responsiveHeight) {
    // var verticalPosition = _this.$gridDiv[0].getBoundingClientRect().top
    // + window.pageYOffset;
    // $gridDiv.css('height',
    // (document.body.clientHeight - verticalPosition) + 'px');
    // }
    if (!collapsed && gridWidth < options.collapseBreakpoint
      && visibleColumns.length > 1) {
      collapsed = true;
      $gridDiv.addClass('slick-stacked');

      _this.grid.grid.getOptions().rowHeight = (options.collapsedRowHeight ? options.collapsedRowHeight : options.rowHeight)
        * visibleColumns.length;
      // collapse
      _this.grid.grid
        .setColumns([{
          id: 0,
          tooltip: function (item, value) {
            var html = [];
            for (var i = 0; i < visibleColumns.length; i++) {
              var text = visibleColumns[i].tooltip(item, visibleColumns[i]
                .getter(item));
              if (text != null && text !== '') {
                html.push(text);
              }
            }
            return html.join('<br />');
          },
          collapsed: true,
          getter: function (item) {
            return item;
          },
          formatter: function (row, cell, value, columnDef,
                               dataContext) {
            var html = [];
            html
              .push('<div class="slick-table-wrapper"><div class="slick-cell-wrapper">');
            if (options.rowHeader) { // e.g. render checkbox
              html.push(options.rowHeader(dataContext));
              html.push('<div style="height:4px;"></div>');
            }
            for (var i = 0; i < visibleColumns.length; i++) {
              if (i > 0) {
                html.push('<div style="height:4px;"></div>');
              }
              var c = visibleColumns[i];
              html.push(c.name);
              html.push(':');
              var s = c.renderer(dataContext, c
                .getter(dataContext));
              html.push(s);

            }
            html.push('</div></div>');
            return html.join('');
          },
          sortable: false,
          name: ''
        }]);
      $gridDiv.find('.slick-header').hide();
      _this.grid.grid.resizeCanvas();
      _this.grid.grid.invalidate();

    } else if (collapsed && gridWidth >= options.collapseBreakpoint) {
      $gridDiv.removeClass('slick-stacked');
      collapsed = false;
      if (options.showHeader) {
        $gridDiv.find('.slick-header').show();
      }
      _this.grid.grid.getOptions().rowHeight = options.rowHeight;
      _this.grid.grid.setColumns(visibleColumns);
      _this.grid.grid.resizeCanvas();
      if (options.select) {
        _this.grid.grid.setSelectedRows(_this.grid.grid
          .getSelectedRows());
      }
      _this.grid.grid.invalidate();
    } else {
      _this.grid.grid.resizeCanvas();
      _this.grid.grid.invalidate();
    }
    _this.grid.maybeAutoResizeColumns();

  };
  if (!options.showHeader) {
    $gridDiv.find('.slick-header').hide();
  }
  if (options.responsive) {
    $(window).on('resize orientationchange', resize);
    $gridDiv.on('remove', function () {
      $(window).off('resize', resize);
    });
    resize();
  }
  this.resize = resize;
  if (visibleColumns.length > 1 && options.items != null
    && options.items.length > 0) {
    this.setItems(options.items);
  }
  if (!$gridDiv.is(':visible')) {
    // find 1st parent that is not visible
    var $parent = $gridDiv;
    var observer = new MutationObserver(function (mutations) {
      if (window.getComputedStyle($parent[0]).display !== 'none') {
        observer.disconnect();
        resize();
      }
    });

    while ($parent.length > 0) {
      if (window.getComputedStyle($parent[0]).display === 'none') {
        break;
      }
      $parent = $parent.parent();

    }

    if ($parent.length > 0) {
      observer.observe($parent[0], {
        attributes: true,
        childList: false,
        characterData: false
      });
    }

  }
}
;

morpheus.Table.defaultRenderer = function (item, value) {
  if (value == null) {
    return '';
  } else if (_.isNumber(value)) {
    return morpheus.Util.nf(value);
  } else if (morpheus.Util.isArray(value)) {
    var s = [];
    for (var i = 0, length = value.length; i < length; i++) {
      if (i > 0) {
        s.push(', ');
      }
      var val = value[i];
      s.push(value[i]);
    }
    return s.join('');
  } else {
    return '' + value;
  }
};

morpheus.Table.prototype = {
  toText: function () {
    var text = [];
    var items = this.getItems();
    var columns = this.columns.filter(function (c) {
      return c.visible;
    });
    for (var j = 0; j < columns.length; j++) {
      if (j > 0) {
        text.push('\t');
      }
      text.push(columns[j].name);
    }
    text.push('\n');
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      for (var j = 0; j < columns.length; j++) {
        if (j > 0) {
          text.push('\t');
        }
        var value = columns[j].getter(item);
        text.push(morpheus.Util.toString(value));
      }
      text.push('\n');
    }
    return text.join('');
  },
  setHeight: function (height) {
    this.options.height = height;
    if (height === 'auto') {
      this.$gridDiv.css('height', '');
      this.grid.grid.getOptions().autoHeight = true;
      this.grid.grid.setOptions(this.grid.grid.getOptions());

    } else {
      this.$gridDiv.css('height', height);
    }
    this.grid.grid.resizeCanvas();
    if (height === 'auto') {
      var height = this.getItems().length * this.options.rowHeight
        + this.options.rowHeight;
      this.$gridDiv.find('.slick-viewport').css('height', height + 'px');
    }
    this.grid.grid.invalidate();

  },
  setSearchVisible: function (visible) {
    this.$header.find('[name=search]').css('display', visible ? '' : 'none');
  },
  autocomplete: function (tokens, response) {
    var matches = [];
    var token = tokens != null && tokens.length > 0 ? tokens[tokens.selectionStartIndex]
      : '';
    token = $.trim(token);
    var columns = this.columns.filter(function (c) {
      return (c.searchable && c.visible) || c.alwaysSearch;
    });

    var ncolumns = columns.length;
    var showField = ncolumns > 1;
    if (token === '') {
      if (ncolumns <= 1) {
        return response(matches);
      }
      for (var i = 0; i < ncolumns; i++) {
        var field = columns[i].name;
        matches.push({
          value: field + ':',
          label: '<span style="font-weight:300;">' + field
          + ':</span>',
          show: true
        });
        // show column names

      }
      matches
        .sort(function (a, b) {
          return (a.value === b.value ? 0
            : (a.value < b.value ? -1 : 1));
        });
      return response(matches);
    }
    var field = null;
    var semi = token.indexOf(':');
    var regex = new RegExp('^' + morpheus.Util.escapeRegex(token), 'i');
    if (semi > 0) { // field search?
      if (token.charCodeAt(semi - 1) !== 92) { // \:
        var possibleField = $.trim(token.substring(0, semi));
        if (possibleField.length > 0 && possibleField[0] === '"'
          && possibleField[token.length - 1] === '"') {
          possibleField = possibleField.substring(1,
            possibleField.length - 1);
        }
        var columnNameToColumn = new morpheus.Map();
        var columnNames = columns.map(function (c) {
          return c.name;
        });
        for (var i = 0; i < columnNames.length; i++) {
          columnNameToColumn.set(columnNames[i], columns[i]);
        }
        var c = columnNameToColumn.get(possibleField);
        if (c !== undefined) {
          token = $.trim(token.substring(semi + 1));
          columns = [c];
          ncolumns = 1;
        }
      }

    } else if (ncolumns > 1) {
      var regex = new RegExp('^' + morpheus.Util.escapeRegex(token), 'i');
      for (var j = 0; j < ncolumns; j++) {
        var field = columns[j].name;
        if (regex.test(field)) {
          matches.push({
            value: field + ':',
            label: '<span style="font-weight:300;">' + field
            + ':</span>',
            show: true
          });
        }
      }
    }
    var set = new morpheus.Set();
    var regex = new RegExp('^' + morpheus.Util.escapeRegex(token), 'i');
    var items = this.getItems();
    var dataTypes = [];
    // filter numeric columns
    var filteredColumns = [];
    columns.forEach(function (c) {
      var dataType = null;
      for (var i = 0, nitems = items.length; i < nitems; i++) {
        var value = c.getter(items[i]);
        if (value != null) {
          dataType = morpheus.Util.getDataType(value);
          break;
        }
      }
      if (dataType === 'string' || dataType === '[string]') {
        dataTypes.push(dataType);
        filteredColumns.push(c);
      }
    });
    columns = filteredColumns;
    ncolumns = columns.length;
    var maxSize = matches.length + 10;
    for (var i = 0, nitems = items.length; i < nitems; i++) {
      var item = items[i];
      for (var j = 0; j < ncolumns; j++) {
        var field = columns[j].name;
        var value = columns[j].getter(item);
        var dataType = dataTypes[j];
        if (dataType === '[string]') {
          var nvalues = value == null ? 0 : value.length;
          for (var k = 0; k < nvalues; k++) {
            var val = value[k];
            if (regex.test(val) && !set.has(val)) {
              set.add(val);
              matches
                .push({
                  value: showField ? (field + ':' + val)
                    : val,
                  label: showField ? ('<span style="font-weight:300;">'
                  + field
                  + ':</span>'
                  + '<span style="font-weight:900;">'
                  + val + '</span>')
                    : ('<span style="font-weight:900;">'
                  + val + '</span>')
                });
            }
            if (matches.length === maxSize) {
              return response(matches);
            }
          }
        } else {
          if (regex.test(value) && !set.has(value)) {
            set.add(value);
            matches
              .push({
                value: showField ? (field + ':' + value)
                  : value,
                label: showField ? ('<span style="font-weight:300;">'
                + field
                + ':</span>'
                + '<span style="font-weight:900;">'
                + value + '</span>')
                  : ('<span style="font-weight:900;">'
                + value + '</span>')
              });
            if (matches.length === maxSize) {
              return response(matches);
            }
          }
        }

      }
    }
    return response(matches);

  },
  searchWithPredicates: function (predicates) {
    if (predicates == null || predicates.length === 0) {
      this.searchFunction = null;
      this.grid
        .setFilter(this.grid
          .getFilter());
      return;
    }
    var columns = this.columns.filter(function (c) {
      return (c.searchable && c.visible) || c.alwaysSearch;
    });
    var columnNameToColumn = new morpheus.Map();
    var columnNames = columns.map(function (c) {
      return c.name;
    });
    for (var i = 0; i < columnNames.length; i++) {
      columnNameToColumn.set(columnNames[i], columns[i]);
    }

    var filteredPredicates = [];
    var npredicates = predicates.length;
    for (var i = 0; i < npredicates; i++) {
      var predicate = predicates[i];
      var filterColumnName = predicate.getField();
      if (filterColumnName != null) {
        var column = columnNameToColumn.get(filterColumnName);
        if (column) {
          predicate.column = column;
          filteredPredicates.push(predicate);
        }
      } else {
        filteredPredicates.push(predicate);
      }
    }
    predicates = filteredPredicates;
    npredicates = predicates.length;
    var f = function (item) {
      for (var p = 0; p < npredicates; p++) {
        var predicate = predicates[p];
        var searchColumns;
        if (predicate.column) {
          searchColumns = [predicate.column];
        } else {
          searchColumns = columns;
        }
        for (var j = 0, ncolumns = searchColumns.length; j < ncolumns; j++) {
          var value = searchColumns[j].getter(item);
          if (morpheus.Util.isArray(value)) {
            var nvalues = value.length;
            for (var i = 0; i < nvalues; i++) {
              if (predicate.accept(value[i])) {
                return true;
              }
            }
          } else {
            var predicate = predicates[p];
            if (predicate.accept(value)) {
              return true;
            }
          }
        }

      }

      return false;
    };
    this.searchFunction = f;
    this.grid
      .setFilter(this.grid
        .getFilter());
  },
  search: function (text) {
    if (text === '') {
      this.searchFunction = null;
      this.grid
        .setFilter(this.grid
          .getFilter());
    } else {
      var tokens = morpheus.Util.getAutocompleteTokens(text);
      var columns = this.columns.filter(function (c) {
        return (c.searchable && c.visible) || c.alwaysSearch;
      });
      var columnNames = columns.map(function (c) {
        return c.name;
      });
      var predicates = morpheus.Util.createSearchPredicates({
        tokens: tokens,
        fields: columnNames
      });
      this.searchWithPredicates(predicates);
    }
  },
  getSelectedRows: function () {
    return this.grid.getSelectedRows();
  },
  getSelectedItems: function () {
    return this.grid.getSelectedItems();
  },
  getSelectedItem: function () {
    return this.grid.getSelectedItem();
  },
  setSelectedRows: function (rows) {
    this.grid.setSelectedRows(rows);
  },
  getItems: function (items) {
    return this.grid.getItems();
  },
  getAllItemCount: function () {
    return this.grid.getAllItemCount();
  },
  getFilteredItemCount: function () {
    return this.grid.getFilteredItemCount();
  },
  setFilter: function (f) {
    this.grid.setFilter(f);
  },
  getFilter: function () {
    return this.grid.getFilter();
  },
  setItems: function (items) {
    this.grid.setItems(items);
    this.grid.redraw();
    // TODO update height?
  },
  redraw: function () {
    this.grid.redraw();
  },
  /**
   * @param evtStr
   *            selectionChanged
   */
  on: function (evtStr, handler) {
    this.grid.on(evtStr, handler);
    return this;
  },
  off: function (evtStr, handler) {
    this.grid.off(evtStr, handler);
    return this;
  },
  trigger: function (evtStr) {
    this.grid.trigger(evtStr);
  }
};

morpheus.Table.createOptions = function (options) {
  options = $.extend(true, {}, {
    items: [],
    height: '564px',
    collapseBreakpoint: 400,
    showHeader: true,
    select: true,
    rowHeader: null,
    responsive: true,
    fixedWidth: '320px',
    columnPicker: true
  }, options);

  if (!options.columns) {
    options.columns = [{
      name: ''
    }];
  }
  var columns = [];
  options.columns.forEach(function (c, i) {
    var column = $.extend(true, {}, {
      id: i,
      tooltip: function (dataContext, value) {
        return morpheus.Table.defaultRenderer(dataContext, value);
      },
      formatter: function (row, cell, value, columnDef, dataContext) {

        var html = [];
        html.push('<div class="slick-table-wrapper"><div class="slick-cell-wrapper">');
        if (options.rowHeader && cell === 0) {
          html.push(options.rowHeader(dataContext));
        }
        html.push(column.renderer(dataContext, value));
        html.push('</div></div>');
        return html.join('');

      },
      comparator: function (a, b) {
        var aNaN = (a == null || _.isNumber(a) && isNaN(a));
        var bNaN = (b == null || _.isNumber(b) && isNaN(b));
        if (aNaN && bNaN) {
          return 0;
        }
        if (aNaN) {
          return 1;
        }
        if (bNaN) {
          return -1;
        }
        if (a.toLowerCase) {
          a = a.toLowerCase();
        }
        if (b.toLowerCase) {
          b = b.toLowerCase();
        }

        return (a === b ? 0 : (a < b ? -1 : 1));
      },
      sortable: true,
      searchable: true,
      width: null,
      name: c.name,
      renderer: morpheus.Table.defaultRenderer
    }, c);

    if (column.visible === undefined) {
      column.visible = true;
    }
    if (!column.getter) {
      column.getter = column.field == null ? function (item) {
        return item;
      } : function (item) {
        return item[c.field];
      };
    }

    columns.push(column);
  });

  options.columns = columns;
  if (options.columns.length === 1) {
    options.tableClass = 'slick-table-compact';
  } else {
    options.tableClass = 'slick-bordered-table';
  }
  if (!options.rowHeight) {
    // options.rowHeight = options.tableClass === 'slick-table-compact' ? 18
    // 	: 20;
    options.rowHeight = 22;
  }
  return options;
};

morpheus.TableSearchUI = function (options) {
  var _this = this;
  var $search = $('<input name="search" type="text" class="form-control input-sm"' +
    ' placeholder="Search" autocomplete="off">');
  $search.appendTo(options.$el);
  this.$search = $search;
  this.$searchResults = $('<span class="pad-top-2 tableview-rowcount" name="search"></span>');
  this.$showAll = $('<div style="display:inline-block;min-width:60px;" name="search" class="pad-left-8 text-button-copy tableview-rowcount">Show' +
    ' all</div>');
  this.$searchResults.appendTo(options.$right);
  this.$showAll.appendTo(options.$right);
  this.$showAll.on('click', function (e) {
    e.preventDefault();
    $search.val('');
    _this.table.search('');
    _this.table.trigger('showAll', {table: _this.table});

  });
  $search.on('keyup', _.debounce(function () {
    _this.table.search($.trim($(this).val()));
  }, 100));
  morpheus.Util.autosuggest({
    $el: $search,
    suggestWhenEmpty: true,
    filter: function (tokens, response) {
      _this.table.autocomplete(tokens, response);
    },
    select: function () {
      _this.table.search($.trim($search.val()));
    }
  });
};

morpheus.TableSearchUI.prototype = {
  updateSearchLabel: function () {
    var text = 'Showing: ' + morpheus.Util.intFormat(this.table.getFilteredItemCount()) + ' / ' + morpheus.Util.intFormat(this.table.getAllItemCount());
    this.$searchResults.html(text);
  },
  setTable: function (table) {
    this.table = table;
    var _this = this;

    table.on('filter', function () {
      _this.updateSearchLabel();
    });

  }

};


morpheus.TrackSelection = function (track, positions, selectionModel, isColumns,
                                    heatMap) {
  var canvas = track.canvas;
  var startIndex = -1;
  var coord = isColumns ? 'x' : 'y';

  function getPosition(event, useDelta) {
    if (track.settings.squished) {
      var total = positions.getPosition(positions.getLength() - 1)
        + positions.getItemSize(positions.getLength() - 1);
      var squishFactor = total
        / (isColumns ? track.getUnscaledWidth() : track
          .getUnscaledHeight());
      var clientXY = morpheus.CanvasUtil.getClientXY(event, useDelta);
      var p = morpheus.CanvasUtil.getMousePosWithScroll(event.target,
        event, 0, 0, useDelta);
      p[coord] *= squishFactor;
      return p;

    } else {
      return morpheus.CanvasUtil.getMousePosWithScroll(event.target,
        event, heatMap.scrollLeft(), heatMap.scrollTop(),
        useDelta);
    }

  }

  var panning = false;

  this.hammer = morpheus.Util
    .hammer(canvas, ['pan', 'tap', 'longpress'])
    .on('longpress', this.longpress = function (event) {
      event.preventDefault();
      event.srcEvent.stopImmediatePropagation();
      event.srcEvent.stopPropagation();
      heatMap.setSelectedTrack(track.name, isColumns);
      track.showPopup(event.srcEvent);
    }).on('panend', this.panend = function (event) {
      panning = false;
    })
    .on(
      'panmove',
      this.panmove = function (event) {
        var position = getPosition(event);
        var endIndex = positions.getIndex(position[coord],
          false);
        var commandKey = morpheus.Util.IS_MAC ? event.srcEvent.metaKey
          : event.srcEvent.ctrlKey;
        var viewIndices = commandKey ? selectionModel
          .getViewIndices() : new morpheus.Set();
        var _startIndex = startIndex;
        if (startIndex > endIndex) {
          var tmp = endIndex;
          endIndex = _startIndex;
          _startIndex = tmp;
        }
        for (var i = _startIndex; i <= endIndex; i++) {
          viewIndices.add(i);
        }
        selectionModel.setViewIndices(viewIndices, true);
        if (!isColumns) {
          var scrollTop = heatMap.scrollTop();
          var scrollBottom = scrollTop
            + heatMap.heatmap.getUnscaledHeight();
          if (position.y > scrollBottom) {
            heatMap.scrollTop(scrollTop + 8);
          } else if (position.y < scrollTop) {
            heatMap.scrollTop(scrollTop - 8);
          }
        } else {
          var scrollLeft = heatMap.scrollLeft();
          var scrollRight = scrollLeft
            + heatMap.heatmap.getUnscaledWidth();
          if (position.x > scrollRight) {
            heatMap.scrollLeft(scrollLeft + 8);
          } else if (position.x < scrollLeft) {
            heatMap.scrollLeft(scrollLeft - 8);
          }
        }
        event.preventDefault();
        event.srcEvent.stopPropagation();
        event.srcEvent.stopImmediatePropagation();
      })
    .on('panstart', this.panstart = function (event) {
      heatMap.setSelectedTrack(track.name, isColumns);
      var position = getPosition(event, true);
      startIndex = positions.getIndex(position[coord], false);
      panning = true;
    })
    .on(
      'tap doubletap',
      this.tap = function (event) {
        var position = getPosition(event);
        var index = positions.getIndex(position[coord], false);
        if (event.tapCount > 1) {
          if ((isColumns && !heatMap.options.columnsSortable)
            || (!isColumns && !heatMap.options.rowsSortable)) {
            return;
          }
          heatMap.sortBasedOnSelection(null, isColumns,
            event.srcEvent.shiftKey);
        } else {
          heatMap.setSelectedTrack(track.name, isColumns);
          var commandKey = morpheus.Util.IS_MAC ? event.srcEvent.metaKey
            : event.srcEvent.ctrlKey;
          if (morpheus.Util.IS_MAC && event.srcEvent.ctrlKey) { // right-click
            // on
            // Mac
            return;
          }
          var viewIndices;
          if (commandKey) { // toggle selection
            viewIndices = selectionModel.getViewIndices();
            if (viewIndices.has(index)) {
              viewIndices.remove(index);
            } else {
              viewIndices.add(index);
            }
          } else if (event.srcEvent.shiftKey) { // add to
            // selection
            viewIndices = selectionModel.getViewIndices();
            var min = Number.MAX_VALUE;
            var max = -Number.MAX_VALUE;
            viewIndices.forEach(function (viewIndex) {
              min = Math.min(viewIndex, min);
              max = Math.max(viewIndex, max);
            });

            if (index >= max) { // select from index to max
              for (var i = max; i <= index; i++) {
                viewIndices.add(i);
              }
            } else {// select from index to min
              for (var i = Math.min(index, min), max = Math
                .max(index, min); i <= max; i++) {
                viewIndices.add(i);
              }
            }
          } else {
            viewIndices = new morpheus.Set();
            viewIndices.add(index);
          }
          selectionModel.setViewIndices(viewIndices, true);
        }
      });
};
morpheus.TrackSelection.prototype = {
  dispose: function () {
    this.hammer.off('longpress', this.longpress).off('panstart',
      this.panstart).off('panmove', this.panmove).off('panend', this.panend).off('tap', this.tap).off('doubletap', this.tap);
    this.hammer.destroy();
  }
};

morpheus.VectorTrackHeader = function (project, name, isColumns, heatMap) {
  morpheus.AbstractCanvas.call(this);
  this.project = project;
  this.name = name;
  this.isColumns = isColumns;
  var canvas = this.canvas;
  this.heatMap = heatMap;
  var vector = (isColumns ? project.getFullDataset().getColumnMetadata()
    : project.getFullDataset().getRowMetadata()).getByName(name);
  if (vector && vector.getProperties().has(morpheus.VectorKeys.TITLE)) {
    this.canvas.setAttribute('title', vector.getProperties().get(
      morpheus.VectorKeys.TITLE));
    $(this.canvas).tooltip();
  }

  var _this = this;

  this.setBounds({
    height: this.defaultFontHeight
    + morpheus.VectorTrackHeader.FONT_OFFSET
  });

  function getResizeCursor(pos) {
    if (isColumns) {
      if (pos.y < 3) {
        return {
          cursor: 'ns-resize',
          isPrevious: true
        };
      }
      if (pos.y >= (_this.getUnscaledHeight() - 3)) {
        return {
          cursor: 'ns-resize',
          isPrevious: false
        };
      }
      if (pos.x >= (_this.getUnscaledWidth() - 3)) { // change change column width
        return {
          isPrevious: false,
          cursor: 'ew-resize'
        };
      }
    } else {
      if (pos.x < 3) {
        return {
          cursor: 'ew-resize',
          isPrevious: true
        };
      }
      if (pos.x >= (_this.getUnscaledWidth() - 3)) {
        return {
          cursor: 'ew-resize',
          isPrevious: false
        };
      }
    }
  }

  var mouseMove = function (event) {
    if (!morpheus.CanvasUtil.dragging) {
      var pos = morpheus.CanvasUtil.getMousePos(event.target, event);
      var resizeCursor = getResizeCursor(pos);
      canvas.style.cursor = resizeCursor == null ? 'default' : resizeCursor.cursor;
      //document.body.style.cursor = !cursor ? 'default' : cursor;
      _this.isMouseOver = true;
      _this.repaint();
    }

  };
  var mouseExit = function (e) {
    if (!morpheus.CanvasUtil.dragging) {
      canvas.style.cursor = 'default';
    }
    _this.isMouseOver = false;
    _this.repaint();
  };
  var showPopup = function (e) {
    heatMap.setSelectedTrack(_this.name, isColumns);
    var track = heatMap.getTrack(_this.name, isColumns);
    if (!track) {
      throw _this.name + ' track not found';
    }
    e.preventDefault();
    if (e.stopPropagation) {
      e.stopPropagation();
    }
    if (e.stopImmediatePropagation) {
      e.stopImmediatePropagation();
    }
    track.showPopup(e, true);
    return false;
  };
  this.selectedBackgroundColor = '#c8c8c8';
  this.backgroundColor = '#f9f9f9';
  $(this.canvas).css({'background-color': this.backgroundColor}).on(
    'mousemove.morpheus', mouseMove).on('mouseout.morpheus', mouseExit)
    .on('mouseenter.morpheus', mouseMove);

  $(this.canvas).on('contextmenu.morpheus', showPopup);

  var resizeCursor;
  var dragStartWidth = 0;
  var dragStartHeight = 0;
  var reorderingTrack = false;
  var dragStartPosition;
  var resizeTrackName;
  // var throttled = _.throttle(function(event) {
  //
  // if (event.type === 'mouseout') {
  // } else {
  // }
  // }, 100);
  // $(canvas).on('mouseout', throttled).on('mousemove', throttled);
  this.hammer = morpheus.Util
    .hammer(canvas, ['pan', 'tap', 'longpress'])
    .on('longpress', this.longpress = function (event) {
      event.preventDefault();
      heatMap.setSelectedTrack(_this.name, isColumns);
      var track = heatMap.getTrack(_this.name, isColumns);
      track.showPopup(event.srcEvent, true);
    })
    .on(
      'panend',
      this.panend = function (event) {
        _this.isMouseOver = false;
        morpheus.CanvasUtil.dragging = false;
        canvas.style.cursor = 'default';
        var index = heatMap.getTrackIndex(_this.name,
          isColumns);
        var header = heatMap.getTrackHeaderByIndex(index,
          isColumns);
        var track = heatMap
          .getTrackByIndex(index, isColumns);
        var $canvas = $(track.canvas);
        $canvas.css('z-index', '0');
        $(header.canvas).css('z-index', '0');
        heatMap.revalidate();
      })
    .on(
      'panstart',
      this.panstart = function (event) {
        _this.isMouseOver = false;
        if (morpheus.CanvasUtil.dragging) {
          return;
        }
        resizeCursor = getResizeCursor(morpheus.CanvasUtil
          .getMousePos(event.target, event, true));
        if (resizeCursor != null) { // make sure start event was on
          // hotspot
          morpheus.CanvasUtil.dragging = true;
          canvas.style.cursor = resizeCursor.cursor;
          if (resizeCursor.isPrevious) {
            var index = heatMap.getTrackIndex(_this.name,
              isColumns);
            index--; // FIXME index = -1
            if (index === -1) {
              index = 0;
            }
            var header = heatMap.getTrackHeaderByIndex(
              index, isColumns);
            dragStartWidth = header.getUnscaledWidth();
            dragStartHeight = header.getUnscaledHeight();
            resizeTrackName = header.name;
          } else {
            resizeTrackName = null;
            dragStartWidth = _this.getUnscaledWidth();
            dragStartHeight = _this.getUnscaledHeight();
          }
          event.preventDefault();
          reorderingTrack = false;
        } else {
          var index = heatMap.getTrackIndex(_this.name,
            isColumns);
          if (index == -1) {
            throw _this.name + ' not found';
          }
          var header = heatMap.getTrackHeaderByIndex(
            index, isColumns);
          var track = heatMap.getTrackByIndex(index,
            isColumns);
          heatMap.setSelectedTrack(_this.name, isColumns);
          var $canvas = $(track.canvas);
          dragStartPosition = $canvas.position();
          $canvas.css('z-index', '100');
          $(header.canvas).css('z-index', '100');
          morpheus.CanvasUtil.dragging = true;
          resizeCursor = undefined;
          reorderingTrack = true;
        }
      })
    .on(
      'panmove',
      this.panmove = function (event) {
        _this.isMouseOver = false;
        if (resizeCursor != null) {
          var width;
          var height;
          if (resizeCursor.cursor === 'ew-resize') {
            var dx = event.deltaX;
            width = Math.max(8, dragStartWidth + dx);
          }

          if (resizeCursor.cursor === 'ns-resize') {
            var dy = event.deltaY;
            height = Math.max(8, dragStartHeight + dy);
          }

          heatMap.resizeTrack(resizeTrackName == null ? _this.name : resizeTrackName, width, height,
            isColumns);
        } else if (reorderingTrack) { // reorder
          var index = heatMap.getTrackIndex(_this.name,
            isColumns);
          var header = heatMap.getTrackHeaderByIndex(
            index, isColumns);
          var track = heatMap.getTrackByIndex(index,
            isColumns);
          var ntracks = heatMap.getNumTracks(isColumns);
          var delta = isColumns ? event.deltaY : event.deltaX;
          var newIndex = index + (delta > 0 ? 1 : -1);
          newIndex = Math.min(Math.max(0, newIndex),
            ntracks - 1);
          var prop = isColumns ? 'top' : 'left';
          var w = isColumns ? 'getUnscaledHeight'
            : 'getUnscaledWidth';
          var trackBounds = {};
          trackBounds[prop] = dragStartPosition[prop] + delta;
          track.setBounds(trackBounds);
          header.setBounds(trackBounds);
          var dragOverTrack = heatMap.getTrackByIndex(
            newIndex, isColumns);
          var dragOverWidth = dragOverTrack[w]();
          var dragOverLeft = $(dragOverTrack.canvas)
            .position()[prop];
          var dragleft = dragStartPosition[prop] + delta;
          var dragright = dragleft + track[w]();
          if ((delta > 0 && dragright >= dragOverLeft
            + dragOverWidth / 2)
            || (delta < 0 && dragleft <= dragOverLeft
            + dragOverWidth / 2)) {
            if (index !== newIndex) {
              heatMap.moveTrack(index, newIndex,
                isColumns);
              var otherHeader = heatMap
                .getTrackHeaderByIndex(index,
                  isColumns);
              var otherTrack = heatMap
                .getTrackByIndex(index, isColumns);
              var $movedCanvas = $(otherTrack.canvas);
              var newLeft = $movedCanvas.position()[prop];
              if (delta < 0) {
                newLeft += track[w]();
              } else {
                newLeft -= track[w]();
              }
              var otherBounds = {};
              otherBounds[prop] = newLeft;
              otherTrack.setBounds(otherBounds);
              otherHeader.setBounds(otherBounds);
            }
          }
        }
      })
    .on(
      'tap',
      this.tap = function (event) {
        if (morpheus.Util.IS_MAC && event.srcEvent.ctrlKey) { // right-click
          return;
        }
        _this.isMouseOver = false;
        heatMap.setSelectedTrack(_this.name, isColumns);
        if (isColumns && !heatMap.options.columnsSortable) {
          return;
        }
        if (!isColumns && !heatMap.options.rowsSortable) {
          return;
        }

        var additionalSort = event.srcEvent.shiftKey;
        var isGroupBy = false; // event.srcEvent.altKey;

        var existingSortKeyIndex = _this
          .getSortKeyIndexForColumnName(_this
            .getSortKeys(), _this.name);
        var sortOrder;
        var sortKey;
        var vector = (isColumns ? project.getFullDataset().getColumnMetadata()
          : project.getFullDataset().getRowMetadata()).getByName(name);
        var dataType = morpheus.VectorUtil.getDataType(vector);
        if (existingSortKeyIndex != -1) {
          sortKey = _this.getSortKeys()[existingSortKeyIndex];
          if (sortKey.getSortOrder() === morpheus.SortKey.SortOrder.UNSORTED) {
            sortOrder = morpheus.SortKey.SortOrder.ASCENDING; // 1st
            // click
          } else if (sortKey.getSortOrder() === morpheus.SortKey.SortOrder.ASCENDING) {
            sortOrder = morpheus.SortKey.SortOrder.DESCENDING; // 2nd
            // click
          } else if (sortKey.getSortOrder() === morpheus.SortKey.SortOrder.TOP_N) {
            sortOrder = morpheus.SortKey.SortOrder.UNSORTED;
          } else {
            sortOrder = dataType === 'number' || dataType === '[number]' ? morpheus.SortKey.SortOrder.TOP_N : morpheus.SortKey.SortOrder.UNSORTED; // 3rd
            // click
          }

        } else {
          sortKey = new morpheus.SortKey(_this.name,
            morpheus.SortKey.SortOrder.ASCENDING);
          sortOrder = morpheus.SortKey.SortOrder.ASCENDING;
        }
        if (sortKey != null) {
          sortKey.setSortOrder(sortOrder);
          _this.setSortingStatus(_this.getSortKeys(),
            sortKey, additionalSort, isGroupBy);
        }
        // }
      });
};
morpheus.VectorTrackHeader.FONT_OFFSET = 2;
morpheus.VectorTrackHeader.prototype = {
  selected: false,
  isMouseOver: false,
  defaultFontHeight: 11,
  dispose: function () {
    morpheus.AbstractCanvas.prototype.dispose.call(this);
    this.hammer.off('longpress', this.longpress).off('panend', this.panend).off('panstart',
      this.panstart).off('panmove', this.panmove).off('tap', this.tap);
    this.hammer.destroy();
  },
  getPreferredSize: function () {
    var size = this.getPrintSize();
    size.width += 22;

    if (!this.isColumns) {
      size.height = this.defaultFontHeight
        + morpheus.VectorTrackHeader.FONT_OFFSET;
    }
    // var vector = (this.isColumns ? this.project.getFullDataset()
    // .getColumnMetadata() : this.project.getFullDataset()
    // .getRowMetadata()).getByName(this.name);
    // if (vector
    // && vector.getProperties().get(
    // morpheus.VectorKeys.SHOW_HEADER_SUMMARY)) {
    // if (isNaN(size.height)) {
    // size.height = 0;
    // }
    // if (!this.isColumns) {
    // size.height += 50;
    // } else {
    // size.width += 50;
    // }
    //
    // }
    return size;
  },
  getPrintSize: function () {
    var context = this.canvas.getContext('2d');
    context.font = this.defaultFontHeight + 'px '
      + morpheus.CanvasUtil.FONT_NAME;
    var textWidth = 4 + context.measureText(this.name).width;
    return {
      width: textWidth,
      height: this.defaultFontHeight
      + morpheus.VectorTrackHeader.FONT_OFFSET
    };
  },
  getSortKeys: function () {
    return this.isColumns ? this.project.getColumnSortKeys() : this.project
      .getRowSortKeys();
  },
  setOrder: function (sortKeys) {
    if (this.isColumns) {
      this.project.setColumnSortKeys(morpheus.SortKey
        .keepExistingSortKeys(sortKeys, this.project
          .getColumnSortKeys()), false);
    } else {
      this.project.setRowSortKeys(morpheus.SortKey.keepExistingSortKeys(
        sortKeys, this.project.getRowSortKeys()), false);
    }
  },
  setGroupBy: function (groupBy) {
    var existingGroupBy = this.isColumns ? this.project.groupColumns
      : this.project.groupRows;
    // see if already exists, if so remove it
    var index = -1;
    for (var i = 0, length = existingGroupBy.length; i < length; i++) {
      if (existingGroupBy[i].toString() === groupBy.toString()) {
        index = i;
        break;
      }
    }
    var newGroupBy = [groupBy];
    if (index !== -1) {
      newGroupBy = existingGroupBy;
      newGroupBy.splice(index, 1);
    }
    if (this.isColumns) {
      this.project.setGroupColumns(newGroupBy, true);
    } else {
      this.project.setGroupRows(newGroupBy, true);
    }
  },
  setSelected: function (selected) {
    if (selected != this.selected) {
      this.selected = selected;
      $(this.canvas)
        .css(
          {
            'background-color': this.selected ? this.selectedBackgroundColor
              : this.backgroundColor
          });
    }
  },
  setSortingStatus: function (sortKeys, sortKey, additionalSort, isGroupBy) {
    if (!isGroupBy) {
      if (sortKey.getSortOrder() == morpheus.SortKey.SortOrder.UNSORTED
        && !additionalSort) {
        this.setOrder([]);
      } else {
        if (additionalSort && sortKeys.length == 0) {
          additionalSort = false;
        }
        if (!additionalSort) {
          sortKeys = [sortKey];
        } else {
          var sortKeyIndex = this.getSortKeyIndexForColumnName(
            sortKeys, sortKey.toString());
          if (sortKeyIndex === -1) { // new sort column
            sortKeys.push(sortKey);
          } else { // change sort order of existing sort column
            sortKeys[sortKeyIndex] = sortKey;
          }
        }
        this.setOrder(sortKeys);
      }
    }
    if (isGroupBy) {
      this.setGroupBy(sortKey);
    } else {
      if (this.isColumns) {
        this.project.trigger('columnSortOrderChanged');
      } else {
        this.project.trigger('rowSortOrderChanged');
      }
    }
  },
  getSortKeyIndexForColumnName: function (sortKeys, columnName) {
    if (sortKeys != null) {
      for (var i = 0, size = sortKeys.length; i < size; i++) {
        if (columnName === sortKeys[i].toString()) {
          return i;
        }
      }
    }
    return -1;
  },
  print: function (clip, context) {
    if (clip.height <= 6) {
      return;
    }
    context.textBaseline = 'bottom';
    if (this.isColumns) {
      context.textAlign = 'right';
      context.font = Math.min(this.defaultFontHeight, clip.height
          - morpheus.VectorTrackHeader.FONT_OFFSET)
        + 'px ' + morpheus.CanvasUtil.FONT_NAME;
    } else {
      context.textAlign = 'left';
      context.font = (clip.height - morpheus.VectorTrackHeader.FONT_OFFSET)
        + 'px ' + morpheus.CanvasUtil.FONT_NAME;
    }
    context.fillStyle = morpheus.CanvasUtil.FONT_COLOR;
    context.fillText(this.name, 0, 0);
  },
  draw: function (clip, context) {
    var sortKeys = this.getSortKeys();
    var name = this.name;
    var existingSortKeyIndex = this.getSortKeyIndexForColumnName(sortKeys,
      name);
    morpheus.CanvasUtil.resetTransform(context);
    context.clearRect(0, 0, this.getUnscaledWidth(), this
      .getUnscaledHeight());

    if (this.getUnscaledHeight() < 5) {
      return;
    }

    if (this.isColumns) {
      context.beginPath();
      context.moveTo(0, this.getUnscaledHeight());
      context.lineTo(this.getUnscaledWidth(), this.getUnscaledHeight());
      context.stroke();
      context.textAlign = 'right';
    } else {
      context.beginPath();
      context.moveTo(this.getUnscaledWidth(), 0);
      context.lineTo(this.getUnscaledWidth(), this.getUnscaledHeight());
      context.stroke();
      context.textAlign = 'left';
    }
    var fontHeight = Math.min(this.defaultFontHeight, this
        .getUnscaledHeight()
      - morpheus.VectorTrackHeader.FONT_OFFSET);
    var squished = this.heatMap.getTrack(this.name, this.isColumns).settings.squished;
    context.font = (squished ? 'Italic ' : '') + fontHeight + 'px '
      + morpheus.CanvasUtil.FONT_NAME;
    var textWidth = context.measureText(name).width;
    var isColumns = this.isColumns;
    var xpix = this.isColumns ? this.getUnscaledWidth() - 2 : 10;
    if (isColumns) {
      if (existingSortKeyIndex != -1) {
        xpix -= 6;
      }
      if (sortKeys.length > 1) {
        xpix -= 6;
      }
    }
    var ypix = this.isColumns ? (this.getUnscaledHeight() / 2)
      : (this.getUnscaledHeight() - (this.defaultFontHeight + morpheus.VectorTrackHeader.FONT_OFFSET) / 2);
    context.textBaseline = 'middle';
    if (this.isMouseOver) {
      context.fillStyle = 'rgb(0,0,0)';
      var xdot = xpix - (isColumns ? textWidth + 4 : 4);
      var ydot = ypix - 3;
      for (var i = 0; i < 2; i++) {
        for (var j = 0; j < 3; j++) {
          context.fillRect(xdot - i * 3, ydot + j * 3, 1.5, 1.5);
        }
      }
    }
    context.fillStyle = morpheus.CanvasUtil.FONT_COLOR;
    context.fillText(name, xpix, ypix);
    // var vector = (this.isColumns ? this.project.getFullDataset()
    // .getColumnMetadata() : this.project.getFullDataset()
    // .getRowMetadata()).getByName(this.name);
    // if (vector
    // && vector.getProperties().get(
    // morpheus.VectorKeys.SHOW_HEADER_SUMMARY)) {
    // var summary = vector.getProperties().get(
    // morpheus.VectorKeys.HEADER_SUMMARY);
    // var track = this.heatMap.getTrack(this.name, this.isColumns);
    // if (summary == null) {
    // var visibleFieldIndices = vector.getProperties().get(
    // morpheus.VectorKeys.VISIBLE_FIELDS);
    //
    // if (visibleFieldIndices == null) {
    // visibleFieldIndices = morpheus.Util
    // .seq(vector.getProperties().get(
    // morpheus.VectorKeys.FIELDS).length);
    // }
    // var bigArray = [];
    // var min = Number.MAX_VALUE;
    // var max = Number.MAX_VALUE;
    // for (var i = 0, size = vector.size(); i < size; i++) {
    // var array = vector.getValue(i);
    // if (array != null) {
    // for (var j = 0, length = visibleFieldIndices.length; j < length; j++)
    // {
    // var value = array[visibleFieldIndices[j]];
    // if (!isNaN(value)) {
    // bigArray.push(value);
    // min = value < min ? value : min;
    // max = value > max ? value : max;
    // }
    // }
    // }
    // }
    // var nbins = Math.ceil(morpheus.Log2(bigArray.length) + 1);
    // var binSize = (max - min) / nbins;
    // var binNumberToOccurences = new Uint32Array(nbins);
    // var maxOccurences = 0;
    // for (var i = 0, size = bigArray.length; i < size; i++) {
    // var value = bigArray[i];
    // var bin = Math.floor((value - min) / binSize);
    // if (bin < 0) {
    // bin = 0;
    // } else if (bin >= binNumberToOccurences.length) {
    // bin = binNumberToOccurences.length - 1;
    // }
    // binNumberToOccurences[bin]++;
    // maxOccurences = Math.max(maxOccurences,
    // binNumberToOccurences[bin]);
    // }
    // summary = {
    // box : morpheus.BoxPlotItem(morpheus.VectorUtil
    // .arrayAsVector(bigArray)),
    // histogram : {
    // binSize : binSize,
    // total : bigArray.length,
    // binNumberToOccurences : binNumberToOccurences,
    // maxOccurences : maxOccurences,
    // min : min,
    // max : max
    // }
    //
    // };
    //
    // vector.getProperties().set(morpheus.VectorKeys.HEADER_SUMMARY,
    // summary);
    // }
    // var box = summary.box;
    // context.save();
    // context.translate(1, 0);
    //
    // var scale = track.createChartScale(this.getUnscaledWidth() - 2); //
    // TODO
    // // make
    // // sure
    // // scale
    // // is
    // // the
    // // same
    // // as
    // // track
    // var itemSize = 12;
    // var pix = 1;
    // var start = pix + 1;
    // var end = pix + itemSize - 1;
    // var center = (start + end) / 2;
    // var _itemSize = itemSize - 2;
    // var lineHeight = Math.max(2, _itemSize - 8);
    // context.fillStyle = 'black';
    // // box from q1 (25th q) to q3
    // context.fillRect(Math.min(scale(box.q1), scale(box.q3)), start,
    // Math.abs(scale(box.q1) - scale(box.q3)), _itemSize);
    // // draw line from q1 to lav
    // context.fillRect(Math.min(scale(box.q1),
    // scale(box.lowerAdjacentValue)), center - lineHeight / 2,
    // Math.abs(scale(box.q1) - scale(box.lowerAdjacentValue)),
    // lineHeight);
    // // draw line from q3 to uav
    // context.fillRect(Math.min(scale(box.q3),
    // scale(box.upperAdjacentValue)), center - lineHeight / 2,
    // Math.abs(scale(box.q3) - scale(box.upperAdjacentValue)),
    // lineHeight);
    // var histogram = summary.histogram;
    // var yscale = d3.scale.linear().domain([ 0, 1 ]).range([ 48, 14 ])
    // .clamp(true);
    // var xscale = d3.scale.linear().domain(
    // [ histogram.min, histogram.max + histogram.binSize ])
    // .range([ 1, this.getUnscaledWidth() - 2 ]).clamp(true);
    // // context.beginPath();
    // // context.moveTo(xscale(0), yscale(0));
    //
    // for (var i = 0, nbins = histogram.binNumberToOccurences.length; i <
    // nbins; i++) {
    // var n = histogram.binNumberToOccurences[i];
    // if (n > 0) {
    // var x = histogram.min + (i * histogram.binSize);
    // var xend = histogram.min + (i * histogram.binSize)
    // + histogram.binSize;
    // var xstart = histogram.min + (i * histogram.binSize);
    // var ypix = yscale(n / histogram.total);
    // context.fillRect(xscale(xstart), ypix, xscale(xend)
    // - xscale(xstart), Math.abs(ypix - yscale(0)));
    // }
    // }
    //
    // context.restore();
    // }
    context.fillStyle = morpheus.CanvasUtil.FONT_COLOR;
    if (existingSortKeyIndex !== -1) {
      context.beginPath();
      var x = this.isColumns ? xpix + 4 : xpix + textWidth + 6;
      var arrowHeight = Math.min(8, this.getUnscaledHeight() / 2 - 1);
      var arrowWidth = 3;
      if (sortKeys[existingSortKeyIndex].getSortOrder() === morpheus.SortKey.SortOrder.ASCENDING) {
        // up arrow
        context.translate(x, ypix - arrowHeight);
        context.moveTo(0, 0);
        context.lineTo(arrowWidth, arrowHeight);
        context.lineTo(-arrowWidth, arrowHeight);
      } else if (sortKeys[existingSortKeyIndex].getSortOrder() === morpheus.SortKey.SortOrder.DESCENDING) { // down
        // arrow
        context.translate(x, ypix);
        context.moveTo(0, arrowHeight);
        context.lineTo(arrowWidth, 0);
        context.lineTo(-arrowWidth, 0);
      } else { // diamond
        context.translate(x, ypix - arrowHeight / 2);
        context.moveTo(0, 0);
        context.lineTo(arrowWidth, arrowHeight / 2);
        context.lineTo(0, arrowHeight);
        context.lineTo(-arrowWidth, arrowHeight / 2);

      }
      context.fill();
      morpheus.CanvasUtil.resetTransform(context);
      if (sortKeys.length > 1) {
        context.textAlign = 'left';
        context.font = '8px ' + morpheus.CanvasUtil.FONT_NAME;
        context.fillText('' + (existingSortKeyIndex + 1), x + 4,
          ypix - 3);
      }
    }
  }
};
morpheus.Util.extend(morpheus.VectorTrackHeader, morpheus.AbstractCanvas);

morpheus.VectorTrack = function (project, name, positions, isColumns, heatmap) {
  morpheus.AbstractCanvas.call(this, true);
  this.preferredSize = {
    width: 0,
    height: 0
  };
  this.project = project;
  this.positions = positions;
  this.isColumns = isColumns;
  this.name = name;
  this.visible = true;
  this.heatmap = heatmap;

  // this.highlightColor = 'rgb(255,255,0)';
  this.id = _.uniqueId();
  var _this = this;
  this.updateSpanMapFunction = function () {
    _this.spanMap = morpheus.VectorUtil.createSpanMap(_this.getVector());
  };

  this.lastPosition = {
    start: -1,
    end: -1
  };
  // for molecule span
  this.events = 'rowSortOrderChanged rowFilterChanged datasetChanged';
  var isTruncated = function (index) {
    if (index !== -1) {
      var size = _this.positions.getItemSize(index);
      if (size < 6) {
        return true;
      }
      var vector = _this.getVector();
      var val = vector.getValue(index);
      if (val != null && val !== '') {
        var toString = morpheus.VectorTrack.vectorToString(vector);
        var fontSize = Math.min(24, _this.positions.getSize() - 2);
        var context = _this.canvas.getContext('2d');
        context.font = fontSize + 'px ' + morpheus.CanvasUtil.FONT_NAME;
        return context.measureText(toString(val)).width > this.textWidth;
      }
    }
  };
  var mouseMoved = function (event) {
    var index = -1;
    if (event.type !== 'mouseout') {
      var position = morpheus.CanvasUtil.getMousePosWithScroll(
        event.target, event, heatmap.scrollLeft(), heatmap
          .scrollTop());
      if (_this.settings.squished) {
        var total = positions.getPosition(positions.getLength() - 1)
          + positions.getItemSize(positions.getLength() - 1);
        var squishFactor = total
          / (isColumns ? _this.getUnscaledWidth() : _this
            .getUnscaledHeight());
        position[isColumns ? 'x' : 'y'] *= squishFactor;
      }
      index = !isColumns ? _this.positions.getIndex(position.y, false)
        : _this.positions.getIndex(position.x, false);

    }

    if (isColumns) {
      heatmap.setMousePosition(-1, index, {
        name: _this.name,
        event: event
      });
    } else {
      heatmap.setMousePosition(index, -1, {
        name: _this.name,
        event: event

      });
    }
  };

  $(this.canvas).on('contextmenu.morpheus', function (e) {
    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();
    heatmap.setSelectedTrack(_this.name, isColumns);
    _this.showPopup(e);
    return false;

  });
  // display options:
  // - text and color, shape, bar (stacked or not), highlight matching (any
  // except arrays)
  // - color and bar-discrete or contin
  // - color by for bar plots
  this.settings = {
    maxTextWidth: undefined,
    squished: false,
    inlineTooltip: false,
    tooltip: true,
    discrete: true, // will be set automatically if
    // discreteAutoDetermined is false
    highlightMatchingValues: false,
    discreteAutoDetermined: false,
    colorBarSize: 12,
    stackedBar: false,
    render: {},
    selectionColor: 'rgb(182,213,253)',
    colorByField: null, // color this vector by another vector
    barColor: '#bdbdbd',
    barSize: 40,
    min: undefined,
    mid: undefined,
    max: undefined,
    autoscaleAlways: false, // autoscale on every repaint
    minMaxReversed: false
    // whether to reverse min and max when auto-setting min and max
  };
  $(this.canvas).on('mousemove.morpheus mouseout.morpheus', mouseMoved);
};
morpheus.VectorTrack.RENDER = {
  TEXT: 'text',
  COLOR: 'color',
  BAR: 'bar',
  MOLECULE: 'molecule',
  TEXT_AND_COLOR: 'text_and_color',
  SHAPE: 'shape',
  ARC: 'arc',
  BOX_PLOT: 'box_plot',
  HEAT_MAP: 'heat_map'
};
morpheus.VectorTrack.vectorToString = function (vector) {
  var formatter = function (v) {
    return '' + v;
  };
  var dataType = morpheus.VectorUtil.getDataType(vector);
  if (dataType === 'number') {
    formatter = morpheus.Util.nf;
  } else if (dataType === '[number]') {
    formatter = function (v) {
      var s = [];
      if (v != null) {
        for (var i = 0, arrayLength = v.length; i < arrayLength; i++) {
          s.push(morpheus.Util.nf(v[i]));
        }
      }
      return s.join(', ');
    };
  } else if (dataType === '[string]') {
    formatter = function (v) {
      var s = [];
      if (v != null) {
        for (var i = 0, arrayLength = v.length; i < arrayLength; i++) {
          s.push(v[i]);
        }
      }
      return s.join(', ');
    };
  }
  return formatter;
};

morpheus.VectorTrack.prototype = {
  settingFromConfig: function (conf) {
    var settings = this.settings;
    if (_.isString(conf)) {
      settings.render = {};
      var tokens = conf.split(',');
      for (var i = 0, length = tokens.length; i < length; i++) {
        var method = $.trim(tokens[i]);
        method = method.toUpperCase();
        var mapped = morpheus.VectorTrack.RENDER[method];
        if (mapped !== undefined) {
          settings.render[mapped] = true;
        } else if (method === 'DISCRETE') {
          settings.discrete = true;
          settings.discreteAutoDetermined = true;
        } else if (method === 'CONTINUOUS') {
          settings.discrete = false;
          settings.discreteAutoDetermined = true;
        } else if (method === 'HIGHLIGHT') {
          settings.highlightMatchingValues = true;
        } else if (method === 'STACKED_BAR') {
          settings.stackedBar = true;
          settings.render[morpheus.VectorTrack.RENDER.BAR] = true;
        } else if (method === 'TOOLTIP') {
          settings.inlineTooltip = true;
        } else {
          console.log(method + ' not found.');
        }
      }
    } else if (_.isNumber(conf)) {
      settings.render = {};
      settings.render[conf] = true;
    } else if (_.isObject(conf)) {
      conf.maxTextWidth = undefined;
      this.settings = $.extend({}, this.settings, conf);
      if (conf.render) {
        for (var method in conf.render) {
          method = method.toUpperCase();
          var mapped = morpheus.VectorTrack.RENDER[method];
          if (mapped !== undefined) {
            this.settings.render[mapped] = true;
          }
        }
      }
    }
    this._update();

  },
  isDiscrete: function () {
    return this.settings.discrete;
  },
  setShowTooltip: function (value) {
    this.settings.tooltip = value;
  },
  isShowTooltip: function () {
    return this.settings.tooltip;
  },
  isRenderAs: function (value) {
    return this.settings.render[value];
  },
  dispose: function () {
    morpheus.AbstractCanvas.prototype.dispose.call(this);
    $(this.canvas).off();
    this._selection.dispose();
    this.project.off(this.events, this.updateSpanMapFunction);
  },
  getName: function () {
    return this.name;
  },
  getVector: function (name) {
    name = name == null ? this.name : name;
    var vector = this.isColumns ? this.project.getSortedFilteredDataset()
      .getColumnMetadata().getByName(name) : this.project
      .getSortedFilteredDataset().getRowMetadata().getByName(name);
    return !vector ? new morpheus.Vector(name, 0) : vector;
  },
  getFullVector: function () {
    var vector = this.isColumns ? this.project.getFullDataset()
      .getColumnMetadata().getByName(this.name) : this.project
      .getFullDataset().getRowMetadata().getByName(this.name);
    return !vector ? new morpheus.Vector(this.name, 0) : vector;
  },
  _updatePreferredSize: function () {
    var size = this._computePreferredSize();
    this.preferredSize.width = size.width;
    this.preferredSize.height = size.height;

  },
  _computePreferredSize: function (forPrint) {
    var width = 0;
    var height = 0;
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT)
      || this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_COLOR)) {
      if (this.positions.getSize() >= 6) {
        var context = this.canvas.getContext('2d');
        var textWidth = morpheus.CanvasUtil.getVectorStringWidth(
          context, this.getVector(), this.positions,
          forPrint ? -1 : (this.isColumns ? 120 : 100));
        if (!forPrint) {
          textWidth = Math.min(textWidth, this.isColumns ? 100 : 500);
          this.settings.maxTextWidth = textWidth;
        }
        width += textWidth;
      } else if (!forPrint) {
        this.settings.maxTextWidth = 0; // text not drawn
      }
    }
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.BAR)) {
      width += this.settings.barSize;
    }
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.COLOR)) {
      width += this.settings.colorBarSize;
    }
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.SHAPE)) {
      width += this.settings.colorBarSize;
    }
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.MOLECULE)) {
      width += 300;
    }
    if (!forPrint && !this.isRenderAs(morpheus.VectorTrack.RENDER.MOLECULE)) {
      width = Math.min(300, width);
    }
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.ARC)) {
      width += this.settings.arcSize;
    }
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.BOX_PLOT)) {
      width += 100;
    }
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.HEAT_MAP)) {
      width += 100;
    }
    // 2 pixel spacing between display types
    var nkeys = _.keys(this.settings.render).length;

    if (nkeys > 0) {
      width += (nkeys - 1) * 2;
    }
    width = Math.max(0, width);
    return this.isColumns ? {
      width: height,
      height: width
    } : {
      width: width,
      height: height
    };

  },
  getPreferredSize: function () {
    return this.preferredSize;
  },
  getPrintSize: function () {
    return this._computePreferredSize(true);
  },
  _createDiscreteValueMap: function () {
    var values = morpheus.VectorUtil.getValues(this.getFullVector());
    values.sort(morpheus.SortKey.ASCENDING_COMPARATOR);
    this.discreteValueMap = new morpheus.Map();
    for (var i = 0, length = values.length; i < length; i++) {
      this.discreteValueMap.set(values[i], i + 1);
    }
    this.settings.min = 0;
    this.settings.mid = 0;
    this.settings.max = values.length;
  },
  _setChartMinMax: function () {
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.BAR)
      || this.isRenderAs(morpheus.VectorTrack.RENDER.BOX_PLOT)) {
      if (!this.settings.stackedBar && this.settings.discrete
        && !this.isRenderAs(morpheus.VectorTrack.RENDER.BOX_PLOT)) {
        if (!this.discreteValueMap) {
          this._createDiscreteValueMap();
        }
      } else {
        if (this.settings.autoscaleAlways || this.settings.min == null || this.settings.max == null
          || this.settings.mid == null) {
          var vector = this.getFullVector();

          var minMax = morpheus.VectorUtil.getMinMax(vector);
          var min = minMax.min;
          var max = minMax.max;
          if (this.settings.minMaxReversed) {
            var tmp = max;
            max = min;
            min = tmp;
          }
          if (this.settings.autoscaleAlways || this.settings.min == null) {
            this.settings.min = Math.min(0, min);
          }
          if (this.settings.autoscaleAlways || this.settings.max == null) {
            this.settings.max = Math.max(0, max);
          }
          if (this.settings.autoscaleAlways || this.settings.mid == null) {
            this.settings.mid = this.settings.min < 0 ? 0
              : this.settings.min;
          }
        }

      }
    }
  },

  _update: function () {
    if (!this.settings.discreteAutoDetermined
      && (this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_COLOR)
      || this.isRenderAs(morpheus.VectorTrack.RENDER.COLOR) || this
        .isRenderAs(morpheus.VectorTrack.RENDER.BAR))) {
      if (this.getFullVector().getProperties().has(
          morpheus.VectorKeys.FIELDS)
        || morpheus.VectorUtil.getDataType(this.getFullVector()) === 'number' || morpheus.VectorUtil.getDataType(this.getFullVector()) === '[number]') {
        this.settings.discrete = false;
        this.settings.highlightMatchingValues = false;
      }
      this.settings.discreteAutoDetermined = true;
    }
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.MOLECULE)) {
      this.project.off(this.events, this.updateSpanMapFunction);
    }
    this._setChartMinMax();
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.MOLECULE)) {
      this.project.on(this.events, this.updateSpanMapFunction);
      if (!this.moleculeCache) {
        this.moleculeCache = {};
        var _this = this;

        var valueToModelIndices = this.getFullVector().getProperties()
          .get(morpheus.VectorKeys.VALUE_TO_INDICES);
        if (!valueToModelIndices) {
          var fullVector = this.getFullVector();
          valueToModelIndices = morpheus.VectorUtil
            .createValueToIndicesMap(fullVector);
          fullVector.getProperties().set(
            morpheus.VectorKeys.VALUE_TO_INDICES,
            valueToModelIndices);

        }

        if (_this.heatmap.options.structureUrlProvider !== undefined) {
          valueToModelIndices.forEach(function (indices, value) {
            var url = _this.heatmap.options
              .structureUrlProvider(value);
            var image = new Image();
            image.src = url;
            _this.moleculeCache[value] = image;
          });

          setTimeout(function () {
            _this.setInvalid(true);
            _this.repaint();
          }, 2000);
        } else {
          var values = valueToModelIndices.keys();
          var doRequest = function (smile) {
            $
              .ajax(
                {
                  contentType: 'text/plain',
                  context: {
                    smile: smile
                  },
                  data: {
                    'string': smile,
                    'representation': 'sdf'
                  },
                  url: 'http://cactus.nci.nih.gov/chemical/structure',
                }).done(function (text) {
              _this.moleculeCache[this.smile] = text;
              if (values.length > 0) {
                doRequest(values.pop());
              }
              _this.invalid = true;
              _this.repaint();
            });
          };
          for (var i = 0; i < 6; i++) {
            doRequest(values.pop());
          }
        }
        this.updateSpanMapFunction();
      }
    }
    this._updatePreferredSize();
  },
  postPaint: function (clip, context) {
    // draw hover, matching values
    context.lineWidth = 1;
    context.strokeStyle = 'Grey';
    var project = this.project;
    var setup = this._setup(context, clip);
    var vector = setup.vector;
    var start = setup.start;
    var end = setup.end;

    // hover
    if (this.isColumns) {
      if (project.getHoverColumnIndex() !== -1) {
        this.drawColumnBorder(context, this.positions, project
          .getHoverColumnIndex(), this.getUnscaledHeight());

      }
    } else {
      if (project.getHoverRowIndex() !== -1) {
        this.drawRowBorder(context, this.positions, project
          .getHoverRowIndex(), this.getUnscaledWidth());
      }
    }
    this._highlightMatchingValues(context, vector, start, end);
  },
  _highlightMatchingValues: function (context, viewVector, start, end) {
    var project = this.project;
    var positions = this.positions;
    context.strokeStyle = 'black';
    context.lineWidth = 3;
    var hoverIndex = this.isColumns ? project.getHoverColumnIndex()
      : project.getHoverRowIndex();
    var value = viewVector.getValue(hoverIndex);

    if (this.settings.highlightMatchingValues
      && hoverIndex !== -1
      && this.heatmap.mousePositionOptions
      && this.heatmap.mousePositionOptions.name === viewVector
        .getName()) {
      var valueToModelIndices = this.getFullVector().getProperties().get(
        morpheus.VectorKeys.VALUE_TO_INDICES);
      if (!valueToModelIndices) {
        var fullVector = this.getFullVector();
        valueToModelIndices = morpheus.VectorUtil
          .createValueToIndicesMap(fullVector);
        fullVector.getProperties().set(
          morpheus.VectorKeys.VALUE_TO_INDICES,
          valueToModelIndices);

      }
      var indices = valueToModelIndices.get(value);
      if (indices == null) {
        console.log('valueToModelIndices error');
        return;
      }
      if (indices.length <= 1) {
        return;
      }
      if (this.isColumns) {
        if (project.getHoverColumnIndex() !== -1) {
          var height = this.getUnscaledHeight();
          // context.fillStyle = '#ffffb3';
          context.beginPath();
          for (var i = 0, nindices = indices.length; i < nindices; i++) {
            var viewIndex = project
              .convertModelColumnIndexToView(indices[i]);
            if (viewIndex >= start && viewIndex < end) {
              var size = positions.getItemSize(viewIndex);
              var pix = positions.getPosition(viewIndex);
              context.rect(pix, 0, size, height);
            }
          }
          context.stroke();

        }
      } else {
        context.beginPath();
        var width = this.getUnscaledWidth();
        var indices = valueToModelIndices.get(value);
        for (var i = 0, nindices = indices.length; i < nindices; i++) {
          var viewIndex = project
            .convertModelRowIndexToView(indices[i]);
          if (viewIndex >= start && viewIndex < end) {
            var size = positions.getItemSize(viewIndex);
            var pix = positions.getPosition(viewIndex);
            context.rect(0, pix, width, size);
          }
        }
        context.stroke();
      }

    }

  },
  drawSelection: function (options) {
    var project = this.project;
    var positions = this.positions;
    var context = options.context;
    var start = options.start;
    var end = options.end;
    context.lineWidth = 1;
    context.fillStyle = this.settings.selectionColor;
    if (this.isColumns) {
      var height = this.getUnscaledHeight();
      var viewIndices = project.getColumnSelectionModel()
        .getViewIndices();
      viewIndices.forEach(function (i) {
        if (i >= start && i <= end) {
          var size = positions.getItemSize(i);
          var pix = positions.getPosition(i);
          context.fillRect(pix, 0, size, height);
        }
      });
    } else {
      var width = this.getUnscaledWidth();
      if (!this.isRenderAs(morpheus.VectorTrack.RENDER.MOLECULE)) {
        var viewIndices = project.getRowSelectionModel()
          .getViewIndices();
        viewIndices.forEach(function (i) {
          if (i >= start && i <= end) {
            var size = positions.getItemSize(i);
            var pix = positions.getPosition(i);
            context.fillRect(0, pix, width, size);
          }
        });
      }
    }

  },
  prePaint: function (clip, context) {
    // draw selection
    var project = this.project;
    var positions = this.positions;
    var setup = this._setup(context, clip);
    var start = setup.start;
    var end = setup.end;
    this.drawSelection({
      context: context,
      start: start,
      end: end
    });
    if (this.invalid || start !== this.lastPosition.start
      || end !== this.lastPosition.end) {
      this.lastPosition.start = start;
      this.lastPosition.end = end;
      this.invalid = true;
    }
  },
  drawRowBorder: function (context, positions, index, gridSize) {
    var size = positions.getItemSize(index);
    var pix = positions.getPosition(index);
    // top and bottom lines
    context.beginPath();
    context.moveTo(0, pix + size);
    context.lineTo(gridSize, pix + size);
    context.stroke();
    context.beginPath();
    context.moveTo(0, pix);
    context.lineTo(gridSize, pix);
    context.stroke();
  },
  drawColumnBorder: function (context, positions, index, gridSize) {
    var size = positions.getItemSize(index);
    var pix = positions.getPosition(index);
    // top and bottom lines
    context.beginPath();
    context.moveTo(pix + size, 0);
    context.lineTo(pix + size, gridSize);
    context.stroke();
    context.beginPath();
    context.moveTo(pix, 0);
    context.lineTo(pix, gridSize);
    context.stroke();
  },
  isSquished: function () {
    return this.settings.squished;
  },
  _setup: function (context, clip) {
    var start = 0;
    var vector = this.getVector();
    var end = vector.size();
    var settings = this.settings;
    var positions = this.positions;
    var width = clip.width;
    var height = clip.height;
    if (!settings.squished) {
      if (this.isColumns) {
        start = morpheus.Positions.getLeft(clip, positions);
        end = morpheus.Positions.getRight(clip, positions);
      } else {
        start = morpheus.Positions.getTop(clip, positions);
        end = morpheus.Positions.getBottom(clip, positions);
      }
    }
    if (settings.squished) {

      var total = positions.getPosition(positions.getLength() - 1)
        + positions.getItemSize(positions.getLength() - 1);
      if (!this.isColumns) {
        var squishFactor = height / total;
        context.scale(1, squishFactor);
      } else {
        var squishFactor = width / total;
        context.scale(squishFactor, 1);
      }

    } else {
      context.translate(-clip.x, -clip.y);
    }
    return {
      start: start,
      end: end,
      vector: vector
    };
  },
  draw: function (clip, context) {
    var setup = this._setup(context, clip);
    this._draw({
      start: setup.start,
      end: setup.end,
      vector: setup.vector,
      context: context,
      availableSpace: this.isColumns ? this.getUnscaledHeight()
        : this.getUnscaledWidth(),
      clip: clip
    });
  },
  print: function (clip, context) {
    var vector = this.getVector();
    this._draw({
      start: 0,
      end: vector.size(),
      vector: vector,
      context: context,
      availableSpace: this.isColumns ? clip.height
        : clip.width,
      clip: clip
    });
  },
  /**
   * @param options.vector
   * @param options.context
   * @param options.start
   * @param options.end
   * @param options.availableSpace
   */
  _draw: function (options) {
    var _this = this;
    var context = options.context;
    var vector = options.vector;
    var availableSpace = options.availableSpace;
    var fullAvailableSpace = options.availableSpace;
    var start = options.start;
    var end = options.end;
    var clip = options.clip;
    var positions = this.positions;
    if (this.settings.autoscaleAlways) {
      this._setChartMinMax();
    }
    context.textAlign = 'left';
    context.fillStyle = morpheus.CanvasUtil.FONT_COLOR;

    var fontSize = Math.min(24, positions.getSize() - 2);
    var size = 0;
    context.font = fontSize + 'px ' + morpheus.CanvasUtil.FONT_NAME;
    context.strokeStyle = morpheus.HeatMapElementCanvas.GRID_COLOR;
    context.lineWidth = 0.1;
    // grid lines
    if (this.heatmap.heatmap.isDrawGrid() && !this.settings.squished) {
      if (this.isColumns) {
        var gridSize = availableSpace;
        context.beginPath();
        for (var i = start; i < end; i++) {
          var size = positions.getItemSize(i);
          var pix = positions.getPosition(i);
          if (size > 7) {
            context.moveTo(pix + size, 0);
            context.lineTo(pix + size, gridSize);
          }
        }
        context.stroke();
      } else {
        if (!this.isRenderAs(morpheus.VectorTrack.RENDER.MOLECULE)) {
          var gridSize = availableSpace;
          context.beginPath();
          for (var i = start; i < end; i++) {
            var size = positions.getItemSize(i);
            var pix = positions.getPosition(i);
            if (size > 7) {

              context.moveTo(0, pix + size);
              context.lineTo(gridSize, pix + size);

            }
          }
          context.stroke();
        }
      }
    }
    context.lineWidth = 1;
    var offset = 1;

    if (this.isRenderAs(morpheus.VectorTrack.RENDER.COLOR)) {
      this.renderColor(context, vector, start, end, clip,
        this.isColumns ? availableSpace : 0,
        !this.settings.discrete);
      offset += this.settings.colorBarSize + 2;
      availableSpace -= offset;
    }
    if (!this.settings.squished
      && this.isRenderAs(morpheus.VectorTrack.RENDER.SHAPE)) {
      this.renderShape(context, vector, start, end, clip,
        this.isColumns ? availableSpace - offset : offset);
      offset += this.settings.colorBarSize + 2;
      availableSpace -= offset;
    }

    if (this.isRenderAs(morpheus.VectorTrack.RENDER.ARC)) {
      this.renderArc(context, vector, start, end, clip,
        this.settings.arcSize);
      offset += this.settings.arcSize + 2;
      availableSpace -= offset;
    }
    if (!this.settings.squished
      && this.isRenderAs(morpheus.VectorTrack.RENDER.MOLECULE)) {
      this.renderMolecule(context, vector, start, end, clip, offset,
        availableSpace);
    }
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.BOX_PLOT)) {
      var barSize = !this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT) ? (availableSpace - 2)
        : this.settings.barSize;
      offset++;
      this.renderBoxPlot(context, vector, start, end, clip, offset,
        barSize);
      offset += barSize + 2;
      availableSpace -= offset;
    }
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.HEAT_MAP)) {
      var barSize = !this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT) ? (availableSpace - 2)
        : this.settings.barSize;
      offset++;
      this.renderHeatMap(context, vector, start, end, clip,
        barSize);
      offset += barSize + 2;
      availableSpace -= offset;
    }

    if (this.isRenderAs(morpheus.VectorTrack.RENDER.BAR)) {
      var barSize = !this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT) ? (availableSpace - 1)
        : this.settings.barSize;
      if (this.settings.stackedBar) {
        this.renderStackedBar(context, vector, start, end, clip,
          offset, barSize);
      } else {
        var fields = vector.getProperties().get(
          morpheus.VectorKeys.FIELDS);
        var visibleFieldIndices = vector.getProperties().get(
          morpheus.VectorKeys.VISIBLE_FIELDS);
        if (fields != null && visibleFieldIndices == null) {
          visibleFieldIndices = morpheus.Util.seq(fields.length);
        }

        if (fields != null) {
          this.renderUnstackedBar(context, vector, start, end, clip,
            offset, barSize, visibleFieldIndices);
        } else {
          this.renderBar(context, vector, start, end, clip, offset,
            barSize);
        }
      }
      offset += barSize + 2;
      availableSpace -= offset;
    }

    if (!this.settings.squished
      && this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_COLOR)) {
      context.fillStyle = morpheus.CanvasUtil.FONT_COLOR;
      this.renderText(context, vector, true, start, end, clip, offset,
        this.isColumns ? fullAvailableSpace : 0);
      offset += this.settings.maxTextWidth + 2;
      availableSpace -= offset;
    }
    this.textWidth = 0;
    if (!this.settings.squished
      && this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT)) {
      this.textWidth = availableSpace;
      context.fillStyle = morpheus.CanvasUtil.FONT_COLOR;
      var dataType = morpheus.VectorUtil.getDataType(vector);
      if (dataType === 'url') {
        context.fillStyle = 'blue';
        this.canvas.style.cursor = 'pointer';
      }
      this.renderText(context, vector, false, start, end, clip, offset,
        this.isColumns ? fullAvailableSpace : 0);
      offset += this.settings.textWidth + 2;
      availableSpace -= offset;
    }

  },
  showPopup: function (e, isHeader) {
    var _this = this;
    var project = this.project;
    var isColumns = this.isColumns;
    var hasSelection = isColumns ? project.getColumnSelectionModel()
      .count() > 0 : project.getRowSelectionModel().count() > 0;
    var ANNOTATE_SELECTION = 'Annotate Selection';
    var INVERT_SELECTION = 'Invert Selection';
    var SELECT_ALL = 'Select All';
    var SHOW_SELECTION_ONLY = 'Show Selection Only';
    var CLEAR_SELECTION = 'Clear Selection';
    var HIGHLIGHT_MATCHING_VALUES = 'Highlight Matching Values';
    var FIELDS = 'Choose Fields...';
    var DELETE = 'Delete...';
    var TOOLTIP = 'Show In Tooltip';
    var HIDE = 'Hide';
    var HIDE_OTHERS = 'Hide Others';
    var REMOVE_SHOW_SELECTION_ONLY = 'Show All';
    var SORT_ASC = 'Sort Ascending';
    var SORT_DESC = 'Sort Descending';
    var MOVE_TO_TOP = 'Move To Top';
    var SORT_SEL_ASC = 'Sort Heat Map Ascending \u2191';
    var SORT_SEL_DESC = 'Sort Heat Map Descending \u2193';
    var SORT_SEL_TOP_N = 'Sort Heat Map Descending/Ascending';
    var DISPLAY_BAR = 'Show Bar Chart';
    var DISPLAY_STACKED_BAR = 'Show Stacked Bar Chart';
    var DISPLAY_BOX_PLOT = 'Show Box Plot';
    var DISPLAY_COLOR = 'Show Color';
    var COLOR_BAR_SIZE = 'Color Bar Size...';
    var DISPLAY_TEXT = 'Show Text';
    var DISPLAY_SHAPE = 'Show Shape';
    var DISPLAY_ARC = 'Show Arc';
    var DISPLAY_TEXT_AND_COLOR = 'Show Colored Text';
    var DISPLAY_STRUCTURE = 'Show Chemical Structure';
    var DISPLAY_CONTINUOUS = 'Continuous';
    var positions = this.positions;
    var heatmap = this.heatmap;

    var sectionToItems = {
      'Sort': [],
      'Selection': [],
      'Display': []
    };

    var customItems = this.heatmap.getPopupItems();
    if (customItems && customItems.length > 0) {
      customItems.forEach(function (item) {
        if (item.columns === isColumns) {
          sectionToItems[item.section].push(item);
        }
      });
    }
    if (sectionToItems.Selection.length > 0) {
      sectionToItems.Selection.push({
        separator: true
      });
    }
    sectionToItems.Selection.push({
      name: MOVE_TO_TOP
    });

    if (sectionToItems.Selection.length > 0) {
      sectionToItems.Selection.push({
        separator: true
      });
    }
    sectionToItems.Selection.push({
      name: 'Copy',
      class: 'copy'
    });
    sectionToItems.Selection.push({
      separator: true
    });
    if (this.heatmap.options.menu.Edit && this.heatmap.options.menu.Edit.indexOf('Annotate' +
        ' Selected Rows') !== -1) {
      sectionToItems.Selection.push({
        name: ANNOTATE_SELECTION
      });
    }

    sectionToItems.Selection.push({
      name: INVERT_SELECTION
    });
    sectionToItems.Selection.push({
      name: SELECT_ALL
    });
    sectionToItems.Selection.push({
      name: CLEAR_SELECTION
    });
    // sectionToItems.Selection.push({
    // name : SHOW_SELECTION_ONLY
    // });
    var combinedFilter = isColumns ? project.getColumnFilter() : project
      .getRowFilter();
    var showSelectionOnlyIndex = combinedFilter
      .indexOf(SHOW_SELECTION_ONLY);
    if (showSelectionOnlyIndex !== -1) {
      sectionToItems.Selection.push({
        name: REMOVE_SHOW_SELECTION_ONLY
      });
    }

    if (!isHeader) {
      sectionToItems['Sort'].push({
        name: SORT_SEL_ASC,
        disabled: !hasSelection
      });
      sectionToItems['Sort'].push({
        name: SORT_SEL_DESC,
        disabled: !hasSelection
      });

      sectionToItems['Sort'].push({
        name: SORT_SEL_TOP_N,
        disabled: !hasSelection
      });
    }
    var dataType = morpheus.VectorUtil.getDataType(this.getFullVector());
    var arrayFields = this.getFullVector().getProperties().get(
      morpheus.VectorKeys.FIELDS);
    var isArray = arrayFields !== undefined;
    var isNumber = dataType === 'number' || dataType === '[number]';
    if (isNumber || isArray) {
      sectionToItems.Display.push({
        name: DISPLAY_BAR,
        checked: this.isRenderAs(morpheus.VectorTrack.RENDER.BAR)
      });
    }
    if (isArray) {
      sectionToItems.Display.push({
        name: DISPLAY_STACKED_BAR,
        checked: this.settings.stackedBar
      });
      sectionToItems.Display.push({
        name: DISPLAY_BOX_PLOT,
        checked: this.isRenderAs(morpheus.VectorTrack.RENDER.BOX_PLOT)
      });
      sectionToItems.Display.push({
        name: FIELDS,
      });

    }
    if (dataType !== 'url') {
      sectionToItems.Display.push({
        name: DISPLAY_TEXT,
        checked: this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT)
      });
      sectionToItems.Display.push({
        name: DISPLAY_COLOR,
        checked: this.isRenderAs(morpheus.VectorTrack.RENDER.COLOR)
      });
      if (this.isRenderAs(morpheus.VectorTrack.RENDER.COLOR)) {
        sectionToItems.Display.push({
          name: COLOR_BAR_SIZE
        });
      }
    }
    if (!isArray && dataType !== 'url') {
      sectionToItems.Display.push({
        name: DISPLAY_SHAPE,
        checked: this.isRenderAs(morpheus.VectorTrack.RENDER.SHAPE)
      });
      // sectionToItems.Display.push({
      // name : DISPLAY_ARC,
      // checked : this.isRenderAs(morpheus.VectorTrack.RENDER.ARC)
      // });

    }

    if (!isArray && !isNumber && !this.isColumns
      && name.toLowerCase().indexOf('smile') !== -1) {
      sectionToItems.Display.push({
        name: DISPLAY_STRUCTURE,
        checked: this.isRenderAs(morpheus.VectorTrack.RENDER.MOLECULE)
      });
    }

    sectionToItems.Display.push({
      name: TOOLTIP,
      checked: this.settings.inlineTooltip
    });
    if (!isArray && dataType !== 'url') {
      sectionToItems.Display.push({
        name: HIGHLIGHT_MATCHING_VALUES,
        checked: this.settings.highlightMatchingValues
      });
    }
    if (dataType !== 'url') {
      sectionToItems.Display.push({
        name: 'Squished',
        checked: this.settings.squished
      });
    }
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.BAR)
      || this.isRenderAs(morpheus.VectorTrack.RENDER.BOX_PLOT)) {
      sectionToItems.Display.push({
        separator: true
      });
      if (this.isRenderAs(morpheus.VectorTrack.RENDER.BAR)) {
        sectionToItems.Display.push({
          name: 'Edit Bar Color...'
        });
      }
      sectionToItems.Display.push({
        name: 'Auto Range'
      });
      sectionToItems.Display.push({
        name: 'Custom Range...'
      });
    }
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.COLOR)
      || this.isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_COLOR)
      || this.isRenderAs(morpheus.VectorTrack.RENDER.BAR)
      || this.isRenderAs(morpheus.VectorTrack.RENDER.SHAPE)) {
      sectionToItems.Display.push({
        separator: true
      });
      if (isNumber) {
        sectionToItems.Display.push({
          name: DISPLAY_CONTINUOUS,
          checked: !this.settings.discrete
        });
      }
      if (this.isRenderAs(morpheus.VectorTrack.RENDER.COLOR)
        || this
          .isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_COLOR)
        || (this.isRenderAs(morpheus.VectorTrack.RENDER.BAR) && isArray)) {
        sectionToItems.Display.push({
          name: 'Edit Colors...'
        });

      }
      if (this.isRenderAs(morpheus.VectorTrack.RENDER.SHAPE)) {
        sectionToItems.Display.push({
          name: 'Edit Shapes...'
        });

      }
      if (this.isRenderAs(morpheus.VectorTrack.RENDER.COLOR)
        || this
          .isRenderAs(morpheus.VectorTrack.RENDER.TEXT_AND_COLOR)
        || (this.isRenderAs(morpheus.VectorTrack.RENDER.BAR) && isArray)) {
        sectionToItems.Display.push({
          name: 'Color Key',
          icon: 'fa fa-key'
        });
      }

    }
    if (this.isRenderAs(morpheus.VectorTrack.RENDER.SHAPE)) {
      sectionToItems.Display.push({
        name: 'Shape Key',
        icon: 'fa fa-key'
      });
    }

    sectionToItems.Display.push({
      separator: true
    });
    sectionToItems.Display.push({
      name: HIDE
    });
    sectionToItems.Display.push({
      name: HIDE_OTHERS,
      disabled: heatmap.getVisibleTrackNames(this.isColumns).length <= 1

    });
    sectionToItems.Display.push({
      separator: true
    });
    sectionToItems.Display.push({
      name: DELETE
    });

    var items = [];

    function addSection(name) {
      if (items.length > 0) {
        items.push({
          separator: true
        });
      }
      items = items.concat(sectionToItems[name]);
    }

    addSection('Sort');
    _.each(sectionToItems.Selection, function (item) {
      if (item.name !== REMOVE_SHOW_SELECTION_ONLY
        && item.name !== SELECT_ALL) {
        item.disabled = !hasSelection;
      }
    });
    if (!isHeader) {
      addSection('Selection');
    } else if (this.heatmap.options.toolbar.options) {
      addSection('Display');
    }

    if (e.preventDefault) {
      e.preventDefault();
    }
    if (items.length === 0) {
      return;
    }
    morpheus.Popup
      .showPopup(
        items,
        {
          x: e.pageX,
          y: e.pageY
        },
        e.target,
        function (event, item) {
          var customItem;
          if (item === 'Copy') {
            heatmap.getActionManager().execute(isColumns ? 'Copy Selected Columns' : 'Copy' +
            ' Selected Rows');
          } else if (item === FIELDS) {
            var visibleFieldIndices = _this
              .getFullVector()
              .getProperties()
              .get(morpheus.VectorKeys.VISIBLE_FIELDS);
            var visibleFields;
            if (visibleFieldIndices == null) {
              visibleFields = arrayFields.slice(0);
            } else {
              visibleFields = [];
              for (var i = 0; i < visibleFieldIndices.length; i++) {
                visibleFields
                  .push(arrayFields[visibleFieldIndices[i]]);
              }

            }
            var availableFields = [];
            for (var i = 0; i < arrayFields.length; i++) {
              if (visibleFields.indexOf(arrayFields[i]) === -1) {
                availableFields.push(arrayFields[i]);
              }
            }

            var leftOptions = [];
            var rightOptions = [];
            for (var i = 0; i < availableFields.length; i++) {
              leftOptions.push(new Option(
                availableFields[i],
                availableFields[i]));
            }
            for (var i = 0; i < visibleFields.length; i++) {
              rightOptions
                .push(new Option(visibleFields[i],
                  visibleFields[i]));
            }

            var list = new morpheus.DualList(leftOptions,
              rightOptions);

            morpheus.FormBuilder
              .showOkCancel({
                title: 'Fields',
                okCallback: function () {
                  var visibleFields = list
                    .getOptions(false);
                  var visibleFieldIndices = [];
                  for (var i = 0; i < visibleFields.length; i++) {
                    visibleFieldIndices
                      .push(arrayFields
                        .indexOf(visibleFields[i]));
                  }
                  var fullVector = _this
                    .getFullVector();
                  fullVector
                    .getProperties()
                    .set(
                      morpheus.VectorKeys.VISIBLE_FIELDS,
                      visibleFieldIndices);

                  var summaryFunction = fullVector
                    .getProperties()
                    .get(
                      morpheus.VectorKeys.ARRAY_SUMMARY_FUNCTION);
                  if (summaryFunction) {
                    summaryFunction.indices = visibleFieldIndices;
                  }
                  var updatedVector = _this.isColumns ? _this.project
                    .getFullDataset()
                    .getColumnMetadata()
                    .add(_this.name)
                    : _this.project
                    .getFullDataset()
                    .getRowMetadata()
                    .add(_this.name);
                  // remove cached summary field
                  for (var i = 0; i < updatedVector
                    .size(); i++) {
                    var array = fullVector
                      .getValue(i);
                    if (array != null) {
                      array.summary = undefined;
                    }

                  }

                  _this.setInvalid(true);
                  _this.repaint();
                },
                content: list.$el
              });
          } else if (item === 'Edit Bar Color...') {
            var formBuilder = new morpheus.FormBuilder();
            formBuilder.append({
              name: 'bar_color',
              type: 'color',
              value: _this.settings.barColor,
              required: true,
              col: 'col-xs-2'
            });
            formBuilder.find('bar_color').on(
              'change',
              function () {
                _this.settings.barColor = $(this)
                  .val();
                _this.setInvalid(true);
                _this.repaint();
              });
            morpheus.FormBuilder.showInModal({
              title: 'Bar Color',
              close: 'Close',
              html: formBuilder.$form
            });
          } else if (item === COLOR_BAR_SIZE) {
            var formBuilder = new morpheus.FormBuilder();
            formBuilder.append({
              name: 'size',
              type: 'text',
              value: _this.settings.colorBarSize,
              required: true,
              col: 'col-xs-2'
            });
            formBuilder.find('size').on(
              'change',
              function () {
                var val = parseFloat($(this)
                  .val());
                if (val > 0) {
                  _this.settings.colorBarSize = val;
                  _this.setInvalid(true);
                  _this.repaint();
                }
              });
            morpheus.FormBuilder.showInModal({
              title: 'Color Bar Size',
              close: 'Close',
              html: formBuilder.$form
            });
          } else if (item === ANNOTATE_SELECTION) {
            heatmap.getActionManager().execute(isColumns ? 'Annotate Selected Columns' : 'Annotate' +
            ' Selected Rows');
          } else if (item === DELETE) {
            morpheus.FormBuilder
              .showOkCancel({
                title: 'Delete',
                content: 'Are you sure you want to delete '
                + _this.name + '?',
                okCallback: function () {
                  var metadata = isColumns ? project
                    .getFullDataset()
                    .getColumnMetadata()
                    : project
                    .getFullDataset()
                    .getRowMetadata();
                  metadata
                    .remove(morpheus.MetadataUtil
                      .indexOf(
                        metadata,
                        _this.name));
                  var sortKeys = isColumns ? project
                    .getColumnSortKeys()
                    : project
                    .getRowSortKeys();
                  var sortKeyIndex = _.indexOf(
                    sortKeys.map(function (key) {
                      return key.field;
                    }), _this.name);
                  if (sortKeyIndex !== -1) {
                    sortKeys.splice(
                      sortKeyIndex, 1);
                    if (isColumns) {
                      project
                        .setColumnSortKeys(
                          sortKeys,
                          true);
                    } else {
                      project.setRowSortKeys(
                        sortKeys, true);
                    }
                  }
                  var groupByKeys = isColumns ? project
                    .getGroupColumns()
                    : project
                    .getGroupRows();
                  var groupByKeyIndex = _
                    .indexOf(
                      groupByKeys
                        .map(function (key) {
                          return key.field;
                        }),
                      _this.name);
                  if (groupByKeyIndex !== -1) {
                    groupByKeys.splice(
                      groupByKeyIndex, 1);
                    if (isColumns) {
                      project
                        .setGroupColumns(
                          groupByKeys,
                          true);
                    } else {
                      project.setGroupRows(
                        groupByKeys,
                        true);
                    }
                  }
                  if (!isColumns) {
                    // remove from any group
                    // by or sort by
                    project
                      .trigger(
                        'rowTrackRemoved',
                        {
                          vector: _this
                            .getFullVector()
                        });
                  } else {
                    project
                      .trigger(
                        'columnTrackRemoved',
                        {
                          vector: _this
                            .getFullVector()
                        });
                  }
                }
              });
          } else if (item === CLEAR_SELECTION) {
            heatmap.getActionManager().execute(isColumns ? 'Clear Selected Columns' : 'Clear' +
            ' Selected Rows');
          } else if (item === INVERT_SELECTION) {
            heatmap.getActionManager().execute(isColumns ? 'Invert Selected Columns' : 'Invert' +
            ' Selected Rows');
          } else if (item === MOVE_TO_TOP) {
            heatmap.getActionManager().execute(isColumns ? 'Move Selected Columns To Top' : 'Move' +
            ' Selected Rows To Top');
          } else if (item === SORT_ASC || item === SORT_DESC) {
            var sortKey = new morpheus.SortKey(
              _this.name,
              item === SORT_ASC ? morpheus.SortKey.SortOrder.ASCENDING
                : morpheus.SortKey.SortOrder.DESCENDING);
            if (_this.isColumns) {
              _this.project
                .setColumnSortKeys(
                  morpheus.SortKey
                    .keepExistingSortKeys(
                      [sortKey],
                      project
                        .getColumnSortKeys()),
                  true);
            } else {
              _this.project
                .setRowSortKeys(
                  morpheus.SortKey
                    .keepExistingSortKeys(
                      [sortKey],
                      project
                        .getRowSortKeys()),
                  true);
            }
          } else if (item == SORT_SEL_ASC
            || item == SORT_SEL_DESC
            || item === SORT_SEL_TOP_N) {
            var sortOrder;
            if (item === SORT_SEL_ASC) {
              sortOrder = morpheus.SortKey.SortOrder.ASCENDING;
            } else if (item === SORT_SEL_DESC) {
              sortOrder = morpheus.SortKey.SortOrder.DESCENDING;
            } else {
              sortOrder = morpheus.SortKey.SortOrder.TOP_N;
            }
            heatmap.sortBasedOnSelection(sortOrder,
              isColumns, e && e.shiftKey);
          } else if (item === SELECT_ALL) {
            heatmap.getActionManager().execute(isColumns ? 'Select All Columns' : 'Select All Rows');
          } else if (item === 'Auto Range') {
            delete _this.settings.min;
            delete _this.settings.max;
            delete _this.settings.mid;
            _this._update();
            heatmap.revalidate();
          } else if (item === 'Custom Range...') {
            var formBuilder = new morpheus.FormBuilder();
            var items = [{
              name: 'min',
              required: true,
              type: 'number',
              value: _this.settings.min
            }, {
              name: 'mid',
              required: true,
              type: 'number',
              value: _this.settings.mid
            }, {
              name: 'max',
              required: true,
              type: 'number',
              value: _this.settings.max
            }];
            _.each(items, function (item) {
              formBuilder.append(item);
            });
            morpheus.FormBuilder
              .showOkCancel({
                title: 'Range',
                content: formBuilder.$form,
                okCallback: function () {
                  _this.settings.min = parseFloat(formBuilder
                    .getValue('min'));
                  _this.settings.mid = parseFloat(formBuilder
                    .getValue('mid'));
                  _this.settings.max = parseFloat(formBuilder
                    .getValue('max'));
                  _this._update();
                  heatmap.revalidate();
                }
              });
          } else if (item === 'Squished') {
            _this.settings.squished = !_this.settings.squished;
            heatmap.revalidate();
          } else if (item === 'Color Key') {

            var legend = new morpheus.HeatMapTrackColorLegend(
              [_this], isColumns ? _this.project
                .getColumnColorModel()
                : _this.project
                .getRowColorModel());
            var size = legend.getPreferredSize();
            legend.setBounds(size);
            legend.repaint();

            morpheus.FormBuilder.showInModal({
              title: 'Color Key',
              html: legend.canvas
            });
          } else if (item === 'Shape Key') {
            var legend = new morpheus.HeatMapTrackShapeLegend(
              [_this], isColumns ? _this.project
                .getColumnShapeModel()
                : _this.project
                .getRowShapeModel());
            var size = legend.getPreferredSize();
            legend.setBounds(size);
            legend.repaint();

            morpheus.FormBuilder.showInModal({
              title: 'Shape Key',
              html: legend.canvas
            });
          } else if (item === 'Edit Shapes...') {
            var shapeFormBuilder = new morpheus.FormBuilder();
            var shapeModel = isColumns ? _this.project
              .getColumnShapeModel() : _this.project
              .getRowShapeModel();
            var chooser = new morpheus.ShapeChooser({
              map: shapeModel.getMap(_this.name)
            });

            chooser.on('change', function (event) {
              shapeModel.setMappedValue(_this
                  .getFullVector(), event.value,
                event.shape);
              _this.setInvalid(true);
              _this.repaint();
            });
            morpheus.FormBuilder.showInModal({
              title: 'Edit Shapes',
              html: chooser.$div,
              close: 'Close'
            });
          } else if (item === 'Edit Colors...') {
            var colorSchemeChooser;
            var colorModel = isColumns ? _this.project
              .getColumnColorModel() : _this.project
              .getRowColorModel();
            if (_this.settings.discrete) {
              colorSchemeChooser = new morpheus.DiscreteColorSchemeChooser(
                {
                  colorScheme: {
                    scale: colorModel
                      .getDiscreteColorScheme(_this
                        .getFullVector())
                  }
                });
              colorSchemeChooser.on('change', function (event) {
                colorModel.setMappedValue(_this
                    .getFullVector(), event.value,
                  event.color);
                _this.setInvalid(true);
                _this.repaint();
              });
            } else {
              colorSchemeChooser = new morpheus.HeatMapColorSchemeChooser(
                {
                  showRelative: false,
                });
              colorSchemeChooser
                .setColorScheme(colorModel
                  .getContinuousColorScheme(_this
                    .getFullVector()));
              colorSchemeChooser.on('change', function (event) {
                _this.setInvalid(true);
                _this.repaint();
              });
            }
            morpheus.FormBuilder.showInModal({
              title: 'Edit Colors',
              html: colorSchemeChooser.$div,
              close: 'Close',
              onClose: function () {
                colorSchemeChooser.dispose();
              }
            });
          } else if (item === TOOLTIP) {
            _this.settings.inlineTooltip = !_this.settings.inlineTooltip;
          } else if (item === HIGHLIGHT_MATCHING_VALUES) {
            _this.settings.highlightMatchingValues = !_this.settings.highlightMatchingValues;
          } else if ((customItem = _
              .find(
                customItems,
                function (customItem) {
                  return customItem.name === item
                    && customItem.columns === isColumns;
                }))) {
            if (customItem.task) {
              // add task
              var task = {
                tabId: _this.heatmap.getTabManager()
                  .getActiveTabId()
              };

              _this.heatmap.getTabManager().addTask(task);
              setTimeout(function () {
                customItem.callback(heatmap);
                _this.heatmap.getTabManager()
                  .removeTask(task);
              }, 1);
            } else {
              customItem.callback(heatmap);
            }

          } else if (item === DISPLAY_CONTINUOUS) {
            _this.settings.discrete = !_this.settings.discrete;
            _this._setChartMinMax();
            _this.setInvalid(true);
            _this.repaint();
          } else if (item === HIDE) {
            heatmap.setTrackVisible(_this.name, false,
              _this.isColumns);
            heatmap.revalidate();
          } else if (item === HIDE_OTHERS) {
            var names = heatmap.getVisibleTrackNames(_this.isColumns);
            for (var i = 0; i < names.length; i++) {
              if (names[i] !== _this.name) {
                heatmap.setTrackVisible(names[i], false,
                  _this.isColumns);
              }
            }

            heatmap.revalidate();

          } else if (item === DISPLAY_STACKED_BAR) {
            _this.settings.stackedBar = !_this.settings.stackedBar;
            _this._update();
            heatmap.revalidate();
          } else {
            if (item === DISPLAY_BAR) {
              item = morpheus.VectorTrack.RENDER.BAR;
            } else if (item === DISPLAY_COLOR) {
              item = morpheus.VectorTrack.RENDER.COLOR;
            } else if (item === DISPLAY_TEXT) {
              item = morpheus.VectorTrack.RENDER.TEXT;
            } else if (item === DISPLAY_TEXT_AND_COLOR) {
              item = morpheus.VectorTrack.RENDER.TEXT_AND_COLOR;
            } else if (item === DISPLAY_STRUCTURE) {
              item = morpheus.VectorTrack.RENDER.MOLECULE;
            } else if (item === DISPLAY_SHAPE) {
              item = morpheus.VectorTrack.RENDER.SHAPE;
            } else if (item === DISPLAY_ARC) {
              item = morpheus.VectorTrack.RENDER.ARC;
            } else if (item === DISPLAY_BOX_PLOT) {
              item = morpheus.VectorTrack.RENDER.BOX_PLOT;
            } else {
              console.log('Unknown item ' + item);
            }
            var show = !_this.isRenderAs(item);
            if (!show) {
              delete _this.settings.render[item];
            } else {
              _this.settings.render[item] = true;
            }
            _this._update();
            heatmap.revalidate();
          }
        });
  },
  renderColor: function (context, vector, start, end, clip, offset, continuous) {
    var isColumns = this.isColumns;
    var positions = this.positions;
    var colorModel = isColumns ? this.project.getColumnColorModel() : this.project.getRowColorModel();
    var settings = this.settings;
    var canvasSize = isColumns ? this.getUnscaledHeight() : this.getUnscaledWidth();
    var colorBarSize = settings.colorBarSize;
    if (colorBarSize > canvasSize) {
      colorBarSize = canvasSize >= 5 ? (canvasSize - 1)
        : canvasSize;
    }
    var getColor;
    if (!continuous) {
      getColor = _.bind(colorModel.getMappedValue, colorModel);
    } else {
      getColor = _.bind(colorModel.getContinuousMappedValue, colorModel);
    }

    if (vector.getProperties().get(
        morpheus.VectorKeys.FIELDS) != null) {
      var visibleFieldIndices = vector.getProperties().get(
        morpheus.VectorKeys.VISIBLE_FIELDS);
      if (visibleFieldIndices == null) {
        visibleFieldIndices = morpheus.Util.seq(vector.getProperties().get(
          morpheus.VectorKeys.FIELDS).length);
      }
      colorBarSize /= visibleFieldIndices.length;
      var nvisibleFieldIndices = visibleFieldIndices.length;

      for (var i = start; i < end; i++) {
        var array = vector.getValue(i);
        var position = positions.getPosition(i);
        var size = positions.getItemSize(i);
        var _offset = offset;
        if (array != null) {
          for (var j = 0; j < nvisibleFieldIndices; j++) {
            var value = array[visibleFieldIndices[j]];
            var color = getColor(vector, value);
            context.fillStyle = color;
            if (isColumns) {
              context.beginPath();
              context.rect(position, _offset - colorBarSize, size,
                colorBarSize);
              context.fill();
            } else {
              context.beginPath();
              context.rect(_offset, position, colorBarSize, size);
              context.fill();
            }
            _offset += colorBarSize;
          }
        }

      }

    } else {
      for (var i = start; i < end; i++) {
        var value = vector.getValue(i);
        var position = positions.getPosition(i);
        var size = positions.getItemSize(i);
        var color = getColor(vector, value);
        context.fillStyle = color;
        if (isColumns) {
          context.beginPath();
          context.rect(position, offset - colorBarSize, size,
            settings.colorBarSize);
          context.fill();
        } else {
          context.beginPath();
          context.rect(offset, position, colorBarSize, size);
          context.fill();
        }
      }
    }
  },
  renderShape: function (context, vector, start, end, clip, offset) {
    var isColumns = this.isColumns;
    var positions = this.positions;
    var shapeModel = isColumns ? this.project.getColumnShapeModel()
      : this.project.getRowShapeModel();
    var settings = this.settings;
    var canvasSize = isColumns ? this.getUnscaledHeight() : this
      .getUnscaledWidth();
    var colorBarSize = settings.colorBarSize;
    if (colorBarSize > canvasSize) {
      colorBarSize = canvasSize >= 5 ? (canvasSize - 1)
        : canvasSize;
    }
    context.fillStyle = 'black';
    context.strokeStyle = 'black';

    var lineWidth = context.lineWidth;
    context.lineWidth = 1;
    for (var i = start; i < end; i++) {

      var value = vector.getValue(i);
      var position = positions.getPosition(i);
      var itemSize = positions.getItemSize(i);
      var minSize = Math.min(colorBarSize, itemSize);
      var size2 = minSize / 2;
      var shape = shapeModel.getMappedValue(vector, value);
      // x and y are at center
      var x = isColumns ? position + itemSize / 2 : offset + size2;
      var y = isColumns ? offset - size2 : position + itemSize / 2;
      size2 -= 0.5; // small border between cells
      morpheus.CanvasUtil.drawShape(context, shape, x, y, size2);
    }
    context.lineWidth = lineWidth;
  },
  renderHeatMap: function (context, vector, start, end, clip, size) {
    var isColumns = this.isColumns;
    var positions = this.positions;
    var project = this.project;
    context.save();
    context.lineWidth = 1;
    //	context.translate(clip.x, clip.y);
    var width = clip.width;
    var height = clip.height;
    var colorScheme = this.heatmap.getHeatMapElementComponent().getColorScheme();
    var drawGrid = this.heatmap.getHeatMapElementComponent().isDrawGrid();
    var gridColor = this.heatmap.getHeatMapElementComponent().getGridColor();
    var gridThickness = this.heatmap.getHeatMapElementComponent().getGridThickness();
    for (var i = start; i < end; i++) {
      var value = vector.getValue(i); // value is an array of values to render as a heat map
      if (value != null) {
        var pix = positions.getPosition(i);
        var itemSize = positions.getItemSize(i);
        var currentPix = 0;
        var nvalues = value.length;
        var pixPer = size / nvalues;
        for (var j = 0; j < nvalues; j++) {
          var val = value[j];
          context.fillStyle = colorScheme.getColor(i, -1, val);
          context.fillRect(j * pixPer, pix, pixPer, itemSize);
        }
        if (drawGrid && itemSize > 10) {
          context.strokeStyle = gridColor;
          context.lineWidth = gridThickness;
          context.beginPath();
          for (var j = 0; j < nvalues; j++) {
            var val = value[j];
            context.rect(j * pixPer, pix, pixPer, itemSize);
          }
          context.stroke();

        }
      }

    }

    context.restore();
  },
  renderArc: function (context, vector, start, end, clip, size) {

    var isColumns = this.isColumns;
    var positions = this.positions;
    var project = this.project;
    context.save();
    context.lineWidth = 1;
    // var scale = d3.scale.linear().domain([1, size]).range([0.8, 1])
    // .clamp(true);
    // var fill = d3.scale.category20b();

    var total = positions.getPosition(positions.getLength() - 1)
      + positions.getItemSize(positions.getLength() - 1);
    context.translate(clip.x, clip.y);
    var width = clip.width;
    var height = clip.height;
    // if (!isColumns) {
    // 	var squishFactor = height / total;
    // 	context.scale(1, squishFactor);
    // } else {
    // 	var squishFactor = width / total;
    // 	context.scale(squishFactor, 1);
    // }

    for (var i = start; i < end; i++) {
      var value = vector.getValue(i); // value is an array of other indices to link to
      if (value != null) {
        var startPix = positions.getPosition(i) + positions.getItemSize(i)
          / 2;
        for (var j = 0, nindices = value.length; j < nindices; j++) {
          var viewIndex = value[j];
          var endPix = positions.getPosition(viewIndex)
            + positions.getItemSize(viewIndex) / 2;
          var midPix = (endPix + startPix) / 2;
          var distance = Math.abs(i - viewIndex);
          var arcRadius = size; // scale(distance) * size;
          if (isColumns) {
            context.beginPath();
            context.moveTo(startPix, arcRadius);
            context.quadraticCurveTo(midPix, 1, endPix, arcRadius);
          } else {
            console.log(i, viewIndex, startPix, endPix);
            context.beginPath();
            context.moveTo(1, startPix);
            context.quadraticCurveTo(arcRadius, midPix, 1, endPix);
          }

          context.stroke();

        }
      }

    }
    context.restore();
  },
  sdfToSvg: function (sdf, width, height) {
    if (!this.jsme && typeof JSApplet !== 'undefined') {
      this.jsmeId = _.uniqueId('m');
      this.$jsmeDiv = $(
        '<div id="'
        + this.jsmeId
        + '" style="position:absolute;left:-10000px;top:-10000px;"></div>')
        .appendTo($(document.body));
      this.jsme = new JSApplet.JSME(this.jsmeId, '380px', '340px', {});
    }
    // this.$jsmeDiv.css('width', width + 'px').css('height', height +
    // 'px');
    // this.jsme.setSize(width + 'px', height + 'px');
    this.jsme.readMolFile(sdf);
    var svg = $('#' + this.jsmeId + ' > div > div > div:nth-child(2) > svg');
    var svgWidth = svg.width.baseVal.value;
    var svgHeight = svg.height.baseVal.value;
    var scale = Math.min(width / svgWidth, height / svgHeight);
    var text = '<svg><g transform="scale(' + scale + ')">' + svg.innerHTML
      + '</g></svg>';
    return text;
  },
  renderMolecule: function (context, vector, start, end, clip, offset) {
    var isColumns = this.isColumns;
    var positions = this.positions;
    context.fillStyle = morpheus.CanvasUtil.FONT_COLOR;
    context.strokeStyle = 'black';
    var width = this.getUnscaledWidth();
    var customUrlProvider = this.heatmap.options.structureUrlProvider !== undefined;
    var dummyTarget = {
      childNodes: [],
      getContext: function () {
        return context;
      }
    };
    for (var i = start; i < end; i++) {
      var spanEnd = this.spanMap.get(i);
      if (spanEnd !== undefined) {
        var startPix = positions.getPosition(i);
        var endPix = positions.getPosition(spanEnd - 1)
          + positions.getSize();
        var size = endPix - startPix;
        var value = vector.getValue(i);
        var cache = this.moleculeCache[value];
        if (cache) {
          if (customUrlProvider) {
            if (cache.complete) {
              // 800 x 400
              var scaleFactor = Math.min(size / cache.height,
                width / cache.width);
              var scaledWidth = cache.width * scaleFactor;
              var scaledHeight = cache.height * scaleFactor;
              var diff = cache.height - scaledHeight;
              startPix += diff / 2;
              try {
                context.drawImage(cache, offset, startPix,
                  scaledWidth, scaledHeight);
              }
              catch (x) {

              }
            }
          } else {
            var text = this.sdfToSvg(cache, width, size);
            canvg(dummyTarget, text, {
              ignoreMouse: true,
              ignoreAnimation: true,
              offsetY: startPix,
              ignoreClear: true,
              ignoreDimensions: true
            });
          }
        }
      }
    }
  },
  createChartScale: function (availableSpace) {
    var domain;
    var range;
    if (this.settings.mid !== this.settings.min
      && this.settings.mid !== this.settings.max) {
      domain = [this.settings.min, this.settings.mid, this.settings.max];
      range = this.isColumns ? [availableSpace, availableSpace / 2, 0]
        : [0, availableSpace / 2, availableSpace];
    } else {
      domain = [this.settings.min, this.settings.max];
      range = this.isColumns ? [availableSpace, 0] : [0,
        availableSpace];
    }
    var scale = d3.scale.linear().domain(domain).range(range).clamp(true);
    return scale;
  },
  renderBar: function (context, vector, start, end, clip, offset, availableSpace) {
    var isColumns = this.isColumns;
    var positions = this.positions;
    context.fillStyle = this.settings.barColor;
    var scale = this.createChartScale(availableSpace);
    var midPix = scale(this.settings.mid);
    var settings = this.settings;
    var discrete = settings.discrete && this.discreteValueMap != null;
    for (var i = start; i < end; i++) {
      var value = vector.getValue(i);
      if (discrete) {
        value = this.discreteValueMap.get(value);
      }
      var position = positions.getPosition(i);
      var size = positions.getItemSize(i);
      var scaledValue = scale(value);
      if (isColumns) {
        context.beginPath();
        context.rect(position, Math.min(midPix, scaledValue), size,
          Math.abs(midPix - scaledValue));
        context.fill();
      } else {
        context.beginPath();
        context.rect(offset + Math.min(midPix, scaledValue), position,
          Math.abs(midPix - scaledValue), size);
        context.fill();
      }
    }
  },
  renderBoxPlot: function (context, vector, start, end, clip, offset, availableSpace) {
    var isColumns = this.isColumns;
    var positions = this.positions;
    context.strokeStyle = 'black';
    context.save();
    context.translate(offset, 0);
    var scale = this.createChartScale(availableSpace);
    var visibleFieldIndices = vector.getProperties().get(
      morpheus.VectorKeys.VISIBLE_FIELDS);

    var colorByVector = this.settings.colorByField != null ? this
      .getVector(this.settings.colorByField) : null;
    var colorModel = isColumns ? this.project.getColumnColorModel()
      : this.project.getRowColorModel();
    for (var i = start; i < end; i++) {
      var array = vector.getValue(i);
      if (array != null) {
        var itemSize = positions.getItemSize(i);
        if (itemSize <= 3) {
          continue;
        }
        var radius = 2;
        var pix = positions.getPosition(i);
        var start = pix + 1;
        var end = pix + itemSize - 1;
        var center = (start + end) / 2;
        var _itemSize = itemSize - 2;
        var lineHeight = Math.max(2, _itemSize - 8);
        var box = array.summary;
        if (box == null) {
          var v = morpheus.VectorUtil.arrayAsVector(array);
          box = morpheus
            .BoxPlotItem(visibleFieldIndices != null ? new morpheus.SlicedVector(
              v, visibleFieldIndices)
              : v);
          array.summary = box;
        }
        context.fillStyle = '#bdbdbd';

        if (!isColumns) {
          // box from q1 (25th q) to q3
          context.fillRect(Math.min(scale(box.q1), scale(box.q3)),
            start, Math.abs(scale(box.q1) - scale(box.q3)),
            _itemSize);
          // draw line from q1 to lav
          context.fillRect(Math.min(scale(box.q1),
            scale(box.lowerAdjacentValue)), center - lineHeight
            / 2, Math.abs(scale(box.q1)
            - scale(box.lowerAdjacentValue)), lineHeight);
          // draw line from q3 to uav
          context.fillRect(Math.min(scale(box.q3),
            scale(box.upperAdjacentValue)), center - lineHeight
            / 2, Math.abs(scale(box.q3)
            - scale(box.upperAdjacentValue)), lineHeight);
          context.fillStyle = '#31a354';
          // highlight median
          context.fillRect(scale(box.median) - 3, start, 3, end - start);
          context.fillStyle = '#636363';

          // draw individual points
          // for (var j = 0, length = visibleFieldIndices == null ? array.length : visibleFieldIndices.length; j < length; j++) {
          // 	var index = visibleFieldIndices == null ? j : visibleFieldIndices[j];
          // 	var value = array[index];
          // 	if (value != null) {
          // 		if (colorByVector != null) {
          // 			var colorByArray = colorByVector.getValue(i);
          // 			if (colorByArray != null) {
          // 				var color = colorModel
          // 				.getMappedValue(
          // 					colorByVector,
          // 					colorByArray[index]);
          // 				context.fillStyle = color;
          // 			} else {
          // 				context.fillStyle = '#636363';
          // 			}
          //
          // 		}
          // 		var pix = scale(value);
          // 		context.beginPath();
          // 		context
          // 		.arc(pix, center, radius, Math.PI * 2,
          // 			false);
          // 		context.fill();
          // 	}
          // }

        } else { // TOD implement for columns

        }

      }
    }
    context.restore();
  },
  renderStackedBar: function (context, vector, start, end, clip, offset, availableSpace) {
    var isColumns = this.isColumns;
    var positions = this.positions;
    var scale = this.createChartScale(availableSpace);
    var midPix = scale(this.settings.mid);
    var settings = this.settings;
    var colorModel = isColumns ? this.project.getColumnColorModel()
      : this.project.getRowColorModel();
    context.strokeStyle = 'black';
    context.lineWidth = 2;
    for (var i = start; i < end; i++) {
      var array = vector.getValue(i);
      if (array != null) {
        var position = positions.getPosition(i);
        var size = positions.getItemSize(i);
        var positivePairs = [];
        var negativePairs = [];
        for (var j = 0, length = array.length; j < length; j++) {
          var value = array[j];
          if (value >= this.settings.mid) {
            positivePairs.push({
              value: value,
              index: j
            });
          } else if (value < 0) {
            negativePairs.push({
              value: value,
              index: j
            });
          }
        }

        // array.sort(function (a, b) {
        // 	return (a.value < b.value ? 1 : (a.value === b.value ? 0 : -1));
        // });
        // var positiveIndices = [];
        // positivePairs.forEach(function (item) {
        // 	positiveIndices.push(item.index);
        // });
        //
        var positiveIndices = morpheus.Util.indexSortPairs(
          positivePairs, false);
        for (var j = 0, length = positiveIndices.length; j < length; j++) {
          var index = positiveIndices[j];
          var value = array[index];
          var color = colorModel.getMappedValue(vector, index);
          context.fillStyle = color;
          var scaledValue = scale(value);
          var nextScaledValue = j === (length - 1) ? midPix
            : scale(array[positiveIndices[j + 1]]);
          if (isColumns) {
            context.beginPath();
            context.rect(position, Math.min(nextScaledValue,
              scaledValue), size, Math.abs(nextScaledValue
              - scaledValue));
            context.fill();
          } else {
            context.beginPath();
            context.rect(offset
              + Math.min(nextScaledValue, scaledValue),
              position, Math.abs(nextScaledValue
                - scaledValue), size);
            context.fill();
          }
        }
        var negativeIndices = morpheus.Util.indexSortPairs(
          negativePairs, true); // draw smaller (more negative)
        // values 1st
        for (var j = 0, length = negativeIndices.length; j < length; j++) {
          var index = negativeIndices[j];
          var value = array[index];
          var color = colorModel.getMappedValue(vector, index);
          context.fillStyle = color;
          var scaledValue = scale(value);
          var nextScaledValue = j === (length - 1) ? midPix
            : scale(array[negativeIndices[j + 1]]);
          if (isColumns) {
            context.beginPath();
            context.rect(position, Math.min(nextScaledValue,
              scaledValue), size, Math.abs(nextScaledValue
              - scaledValue));
            context.fill();
          } else {
            context.beginPath();
            context.rect(offset
              + Math.min(nextScaledValue, scaledValue),
              position, Math.abs(nextScaledValue
                - scaledValue), size);
            context.fill();
          }

        }
      }
    }
    context.lineWidth = 1;
  },
  renderUnstackedBar: function (context, vector, start, end, clip, offset, availableSpace, fieldIndices) {
    var isColumns = this.isColumns;
    var positions = this.positions;
    var nvalues = fieldIndices.length;
    var settings = this.settings;
    var colorModel = isColumns ? this.project.getColumnColorModel()
      : this.project.getRowColorModel();
    context.fillStyle = this.settings.barColor;
    // context.strokeStyle = '0000f0';
    var barSpacer = 0;
    var barWidth = (availableSpace - (nvalues - 1) * barSpacer) / nvalues;
    var colorByVector = this.settings.colorByField != null ? this
      .getVector(this.settings.colorByField) : null;
    context.strokeStyle = 'white';
    for (var i = start; i < end; i++) {
      var array = vector.getValue(i);
      if (array != null) {
        var position = positions.getPosition(i);
        var itemSize = positions.getItemSize(i);
        var scale = this.createChartScale(itemSize - 1);
        var midPix = scale(this.settings.mid); // need to set mid pix
        // for each item
        var xpix = 0;
        for (var j = 0; j < nvalues; j++) {
          var value = array[fieldIndices[j]];
          if (colorByVector != null) {
            var colorByArray = colorByVector.getValue(i);
            var color = colorModel
              .getMappedValue(
                colorByVector,
                colorByArray != null ? colorByArray[fieldIndices[j]]
                  : null);
            context.fillStyle = color;
          }

          var scaledValue = scale(value);

          if (isColumns) {
            context.beginPath();
            context.rect(Math.min(midPix, scaledValue), offset
              + xpix, Math.abs(midPix - scaledValue),
              barWidth);
            context.fill();
          } else {
            // bar always goes to midpix
            context.beginPath();
            var barHeight = Math.abs(midPix - scaledValue);
            var ypix = position + itemSize
              - Math.max(midPix, scaledValue);
            context.rect(offset + xpix, ypix, barWidth, barHeight);
            context.fill();

          }

          xpix += barWidth + barSpacer;
        }

      }

    }
  },
  renderText: function (context, vector, isColor, start, end, clip, offset,
                        canvasSize) {

    context.textBaseline = 'middle';
    var positions = this.positions;
    var isColumns = this.isColumns;

    var colorModel = isColumns ? this.project.getColumnColorModel()
      : this.project.getRowColorModel();

    if (isColumns) {
      context.translate(clip.x, clip.y); // reset transform, needed for export to svg
    }
    var toStringFunction = morpheus.VectorTrack.vectorToString(vector);
    for (var i = start; i < end; i++) {
      var size = this.positions.getItemSize(i);
      if (size < 6) {
        continue;
      }
      var value = vector.getValue(i);
      if (value != null) {
        value = toStringFunction(value);
        var position = positions.getPosition(i);
        if (isColor) {
          context.fillStyle = colorModel
            .getMappedValue(vector, value);
        }
        if (isColumns) {
          context.save();
          context.translate(position + size / 2 - clip.x, canvasSize
            - clip.y - offset);
          context.rotate(-Math.PI / 2);
          context.fillText(value, 0, 0);
          context.restore();
        } else {
          context.fillText(value, offset, position + size / 2);
        }
      }
    }
  }
};
morpheus.Util.extend(morpheus.VectorTrack, morpheus.AbstractCanvas);

/**
 * Performs clustering using pairwise average linking on the given distance
 * matrix.
 *
 * @return array of nodes. Each node object contains a left, right, and
 *         distance.
 */
morpheus.AverageLinkage = function (nelements, distmatrix) {
  var j;
  var n;
  var clusterid;
  var number;
  var result;
  clusterid = []; // nelements;
  number = []; // nelements;
  result = []; // nelements - 1;
  for (var i = 0; i < nelements - 1; i++) {
    result[i] = {
      left: 0,
      right: 0,
      distance: 0
    };
  }
  /*
   * Setup a list specifying to which cluster an element belongs, and keep
   * track of the number of elements in each cluster (needed to calculate the
   * average).
   */
  for (j = 0; j < nelements; j++) {
    number[j] = 1;
    clusterid[j] = j;
  }
  // ip, jp, and distance;
  var r = {};
  // result array contains array of int left, int right, float distance;
  for (n = nelements; n > 1; n--) {
    morpheus.HCluster.findClosestPair(n, distmatrix, r);
    result[nelements - n] = {};
    result[nelements - n].distance = r.distance;
    var is = r.ip;
    var js = r.jp;
    /* Save result */
    result[nelements - n].left = clusterid[is];
    result[nelements - n].right = clusterid[js];
    /* Fix the distances */
    var sum = number[is] + number[js];
    for (j = 0; j < js; j++) {
      distmatrix[js][j] = distmatrix[is][j] * number[is]
        + distmatrix[js][j] * number[js];
      distmatrix[js][j] /= sum;
    }
    for (j = js + 1; j < is; j++) {
      distmatrix[j][js] = distmatrix[is][j] * number[is]
        + distmatrix[j][js] * number[js];
      distmatrix[j][js] /= sum;
    }
    for (j = is + 1; j < n; j++) {
      distmatrix[j][js] = distmatrix[j][is] * number[is]
        + distmatrix[j][js] * number[js];
      distmatrix[j][js] /= sum;
    }
    for (j = 0; j < is; j++) {
      distmatrix[is][j] = distmatrix[n - 1][j];
    }
    for (j = is + 1; j < n - 1; j++) {
      distmatrix[j][is] = distmatrix[n - 1][j];
    }
    /* Update number of elements in the clusters */
    number[js] = sum;
    number[is] = number[n - 1];
    /* Update clusterids */
    clusterid[js] = n - nelements - 1;
    clusterid[is] = clusterid[n - 1];
  }
  return result;
};

morpheus.CollapseDataset = function (dataset, collapseToFields,
                                     summarizeFunction, shallowCopy) {
  var vectors = [];
  for (var i = 0; i < collapseToFields.length; i++) {
    var v = dataset.getRowMetadata().getByName(collapseToFields[i]);
    if (!v) {
      throw collapseToFields[i]
      + ' not found. Available fields are '
      + morpheus.MetadataUtil.getMetadataNames(dataset
        .getRowMetadata());
    }
    vectors.push(v);
  }
  var idToIndices = morpheus.VectorUtil.createValuesToIndicesMap(vectors);
  var collapsedDataset = new morpheus.Dataset({
    name: dataset.getName(),
    rows: idToIndices.size(),
    columns: dataset.getColumnCount(),
    dataType: 'Float32'
  });
  var nseries = dataset.getSeriesCount();
  for (var series = 1; series < nseries; series++) {
    collapsedDataset.addSeries({
      name: dataset.getName(i),
      dataType: 'Float32'
    });
  }
  if (shallowCopy) {
    collapsedDataset.setColumnMetadata(dataset.getColumnMetadata());
  } else {
    morpheus.MetadataUtil.copy(dataset.getColumnMetadata(),
      collapsedDataset.getColumnMetadata());
  }
  var nfields = collapseToFields.length;
  var collapseToVectors = [];
  for (var i = 0; i < nfields; i++) {
    collapseToVectors.push(collapsedDataset.getRowMetadata().add(
      collapseToFields[i]));
  }
  var counter = 0;
  idToIndices
    .forEach(function (rowIndices, key) {
      // collapse each column separately
      var slice = morpheus.DatasetUtil.slicedView(dataset,
        rowIndices, null);
      var view = new morpheus.DatasetColumnView(slice);
      for (var series = 0; series < nseries; series++) {
        view.setSeriesIndex(series);
        for (var j = 0, ncols = dataset.getColumnCount(); j < ncols; j++) {
          view.setIndex(j);
          collapsedDataset.setValue(counter, j,
            summarizeFunction(view), series);
        }
      }
      for (var i = 0; i < nfields; i++) {
        var collapsedToVector = collapseToVectors[i];
        var vector = vectors[i];
        collapsedToVector.setValue(counter, vector
          .getValue(rowIndices[0]));
      }
      counter++;
    });
  return collapsedDataset;
};

morpheus.CompleteLinkage = function (nelements, distmatrix) {
  var j;
  var n;
  var clusterid = []; // new var[nelements];
  var result = [];// new Node[nelements - 1];
  for (var i = 0; i < nelements - 1; i++) {
    result[i] = {
      left: 0,
      right: 0,
      distance: 0
    };
  }
  /* Setup a list specifying to which cluster a gene belongs */
  for (j = 0; j < nelements; j++) {
    clusterid[j] = j;
  }
  var r = {};
  for (n = nelements; n > 1; n--) {
    morpheus.HCluster.findClosestPair(n, distmatrix, r);
    result[nelements - n].distance = r.distance;
    var is = r.ip;
    var js = r.jp;
    /* Fix the distances */
    for (j = 0; j < js; j++) {
      distmatrix[js][j] = Math.max(distmatrix[is][j], distmatrix[js][j]);
    }
    for (j = js + 1; j < is; j++) {
      distmatrix[j][js] = Math.max(distmatrix[is][j], distmatrix[j][js]);
    }
    for (j = is + 1; j < n; j++) {
      distmatrix[j][js] = Math.max(distmatrix[j][is], distmatrix[j][js]);
    }
    for (j = 0; j < is; j++) {
      distmatrix[is][j] = distmatrix[n - 1][j];
    }
    for (j = is + 1; j < n - 1; j++) {
      distmatrix[j][is] = distmatrix[n - 1][j];
    }
    /* Update clusterids */
    result[nelements - n].left = clusterid[is];
    result[nelements - n].right = clusterid[js];
    clusterid[js] = n - nelements - 1;
    clusterid[is] = clusterid[n - 1];
  }
  return result;
};

morpheus.HClusterGroupBy = function (dataset, groupByFieldNames, distanceFunction, linkageMethod) {
  var model = dataset.getRowMetadata();
  var vectors = morpheus.MetadataUtil.getVectors(dataset.getRowMetadata(),
    groupByFieldNames);
  var idToIndices = morpheus.VectorUtil.createValuesToIndicesMap(vectors);
  var reorderedIndices = [];
  var offset = 0;
  var root = {
    id: -1,
    children: [],
    height: 0
  };
  var tree = {
    maxHeight: 0,
    rootNode: root,
    leafNodes: [],
    nLeafNodes: 0
  };
  idToIndices
    .forEach(function (rowIndices, id) {
      var originalIndicesForGroup = idToIndices.get(id);
      var subset = morpheus.DatasetUtil.slicedView(dataset,
        originalIndicesForGroup, null);
      var hcl;
      var distanceMatrix = morpheus.HCluster.computeDistanceMatrix(
        subset, distanceFunction);
      hcl = new morpheus.HCluster(distanceMatrix, linkageMethod);
      var reorderedGroupIndices = hcl.reorderedIndices;
      for (var i = 0, rows = subset.getRowCount(); i < rows; i++) {
        var originalIndex = originalIndicesForGroup[reorderedGroupIndices[i]];
        reorderedIndices.push(originalIndex);
      }

      morpheus.DendrogramUtil.dfs(hcl.tree.rootNode, function (node) {
        node.index += offset;
        node.minIndex += offset;
        node.maxIndex += offset;
        node.id += offset;
        return true;
      });
      if (hcl.tree.leafNodes.length === 0) {
        tree.leafNodes = tree.leafNodes
          .concat([hcl.tree.rootNode]);
      } else {
        tree.leafNodes = tree.leafNodes.concat(hcl.tree.leafNodes);

      }

      root.children.push(hcl.tree.rootNode);
      if (!isNaN(hcl.tree.maxHeight)) {
        tree.maxHeight = Math.max(tree.maxHeight,
          hcl.tree.maxHeight);
      }
      offset += subset.getRowCount();
    });
  tree.nLeafNodes = tree.leafNodes.length;
  tree.rootNode.height = tree.maxHeight;
  this.tree = tree;
  this.reorderedIndices = reorderedIndices;
};

/**
 *
 * @param distmatrix
 * @param linkageAlgorithm {Function}
 * @constructor
 */
morpheus.HCluster = function (distmatrix, linkageAlgorithm) {
  var nelements = distmatrix.length;
  var nNodes = nelements - 1;
  if (nNodes === -1) {

    var root = {
      id: 0,
      height: 0,
      index: 0,
      minIndex: 0,
      maxIndex: 0,
      depth: 0
    };

    this.tree = {
      maxHeight: 0,
      rootNode: root,
      leafNodes: [],
      nLeafNodes: 0
    };
    this.reorderedIndices = [0];
    return;
  }
  // tree array contains array of int left, int right, float distance;
  var tree = linkageAlgorithm(nelements, distmatrix);
  var nodeorder = []; // nNodes;
  var nodecounts = [];// nNodes;
  var order = []; // nelements;
  var nodeID = []; // nNodes;
  for (var i = 0; i < nelements; i++) {
    order[i] = i;
  }
  var leftIds = []; // nNodes
  var rightIds = []; // nNodes
  for (var i = 0; i < nNodes; i++) {
    var min1 = tree[i].left;
    var min2 = tree[i].right;
    /* min1 and min2 are the elements that are to be joined */
    var order1;
    var order2;
    var counts1;
    var counts2;
    var ID1;
    var ID2;
    nodeID[i] = nNodes + (i + 2);
    if (min1 < 0) {
      var index1 = -min1 - 1;
      order1 = nodeorder[index1];
      counts1 = nodecounts[index1];
      ID1 = nodeID[index1];
      tree[i].distance = Math
        .max(tree[i].distance, tree[index1].distance);
    } else {
      order1 = order[min1];
      counts1 = 1;
      ID1 = min1;
    }
    if (min2 < 0) {
      var index2 = -min2 - 1;
      order2 = nodeorder[index2];
      counts2 = nodecounts[index2];
      ID2 = nodeID[index2];
      tree[i].distance = Math
        .max(tree[i].distance, tree[index2].distance);
    } else {
      order2 = order[min2];
      counts2 = 1;
      ID2 = min2;
    }
    leftIds[i] = ID1;
    rightIds[i] = ID2;
    nodecounts[i] = counts1 + counts2;
    nodeorder[i] = (counts1 * order1 + counts2 * order2)
      / (counts1 + counts2);
  }
  var reorderedIndices = morpheus.HCluster.treeSort(nNodes, order, nodeorder,
    nodecounts, tree);
  var idToIndex = {};
  for (var i = 0, length = reorderedIndices.length; i < length; i++) {
    var index = reorderedIndices[i];
    idToIndex[index] = i;
  }
  var nodeIdToNode = {};
  var node;
  for (var i = 0, length = nodeID.length; i < length; i++) {
    var id = nodeID[i];
    var leftId = leftIds[i];
    var lnode = nodeIdToNode[leftId];
    if (lnode === undefined) {
      lnode = {
        id: leftId
      };
      var index = idToIndex[leftId];
      lnode.index = index;
      lnode.minIndex = index;
      lnode.maxIndex = index;
      nodeIdToNode[lnode.id] = lnode;
    }
    var rightId = rightIds[i];
    var rnode = nodeIdToNode[rightId];
    if (rnode === undefined) {
      rnode = {
        id: rightId
      };
      var index = idToIndex[rightId];
      rnode.index = index;
      rnode.minIndex = index;
      rnode.maxIndex = index;
      nodeIdToNode[rnode.id] = rnode;
    }
    node = {
      id: id,
      children: lnode.index < rnode.index ? [lnode, rnode] : [rnode, lnode],
      height: tree[i].distance,
      index: (rnode.index + lnode.index) / 2.0
    };

    node.minIndex = Math.min(rnode.minIndex, lnode.minIndex);
    node.maxIndex = Math.max(rnode.maxIndex, lnode.maxIndex);
    lnode.parent = node;
    rnode.parent = node;
    nodeIdToNode[node.id] = node;
  }
  this.reorderedIndices = reorderedIndices;
  var leafNodes = [];
  for (var i = 0, length = reorderedIndices.length; i < length; i++) {
    var leaf = nodeIdToNode[reorderedIndices[i]];
    leaf.height = 0;
    leafNodes.push(leaf);
  }

  morpheus.DendrogramUtil.setNodeDepths(node);

  this.tree = {
    maxHeight: node.height,
    rootNode: node,
    leafNodes: leafNodes,
    nLeafNodes: leafNodes.length
  };
};
/*
 * Searches the distance matrix to find the pair with the shortest distance
 * between them. The indices of the pair are returned in ip and jp; the distance
 * itself is returned by the function.
 * 
 * @param n The number of elements in the distance matrix.
 * 
 * @param distmatrix. A ragged array containing the distance matrix. The number
 * of columns in each row is one less than the row index.
 * 
 * @return The first and second indices of the pair with the shortest distance.
 */
morpheus.HCluster.findClosestPair = function (n, distmatrix, r) {
  var i, j;
  var temp;
  var distance = distmatrix[1][0];
  var ip = 1;
  var jp = 0;
  for (i = 1; i < n; i++) {
    for (j = 0; j < i; j++) {
      temp = distmatrix[i][j];
      if (temp < distance) {
        distance = temp;
        ip = i;
        jp = j;
      }
    }
  }
  r.distance = distance;
  r.ip = ip;
  r.jp = jp;
};
/**
 * Creates a ragged array with the number of rows equal to the number of rows in
 * the dataset. Each row in the array has n columns where n is the row index.
 *
 * @param dataset
 * @param distanceFunction
 *            The distance function. Use 0 to assume dataset is already a
 *            distance matrix, 1 to assume dataset is already a similarity
 *            matrix.
 * @return the distance matrix
 */
morpheus.HCluster.computeDistanceMatrix = function (dataset, distanceFunction) {
  /* Set up the ragged array */
  var matrix = [];
  var n = dataset.getRowCount();
  for (var i = 1; i < n; i++) {
    matrix[i] = new Float32Array(i);
  }
  // assume dataset is already a distance matrix
  if (distanceFunction === 0) {
    for (var i = 1; i < n; i++) {
      for (var j = 0; j < i; j++) {
        matrix[i][j] = dataset.getValue(i, j);
      }
    }
  } else if (distanceFunction === 1) { // already a similarity matrix
    for (var i = 1; i < n; i++) {
      for (var j = 0; j < i; j++) {
        matrix[i][j] = 1 - dataset.getValue(i, j);
      }
    }
  } else {
    var list1 = new morpheus.DatasetRowView(dataset);
    var list2 = new morpheus.DatasetRowView(dataset);
    /* Calculate the distances and save them in the ragged array */
    for (var i = 1; i < n; i++) {
      list1.setIndex(i);
      for (var j = 0; j < i; j++) {
        matrix[i][j] = distanceFunction(list1, list2.setIndex(j));
      }
    }
  }

  return matrix;
};
morpheus.HCluster.treeSort = function (nNodes, order, nodeorder, nodecounts,
                                       tree) {
  var nElements = nNodes + 1;
  var i;
  var neworder = []; // nElements;
  var clusterids = []; // nElements;
  for (i = 0; i < nElements; i++) {
    clusterids[i] = i;
    neworder[i] = 0;
  }
  for (i = 0; i < nNodes; i++) {
    var i1 = tree[i].left;
    var i2 = tree[i].right;
    var order1 = (i1 < 0) ? nodeorder[-i1 - 1] : order[i1];
    var order2 = (i2 < 0) ? nodeorder[-i2 - 1] : order[i2];
    var count1 = (i1 < 0) ? nodecounts[-i1 - 1] : 1;
    var count2 = (i2 < 0) ? nodecounts[-i2 - 1] : 1;
    /*
     * If order1 and order2 are equal, their order is determined by the
     * order in which they were clustered
     */
    if (i1 < i2) {
      var increase = (order1 < order2) ? count1 : count2;
      var j;
      for (j = 0; j < nElements; j++) {
        var clusterid = clusterids[j];
        if ((clusterid == i1) && (order1 >= order2)) {
          neworder[j] += increase;
        }
        if ((clusterid == i2) && (order1 < order2)) {
          neworder[j] += increase;
        }
        if ((clusterid == i1) || (clusterid == i2)) {
          clusterids[j] = -i - 1;
        }
      }
    } else {
      var increase = (order1 <= order2) ? count1 : count2;
      var j;
      for (j = 0; j < nElements; j++) {
        var clusterid = clusterids[j];
        if ((clusterid == i1) && (order1 > order2)) {
          neworder[j] += increase;
        }
        if ((clusterid == i2) && (order1 <= order2)) {
          neworder[j] += increase;
        }
        if ((clusterid == i1) || (clusterid == i2)) {
          clusterids[j] = -i - 1;
        }
      }
    }
  }
  return morpheus.Util.indexSort(neworder, true);
};

/**
 * Clustering algorithm based on David Arthur and Sergei Vassilvitski k-means++ algorithm.
 * @param <T> type of the points to cluster
 * @see <a href="http://en.wikipedia.org/wiki/K-means%2B%2B">K-means++ (wikipedia)</a>
 * @since 3.2
 */

/**
 * @param dataset The dataset to cluster the rows of
 * @param distance
 * @param k The number of clusters
 * @param maxIterations The maximum number of iterations
 * @constructor
 */
morpheus.KMeansPlusPlusClusterer = function (k, maxIterations, distanceFunction) {

  var distance = function (points1, points2) {
    return distanceFunction(morpheus.VectorUtil.arrayAsVector(points1.getPoint()), morpheus.VectorUtil.arrayAsVector(points2.getPoint()));
  };

  function nextInt(upperBound) {
    return (Math.floor(Math.random() * upperBound)) | 0;
  }

  function nextDouble() {
    return Math.random();
  }

  function DoublePoint(point) {
    this.getPoint = function () {
      return point;
    };
  }

  function CentroidCluster(center) {
    var centroidPoints = [];
    this.addPoint = function (p) {
      centroidPoints.push(p);
    };
    this.getPoints = function () {
      return centroidPoints;
    };
    this.getCenter = function () {
      return center;
    };
  }

  /**
   * Runs the K-means++ clustering algorithm.
   *
   * @param points the points to cluster
   * @return a list of clusters containing the points
   */
  function cluster(points) {
    // number of clusters has to be smaller or equal the number of data points
    if (points.length < k) {
      throw 'Too many clusters';
    }

    // create the initial clusters
    var clusters = chooseInitialCenters(points);

    // create an array containing the latest assignment of a point to a cluster
    // no need to initialize the array, as it will be filled with the first assignment
    var assignments = new Int32Array(points.length);
    assignPointsToClusters(clusters, points, assignments);
    // iterate through updating the centers until we're done
    var max = (maxIterations < 0) ? Number.MAX_VALUE : maxIterations;
    for (var count = 0; count < max; count++) {
      var emptyCluster = false;
      var newClusters = [];
      for (var clusterIndex = 0; clusterIndex < clusters.length; clusterIndex++) {
        var cluster = clusters[clusterIndex];
        var newCenter;
        if (cluster.getPoints().length === 0) {
          newCenter = getPointFromLargestVarianceCluster(clusters);
          emptyCluster = true;
        } else {
          newCenter = centroidOf(cluster.getPoints(), cluster.getCenter().getPoint().length);
        }
        newClusters.push(new CentroidCluster(newCenter));
      }
      var changes = assignPointsToClusters(newClusters, points, assignments);
      clusters = newClusters;

      // if there were no more changes in the point-to-cluster assignment
      // and there are no empty clusters left, return the current clusters
      if (changes === 0 && !emptyCluster) {
        return clusters;
      }
    }
    return clusters;
  }

  /**
   * Adds the given points to the closest {@link Cluster}.
   *
   * @param clusters the {@link Cluster}s to add the points to
   * @param points the points to add to the given {@link Cluster}s
   * @param assignments points assignments to clusters
   * @return the number of points assigned to different clusters as the iteration before
   */
  function assignPointsToClusters(clusters, points, assignments) {
    var assignedDifferently = 0;
    var pointIndex = 0;
    for (var i = 0; i < points.length; i++) {
      var p = points[i];
      var clusterIndex = getNearestCluster(clusters, p);
      if (clusterIndex != assignments[pointIndex]) {
        assignedDifferently++;
      }

      var cluster = clusters[clusterIndex];
      cluster.addPoint(p);
      assignments[pointIndex++] = clusterIndex;
    }

    return assignedDifferently;
  }

  /**
   * Use K-means++ to choose the initial centers.
   *
   * @param points the points to choose the initial centers from
   * @return the initial centers
   */
  function chooseInitialCenters(points) {

    // Convert to list for indexed access. Make it unmodifiable, since removal of items
    // would screw up the logic of this method.
    var pointList = points.slice(0);

    // The number of points in the list.
    var numPoints = pointList.length;

    // Set the corresponding element in this array to indicate when
    // elements of pointList are no longer available.
    var taken = new Array(numPoints);
    for (var i = 0; i < taken.length; i++) {
      taken[i] = false;
    }

    // The resulting list of initial centers.
    var resultSet = [];

    // Choose one center uniformly at random from among the data points.
    var firstPointIndex = nextInt(numPoints);
    var firstPoint = pointList[firstPointIndex];
    resultSet.push(new CentroidCluster(firstPoint));
    // Must mark it as taken
    taken[firstPointIndex] = true;

    // To keep track of the minimum distance squared of elements of
    // pointList to elements of resultSet.

    var minDistSquared = new Float64Array(numPoints);

    // Initialize the elements.  Since the only point in resultSet is firstPoint,
    // this is very easy.
    for (var i = 0; i < numPoints; i++) {
      if (i !== firstPointIndex) { // That point isn't considered
        var d = distance(firstPoint, pointList[i]);
        minDistSquared[i] = d * d;
      }
    }

    while (resultSet.length < k) {
      // Sum up the squared distances for the points in pointList not
      // already taken.
      var distSqSum = 0.0;

      for (var i = 0; i < numPoints; i++) {
        if (!taken[i]) {
          distSqSum += minDistSquared[i];
        }
      }

      // Add one new data point as a center. Each point x is chosen with
      // probability proportional to D(x)2
      var r = nextDouble() * distSqSum;

      // The index of the next point to be added to the resultSet.
      var nextPointIndex = -1;

      // Sum through the squared min distances again, stopping when
      // sum >= r.
      var sum = 0.0;
      for (var i = 0; i < numPoints; i++) {
        if (!taken[i]) {
          sum += minDistSquared[i];
          if (sum >= r) {
            nextPointIndex = i;
            break;
          }
        }
      }

      // If it's not set to >= 0, the point wasn't found in the previous
      // for loop, probably because distances are extremely small.  Just pick
      // the last available point.
      if (nextPointIndex === -1) {
        for (var i = numPoints - 1; i >= 0; i--) {
          if (!taken[i]) {
            nextPointIndex = i;
            break;
          }
        }
      }

      // We found one.
      if (nextPointIndex >= 0) {

        var p = pointList[nextPointIndex];

        resultSet.push(new CentroidCluster(p));

        // Mark it as taken.
        taken[nextPointIndex] = true;

        if (resultSet.length < k) {
          // Now update elements of minDistSquared.  We only have to compute
          // the distance to the new center to do this.
          for (var j = 0; j < numPoints; j++) {
            // Only have to worry about the points still not taken.
            if (!taken[j]) {
              var d = distance(p, pointList[j]);
              var d2 = d * d;
              if (d2 < minDistSquared[j]) {
                minDistSquared[j] = d2;
              }
            }
          }
        }

      } else {
        // None found --
        // Break from the while loop to prevent
        // an infinite loop.
        break;
      }
    }
    return resultSet;
  }

  /**
   * Get a random point from the {@link Cluster} with the largest distance variance.
   *
   * @param clusters the {@link Cluster}s to search
   * @return a random point from the selected cluster
   * @throws ConvergenceException if clusters are all empty
   */
  function getPointFromLargestVarianceCluster(clusters) {
    var maxVariance = -Number.MAX_VALUE;
    var selected = null;
    for (var clusterIndex = 0; clusterIndex < clusters.length; clusterIndex++) {
      var cluster = clusters[clusterIndex];
      if (cluster.getPoints().length > 0) {
        // compute the distance variance of the current cluster
        var center = cluster.getCenter();
        var points = cluster.getPoints();
        var distances = new Float32Array(points.length);
        for (var i = 0; i < points.length; i++) {
          distances[i] = distance(points[i], center);
        }

        var variance = morpheus.Variance(morpheus.VectorUtil.arrayAsVector(distances));
        // select the cluster with the largest variance
        if (variance > maxVariance) {
          maxVariance = variance;
          selected = cluster;
        }
      }
    }

    // did we find at least one non-empty cluster ?
    if (selected == null) {
      throw 'Empty cluster';
    }

    // extract a random point from the cluster
    var selectedPoints = selected.getPoints();
    return selectedPoints.splice(nextInt(selectedPoints.length), 1);

  }

  // /**
  //  * Get the point farthest to its cluster center
  //  *
  //  * @param clusters the {@link Cluster}s to search
  //  * @return point farthest to its cluster center
  //  * @throws ConvergenceException if clusters are all empty
  //  */
  // function getFarthestPoint(clusters) {
  //
  //   var maxDistance = Number.NEGATIVE_INFINITY;
  //   var selectedCluster = null;
  //   var selectedPoint = -1;
  //   for (var clusterIndex = 0; clusterIndex < clusters.length; clusterIndex++) {
  //     var c = clusters[clusterIndex];
  //     // get the farthest point
  //     var center = cluster.getCenter();
  //     var points = cluster.getPoints();
  //     for (var i = 0; i < points.length; ++i) {
  //       var d = distance(points[i], center);
  //       if (d > maxDistance) {
  //         maxDistance = d;
  //         selectedCluster = cluster;
  //         selectedPoint = i;
  //       }
  //     }
  //
  //   }
  //
  //   // did we find at least one non-empty cluster ?
  //   if (selectedCluster == null) {
  //     throw 'Empty cluster';
  //   }
  //
  //   return selectedCluster.getPoints().splice(selectedPoint, 1);
  //
  // }

  /**
   * Returns the nearest {@link Cluster} to the given point
   *
   * @param clusters the {@link Cluster}s to search
   * @param point the point to find the nearest {@link Cluster} for
   * @return the index of the nearest {@link Cluster} to the given point
   */
  function getNearestCluster(clusters, point) {
    var minDistance = Number.MAX_VALUE;
    var clusterIndex = 0;
    var minCluster = 0;
    for (var i = 0; i < clusters.length; i++) {
      var c = clusters[i];
      var d = distance(point, c.getCenter());
      if (d < minDistance) {
        minDistance = d;
        minCluster = clusterIndex;
      }
      clusterIndex++;
    }
    return minCluster;
  }

  /**
   * Computes the centroid for a set of points.
   *
   * @param points the set of points
   * @param dimension the point dimension
   * @return the computed centroid for the set of points
   */
  function centroidOf(points, dimension) {
    var centroid = new Float32Array(dimension);
    for (var pointIndex = 0; pointIndex < points.length; pointIndex++) {
      var p = points[pointIndex];
      var point = p.getPoint();
      for (var i = 0; i < centroid.length; i++) {
        centroid[i] += point[i];
      }
    }
    for (var i = 0; i < centroid.length; i++) {
      centroid[i] /= points.length;
    }
    return new DoublePoint(centroid);
  }

  this.execute = function (arrayOfArraysToCluster) {
    var points = [];
    // cluster rows
    var npoints = arrayOfArraysToCluster.length;
    for (var i = 0; i < npoints; i++) {
      var p = new DoublePoint(arrayOfArraysToCluster[i]);
      p.i = i;
      points.push(p);
    }
    return cluster(points);
  };
  this.cluster = cluster;
};

morpheus.PermutationPValues = function (dataset, aIndices, bIndices,
                                        numPermutations, f) {
  var numRows = dataset.getRowCount();
  /** unpermuted scores */
  var scores = new Float32Array(numRows);
  /** Whether to smooth p values */
  var smoothPValues = true;
  var list1 = new morpheus.DatasetRowView(new morpheus.SlicedDatasetView(
    dataset, null, aIndices));
  var list2 = new morpheus.DatasetRowView(new morpheus.SlicedDatasetView(
    dataset, null, bIndices));

  for (var i = 0; i < numRows; i++) {
    scores[i] = f(list1.setIndex(i), list2.setIndex(i));
  }
  dataset = new morpheus.SlicedDatasetView(dataset, null, aIndices
    .concat(bIndices));
  var rowSpecificPValues = new Float32Array(numRows);
  var permuter = new morpheus.UnbalancedPermuter(aIndices.length,
    bIndices.length);
  var permutationScore = new morpheus.TwoClassPermutationScore();
  permutationScore.init(dataset, f);
  for (var permutationIndex = 0; permutationIndex < numPermutations; permutationIndex++) {
    permutationScore.setPermutation(permuter.next());
    for (var i = 0; i < numRows; i++) {
      var permutedScore = permutationScore.getScore(i);
      var score = scores[i];
      if (permutedScore >= score) {
        rowSpecificPValues[i]++;
      }
    }
  }
  var N = numPermutations;
  var kArray = new Uint32Array(numRows);
  for (var i = 0; i < numRows; i++) {
    var k = rowSpecificPValues[i];
    kArray[i] = k;
    var p;
    if (smoothPValues) {
      p = (k + 1) / (N + 2);
    } else {
      p = k / N;

    }
    // 2-sided p-value
    var oneMinusP = 1 - p;
    if (oneMinusP < p) {
      p = oneMinusP;
    }
    p *= 2;
    if (p === 0) {
      // ensure not degenerate case where profile is
      // completely
      // flat
      // TODO handle cases where profile is flat (but not
      // completely)

      var val = dataset.getValue(i, 0);
      var flat = true;
      for (var j = 1, cols = dataset.getColumnCount(); j < cols && flat; j++) {
        if (dataset.getValue(i, j) != val) {
          flat = false;
        }
      }
      if (flat) {
        p = 1;
      }
    }
    rowSpecificPValues[i] = p;

  }
  this.rowSpecificPValues = rowSpecificPValues;
  this.k = kArray;
  this.fdr = morpheus.FDR_BH(rowSpecificPValues);
  this.scores = scores;
};
morpheus.PermutationPValues.prototype = {
  getBonferroni: function (index) {
    return Math.min(this.rowSpecificPValues[index] * this.numRows, 1);
  }
};

morpheus.UnbalancedPermuter = function (numClassZero, numClassOne) {
  var assignments = new Uint32Array(numClassZero + numClassOne);
  var indices = new Uint32Array(numClassZero + numClassOne);
  for (var i = 0; i < indices.length; i++) {
    indices[i] = i;
  }
  var n = indices.length;
  // Returns a random integer between min (included) and max (included)
  // Using Math.round() will give you a non-uniform distribution!
  function getRandomIntInclusive(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  this.next = function () {
    // shuffle indices array
    for (var i = n - 1; i >= 1; i--) {
      var j = getRandomIntInclusive(0, i); // random integer such that
      // 0 ≤ j ≤ i
      // exchange a[j] and a[i]
      var tmp = indices[j];
      indices[j] = indices[i];
      indices[i] = tmp;
    }

    // pick 1st numClassOne indices to be class one
    for (var i = 0; i < n; i++) {
      assignments[i] = 0;
    }
    for (var i = 0; i < numClassOne; i++) {
      assignments[indices[i]] = 1;
    }

    return assignments;
  };
};

morpheus.TwoClassPermutationScore = function () {
  this.classZeroView = null;
  this.classOneView = null;

};
morpheus.TwoClassPermutationScore.prototype = {
  getScore: function (index) {
    this.classZeroView.setIndex(index);
    this.classOneView.setIndex(index);
    return this.f(this.classZeroView, this.classOneView);
  },
  init: function (dataset, f) {
    this.dataset = dataset;
    this.classZeroView = new morpheus.DatasetRowView(dataset);
    this.classOneView = new morpheus.DatasetRowView(dataset);
    this.f = f;
  },
  setPermutation: function (permutedAssignments) {
    var zeroIndices = [];
    var oneIndices = [];
    for (var i = 0, length = permutedAssignments.length; i < length; i++) {
      if (permutedAssignments[i] === 0) {
        zeroIndices.push(i);
      } else {
        oneIndices.push(i);
      }
    }

    this.classZeroView.setDataset(new morpheus.SlicedDatasetView(
      this.dataset, null, zeroIndices));
    this.classOneView.setDataset(new morpheus.SlicedDatasetView(
      this.dataset, null, oneIndices));

  }

};

morpheus.Ranking = function (values) {
  var ranks = [];
  for (var i = 0, length = values.length; i < length; i++) {
    ranks.push({
      value: values[i],
      position: i
    });
  }
  if (ranks.length === 0) {
    return [];
  }
  ranks.sort(function (a, b) {
    return (a.value < b.value ? -1 : (a.value === b.value ? 0 : 1));
  });

  var out = [];
  var pos = 1; // position in sorted array
  out[ranks[0].position] = pos;
  var tiesTrace = [];
  tiesTrace.push(ranks[0].position);
  for (var i = 1; i < ranks.length; i++) {
    if (ranks[i].value > ranks[i - 1].value) {
      // tie sequence has ended (or had length 1)
      pos = i + 1;
      if (tiesTrace.length > 1) { // if seq is nontrivial, resolve
        morpheus.Ranking.fillAverage(out, tiesTrace);
      }
      tiesTrace = [];
      tiesTrace.push(ranks[i].position);
    } else {
      // tie sequence continues
      tiesTrace.push(ranks[i].position);
    }
    out[ranks[i].position] = pos;
  }
  if (tiesTrace.length > 1) { // handle tie sequence at end
    morpheus.Ranking.fillAverage(out, tiesTrace);
  }
  return out;
};
morpheus.Ranking.fill = function (data, tiesTrace, value) {
  for (var i = 0, length = tiesTrace.length; i < length; i++) {
    data[tiesTrace[i]] = value;
  }
};
morpheus.Ranking.fillAverage = function (ranks, tiesTrace) {
  var c = ranks[tiesTrace[0]];
  // length of sequence of tied ranks
  var length = tiesTrace.length;
  morpheus.Ranking.fill(ranks, tiesTrace, (2 * c + length - 1) / 2);
};

morpheus.SingleLinkage = function (nelements, distmatrix) {
  var i, j, k;
  var nnodes = nelements - 1;
  var temp = []; // var[nnodes];
  var index = []; // new var[nelements];
  var vector = []; // var[nnodes];
  var result = []; // new Node[nelements];
  for (i = 0; i < nelements; i++) {
    result[i] = {
      left: 0,
      right: 0,
      distance: 0
    };
  }
  for (i = 0; i < nnodes; i++) {
    vector[i] = i;
  }
  for (i = 0; i < nelements; i++) {
    result[i].distance = Number.MAX_VALUE;
    for (j = 0; j < i; j++) {
      temp[j] = distmatrix[i][j];
    }
    for (j = 0; j < i; j++) {
      k = vector[j];
      if (result[j].distance >= temp[j]) {
        if (result[j].distance < temp[k]) {
          temp[k] = result[j].distance;
        }
        result[j].distance = temp[j];
        vector[j] = i;
      } else if (temp[j] < temp[k]) {
        temp[k] = temp[j];
      }
    }
    for (j = 0; j < i; j++) {
      if (result[j].distance >= result[vector[j]].distance) {
        vector[j] = i;
      }
    }
  }
  for (i = 0; i < nnodes; i++) {
    result[i].left = i;
  }
  result.sort(function (node1, node2) {
    var term1 = node1.distance;
    var term2 = node2.distance;
    if (term1 < term2)
      return -1;
    if (term1 > term2)
      return +1;
    return 0;
  });
  for (i = 0; i < nelements; i++) {
    index[i] = i;
  }
  for (i = 0; i < nnodes; i++) {
    j = result[i].left;
    k = vector[j];
    result[i].left = index[j];
    result[i].right = index[k];
    index[k] = -i - 1;
  }
  var result2 = []; // new Node[nelements - 1];
  for (i = 0; i < nelements - 1; i++) {
    result2[i] = result[i];
  }
  return result2;
};

// create main global object
var tsnejs = tsnejs || {REVISION: 'ALPHA'};

(function (global) {
	// utility function
	var assert = function (condition, message) {
		if (!condition) {
			throw message || "Assertion failed";
		}
	}

	// syntax sugar
	var getopt = function (opt, field, defaultval) {
		if (opt.hasOwnProperty(field)) {
			return opt[field];
		} else {
			return defaultval;
		}
	}

	// return 0 mean unit standard deviation random number
	var return_v = false;
	var v_val = 0.0;
	var gaussRandom = function () {
		if (return_v) {
			return_v = false;
			return v_val;
		}
		var u = 2 * Math.random() - 1;
		var v = 2 * Math.random() - 1;
		var r = u * u + v * v;
		if (r == 0 || r > 1) return gaussRandom();
		var c = Math.sqrt(-2 * Math.log(r) / r);
		v_val = v * c; // cache this for next function call for efficiency
		return_v = true;
		return u * c;
	}

	// return random normal number
	var randn = function (mu, std) {
		return mu + gaussRandom() * std;
	}

	// utilitity that creates contiguous vector of zeros of size n
	var zeros = function (n) {
		if (typeof(n) === 'undefined' || isNaN(n)) {
			return [];
		}
		if (typeof ArrayBuffer === 'undefined') {
			// lacking browser support
			var arr = new Array(n);
			for (var i = 0; i < n; i++) {
				arr[i] = 0;
			}
			return arr;
		} else {
			return new Float64Array(n); // typed arrays are faster
		}
	}

	// utility that returns 2d array filled with random numbers
	// or with value s, if provided
	var randn2d = function (n, d, s) {
		var uses = typeof s !== 'undefined';
		var x = [];
		for (var i = 0; i < n; i++) {
			var xhere = [];
			for (var j = 0; j < d; j++) {
				if (uses) {
					xhere.push(s);
				} else {
					xhere.push(randn(0.0, 1e-4));
				}
			}
			x.push(xhere);
		}
		return x;
	}

	// compute L2 distance between two vectors
	var L2 = function (x1, x2) {
		var D = x1.length;
		var d = 0;
		for (var i = 0; i < D; i++) {
			var x1i = x1[i];
			var x2i = x2[i];
			d += (x1i - x2i) * (x1i - x2i);
		}
		return d;
	}

	// compute pairwise distance in all vectors in X
	var xtod = function (X) {
		var N = X.length;
		var dist = zeros(N * N); // allocate contiguous array
		for (var i = 0; i < N; i++) {
			for (var j = i + 1; j < N; j++) {
				var d = L2(X[i], X[j]);
				dist[i * N + j] = d;
				dist[j * N + i] = d;
			}
		}
		return dist;
	}

	// compute (p_{i|j} + p_{j|i})/(2n)
	var d2p = function (D, perplexity, tol) {
		var Nf = Math.sqrt(D.length); // this better be an integer
		var N = Math.floor(Nf);
		assert(N === Nf, "D should have square number of elements.");
		var Htarget = Math.log(perplexity); // target entropy of distribution
		var P = zeros(N * N); // temporary probability matrix

		var prow = zeros(N); // a temporary storage compartment
		for (var i = 0; i < N; i++) {
			var betamin = -Infinity;
			var betamax = Infinity;
			var beta = 1; // initial value of precision
			var done = false;
			var maxtries = 50;

			// perform binary search to find a suitable precision beta
			// so that the entropy of the distribution is appropriate
			var num = 0;
			while (!done) {
				//debugger;

				// compute entropy and kernel row with beta precision
				var psum = 0.0;
				for (var j = 0; j < N; j++) {
					var pj = Math.exp(-D[i * N + j] * beta);
					if (i === j) {
						pj = 0;
					} // we dont care about diagonals
					prow[j] = pj;
					psum += pj;
				}
				// normalize p and compute entropy
				var Hhere = 0.0;
				for (var j = 0; j < N; j++) {
					var pj = prow[j] / psum;
					prow[j] = pj;
					if (pj > 1e-7) Hhere -= pj * Math.log(pj);
				}

				// adjust beta based on result
				if (Hhere > Htarget) {
					// entropy was too high (distribution too diffuse)
					// so we need to increase the precision for more peaky distribution
					betamin = beta; // move up the bounds
					if (betamax === Infinity) {
						beta = beta * 2;
					}
					else {
						beta = (beta + betamax) / 2;
					}

				} else {
					// converse case. make distrubtion less peaky
					betamax = beta;
					if (betamin === -Infinity) {
						beta = beta / 2;
					}
					else {
						beta = (beta + betamin) / 2;
					}
				}

				// stopping conditions: too many tries or got a good precision
				num++;
				if (Math.abs(Hhere - Htarget) < tol) {
					done = true;
				}
				if (num >= maxtries) {
					done = true;
				}
			}

			// console.log('data point ' + i + ' gets precision ' + beta + ' after ' + num + ' binary search steps.');
			// copy over the final prow to P at row i
			for (var j = 0; j < N; j++) {
				P[i * N + j] = prow[j];
			}

		} // end loop over examples i

		// symmetrize P and normalize it to sum to 1 over all ij
		var Pout = zeros(N * N);
		var N2 = N * 2;
		for (var i = 0; i < N; i++) {
			for (var j = 0; j < N; j++) {
				Pout[i * N + j] = Math.max((P[i * N + j] + P[j * N + i]) / N2, 1e-100);
			}
		}

		return Pout;
	}

	// helper function
	function sign(x) {
		return x > 0 ? 1 : x < 0 ? -1 : 0;
	}

	var tSNE = function (opt) {
		var opt = opt || {};
		this.perplexity = getopt(opt, "perplexity", 30); // effective number of nearest neighbors
		this.dim = getopt(opt, "dim", 2); // by default 2-D tSNE
		this.epsilon = getopt(opt, "epsilon", 10); // learning rate

		this.iter = 0;
	}

	tSNE.prototype = {

		// this function takes a set of high-dimensional points
		// and creates matrix P from them using gaussian kernel
		initDataRaw: function (X) {
			var N = X.length;
			var D = X[0].length;
			assert(N > 0, " X is empty? You must have some data!");
			assert(D > 0, " X[0] is empty? Where is the data?");
			var dists = xtod(X); // convert X to distances using gaussian kernel
			this.P = d2p(dists, this.perplexity, 1e-4); // attach to object
			this.N = N; // back up the size of the dataset
			this.initSolution(); // refresh this
		},

		// this function takes a given distance matrix and creates
		// matrix P from them.
		// D is assumed to be provided as a list of lists, and should be symmetric
		initDataDist: function (D) {
			var N = D.length;
			assert(N > 0, " X is empty? You must have some data!");
			// convert D to a (fast) typed array version
			var dists = zeros(N * N); // allocate contiguous array
			for (var i = 0; i < N; i++) {
				for (var j = i + 1; j < N; j++) {
					var d = D[i][j];
					dists[i * N + j] = d;
					dists[j * N + i] = d;
				}
			}
			this.P = d2p(dists, this.perplexity, 1e-4);
			this.N = N;
			this.initSolution(); // refresh this
		},

		// (re)initializes the solution to random
		initSolution: function () {
			// generate random solution to t-SNE
			this.Y = randn2d(this.N, this.dim); // the solution
			this.gains = randn2d(this.N, this.dim, 1.0); // step gains to accelerate progress in unchanging directions
			this.ystep = randn2d(this.N, this.dim, 0.0); // momentum accumulator
			this.iter = 0;
		},

		// return pointer to current solution
		getSolution: function () {
			return this.Y;
		},

		// perform a single step of optimization to improve the embedding
		step: function () {
			this.iter += 1;
			var N = this.N;

			var cg = this.costGrad(this.Y); // evaluate gradient
			var cost = cg.cost;
			var grad = cg.grad;

			// perform gradient step
			var ymean = zeros(this.dim);
			for (var i = 0; i < N; i++) {
				for (var d = 0; d < this.dim; d++) {
					var gid = grad[i][d];
					var sid = this.ystep[i][d];
					var gainid = this.gains[i][d];

					// compute gain update
					var newgain = sign(gid) === sign(sid) ? gainid * 0.8 : gainid + 0.2;
					if (newgain < 0.01) newgain = 0.01; // clamp
					this.gains[i][d] = newgain; // store for next turn

					// compute momentum step direction
					var momval = this.iter < 250 ? 0.5 : 0.8;
					var newsid = momval * sid - this.epsilon * newgain * grad[i][d];
					this.ystep[i][d] = newsid; // remember the step we took

					// step!
					this.Y[i][d] += newsid;

					ymean[d] += this.Y[i][d]; // accumulate mean so that we can center later
				}
			}

			// reproject Y to be zero mean
			for (var i = 0; i < N; i++) {
				for (var d = 0; d < this.dim; d++) {
					this.Y[i][d] -= ymean[d] / N;
				}
			}

			//if(this.iter%100===0) console.log('iter ' + this.iter + ', cost: ' + cost);
			return cost; // return current cost
		},

		// for debugging: gradient check
		debugGrad: function () {
			var N = this.N;

			var cg = this.costGrad(this.Y); // evaluate gradient
			var cost = cg.cost;
			var grad = cg.grad;

			var e = 1e-5;
			for (var i = 0; i < N; i++) {
				for (var d = 0; d < this.dim; d++) {
					var yold = this.Y[i][d];

					this.Y[i][d] = yold + e;
					var cg0 = this.costGrad(this.Y);

					this.Y[i][d] = yold - e;
					var cg1 = this.costGrad(this.Y);

					var analytic = grad[i][d];
					var numerical = (cg0.cost - cg1.cost) / ( 2 * e );
					console.log(i + ',' + d + ': gradcheck analytic: ' + analytic + ' vs. numerical: ' + numerical);

					this.Y[i][d] = yold;
				}
			}
		},

		// return cost and gradient, given an arrangement
		costGrad: function (Y) {
			var N = this.N;
			var dim = this.dim; // dim of output space
			var P = this.P;

			var pmul = this.iter < 100 ? 4 : 1; // trick that helps with local optima

			// compute current Q distribution, unnormalized first
			var Qu = zeros(N * N);
			var qsum = 0.0;
			for (var i = 0; i < N; i++) {
				for (var j = i + 1; j < N; j++) {
					var dsum = 0.0;
					for (var d = 0; d < dim; d++) {
						var dhere = Y[i][d] - Y[j][d];
						dsum += dhere * dhere;
					}
					var qu = 1.0 / (1.0 + dsum); // Student t-distribution
					Qu[i * N + j] = qu;
					Qu[j * N + i] = qu;
					qsum += 2 * qu;
				}
			}
			// normalize Q distribution to sum to 1
			var NN = N * N;
			var Q = zeros(NN);
			for (var q = 0; q < NN; q++) {
				Q[q] = Math.max(Qu[q] / qsum, 1e-100);
			}

			var cost = 0.0;
			var grad = [];
			for (var i = 0; i < N; i++) {
				var gsum = new Array(dim); // init grad for point i
				for (var d = 0; d < dim; d++) {
					gsum[d] = 0.0;
				}
				for (var j = 0; j < N; j++) {
					cost += -P[i * N + j] * Math.log(Q[i * N + j]); // accumulate cost (the non-constant portion at least...)
					var premult = 4 * (pmul * P[i * N + j] - Q[i * N + j]) * Qu[i * N + j];
					for (var d = 0; d < dim; d++) {
						gsum[d] += premult * (Y[i][d] - Y[j][d]);
					}
				}
				grad.push(gsum);
			}

			return {
				cost: cost,
				grad: grad
			};
		}
	}

	global.tSNE = tSNE; // export tSNE class
})(tsnejs);




})(typeof window !== 'undefined' ? window : this);
